{"version":3,"sources":["../src/assertions.ts","../src/baseX.ts","../src/base10.ts","../src/base16.ts","../src/base58.ts","../src/baseX-reslice.ts","../src/base64.ts","../src/null-characters.ts","../../text-encoding-impl/src/index.browser.ts","../src/utf8.ts"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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","file":"index.browser.mjs","sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    toArrayBuffer,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(toArrayBuffer(bytes), offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"]}