{"version":3,"sources":["../src/application-domain.ts","../src/codecs/application-domain.ts","../src/codecs/signing-domain.ts","../src/codecs/preamble-common.ts","../src/codecs/signatures.ts","../src/codecs/envelope.ts","../src/content.ts","../src/message-v0.ts","../src/codecs/content.ts","../src/codecs/preamble-v0.ts","../src/codecs/message-v0.ts","../src/codecs/preamble-v1.ts","../src/codecs/message-v1.ts","../src/codecs/message.ts","../src/envelope-common.ts","../src/envelope-v0.ts","../src/envelope-v1.ts","../src/envelope.ts","../src/signatures.ts"],"names":["isAddress","assertIsAddress","isSolanaError","SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE","SolanaError","SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE","SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH","SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH","transformEncoder","getAddressEncoder","getAddressDecoder","combineCodec","getConstantDecoder","getConstantEncoder","getHiddenPrefixDecoder","getStructDecoder","getHiddenPrefixEncoder","getStructEncoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED","SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION","transformDecoder","getU8Decoder","getU8Encoder","getBytesDecoder","offsetDecoder","getArrayDecoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO","getArrayEncoder","fixEncoderSize","getBytesEncoder","address","SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH","fixDecoderSize","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH","OffchainMessageContentFormat","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY","SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE","getUtf8Encoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED","getEnumDecoder","getEnumEncoder","getU16Decoder","getU16Encoder","getTupleDecoder","getUtf8Decoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH","SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE","getTupleEncoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE","SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED","createDecoder","createEncoder","getAddressFromPublicKey","signBytes","bytesEqual","SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE","SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING","getPublicKeyFromAddress","verifySignature","SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { assertIsAddress, isAddress } from '@solana/addresses';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * A 32-byte array identifying the application requesting off-chain message signing.\n *\n * This may be any arbitrary bytes. For instance the on-chain address of a program, DAO instance,\n * Candy Machine, et cetera.\n *\n * This field SHOULD be displayed to users as a base58-encoded ASCII string rather than interpreted\n * otherwise.\n */\nexport type OffchainMessageApplicationDomain = Brand<\n    EncodedString<string, 'base58'>,\n    'OffchainMessageApplicationDomain'\n>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the\n * {@link OffchainMessageApplicationDomain} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * if (isOffchainMessageApplicationDomain(applicationDomain)) {\n *     // At this point, `applicationDomain` has been refined to an\n *     // `OffchainMessageApplcationDomain` that can be used to craft a message.\n *     const offchainMessage: OffchainMessageV0 = {\n *         applicationDomain:\n *             offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *     };\n * } else {\n *     setError(`${applicationDomain} is not a valid application domain for an offchain message`);\n * }\n * ```\n */\nexport function isOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): putativeApplicationDomain is OffchainMessageApplicationDomain {\n    return isAddress(putativeApplicationDomain);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an offchain message\n * application domain, from an untrusted network API or user input. Use this function to assert that\n * such an arbitrary string is a base58-encoded application domain.\n *\n * @example\n * ```ts\n * import { assertIsOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * // Imagine a function that determines whether an application domain is valid.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const applicationDomain: string = applicationDomainInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `applicationDomain` to `OffchainMessageApplicationDomain`.\n *         assertIsOffchainMessageApplicationDomain(applicationDomain);\n *         // At this point, `applicationDomain` is a `OffchainMessageApplicationDomain` that can be\n *         // used to craft an offchain message.\n *         const offchainMessage: OffchainMessageV0 = {\n *             applicationDomain:\n *                 offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `applicationDomain` turned out not to be a base58-encoded application domain\n *     }\n * }\n * ```\n */\nexport function assertIsOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): asserts putativeApplicationDomain is OffchainMessageApplicationDomain {\n    try {\n        assertIsAddress(putativeApplicationDomain);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n                error.context,\n            );\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n                error.context,\n            );\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an offchain message application domain with _coercing_ it\n * to the {@link OffchainMessageApplicationDomain} type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * const offchainMessage: OffchainMessageV0 = {\n *     applicationDomain:\n *         offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *     // ...\n * };\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good application domain as a string, it's more efficient to typecast\n * > it rather than to use the {@link offchainMessageApplicationDomain} helper, because the helper\n * > unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageApplicationDomain } from '@solana/offchain-messages';\n * >\n * > const applicationDomain =\n * >     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * > ```\n */\nexport function offchainMessageApplicationDomain(putativeApplicationDomain: string): OffchainMessageApplicationDomain {\n    assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);\n    return putativeApplicationDomain;\n}\n","import { Address, getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformEncoder,\n} from '@solana/codecs-core';\n\nimport { OffchainMessageApplicationDomain, offchainMessageApplicationDomain } from '../application-domain';\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded offchain message application\n * domain to a byte array.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainEncoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomain =\n *     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * const offchainMessageApplicationDomainEncoder = getOffchainMessageApplicationDomainEncoder();\n * const offchainMessageApplicationDomainBytes =\n *     offchainMessageApplicationDomainEncoder.encode(offchainMessageApplicationDomain);\n * // Uint8Array(32) [\n * //   247, 203,  28,  80,  52, 240, 169,  19,\n * //    21, 103, 107, 119,  91, 235,  13,  48,\n * //   194, 169, 148, 160,  78, 105, 235,  37,\n * //   232, 160,  49,  47,  64,  89,  18, 153,\n * // ]\n * ```\n */\nexport function getOffchainMessageApplicationDomainEncoder(): FixedSizeEncoder<OffchainMessageApplicationDomain, 32> {\n    return transformEncoder(\n        getAddressEncoder(),\n        putativeApplicationDomain => offchainMessageApplicationDomain(putativeApplicationDomain) as string as Address,\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an offchain\n * message application domain to the base58-encoded representation of that application domain.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomainBytes = new Uint8Array([\n *     247, 203,  28,  80,  52, 240, 169,  19,\n *      21, 103, 107, 119,  91, 235,  13,  48,\n *     194, 169, 148, 160,  78, 105, 235,  37,\n *     232, 160,  49,  47,  64,  89,  18, 153,\n * ]);\n * const offchainMessageApplicationDomainDecoder = getOffchainMessageApplicationDomainDecoder();\n * const offchainMessageApplicationDomain =\n *     offchainMessageApplicationDomainDecoder.decode(offchainMessageApplicationDomainBytes);\n *     // HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx\n * ```\n */\nexport function getOffchainMessageApplicationDomainDecoder(): FixedSizeDecoder<OffchainMessageApplicationDomain, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<\n        OffchainMessageApplicationDomain,\n        32\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded offchain message\n * application domain.\n *\n * @see {@link getOffchainMessageApplicationDomainDecoder}\n * @see {@link getOffchainMessageApplicationDomainEncoder}\n */\nexport function getOffchainMessageApplicationDomainCodec(): FixedSizeCodec<\n    OffchainMessageApplicationDomain,\n    OffchainMessageApplicationDomain,\n    32\n> {\n    return combineCodec(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getConstantDecoder, getConstantEncoder } from '@solana/codecs-data-structures';\n\n// The string `'\\xffsolana offchain'`\nconst OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES: ReadonlyUint8Array = new Uint8Array([\n    0xff, 0x73, 0x6f, 0x6c, 0x61, 0x6e, 0x61, 0x20, 0x6f, 0x66, 0x66, 0x63, 0x68, 0x61, 0x69, 0x6e,\n]);\n\nexport function getOffchainMessageSigningDomainDecoder(): FixedSizeDecoder<void, 16> {\n    return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeDecoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainEncoder(): FixedSizeEncoder<void, 16> {\n    return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeEncoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainCodec(): FixedSizeCodec<void, void, 16> {\n    return combineCodec(getOffchainMessageSigningDomainEncoder(), getOffchainMessageSigningDomainDecoder());\n}\n","import { Address, getAddressDecoder } from '@solana/addresses';\nimport {\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    offsetDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getHiddenPrefixDecoder,\n    getHiddenPrefixEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageVersion } from '../version';\nimport { getOffchainMessageSigningDomainDecoder, getOffchainMessageSigningDomainEncoder } from './signing-domain';\n\ntype TDecoderFields = Parameters<typeof getStructDecoder>[0];\ntype TEncoderFields = Parameters<typeof getStructEncoder>[0];\n\nfunction getSigningDomainPrefixedDecoder<const T extends TDecoderFields>(...fields: T) {\n    return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);\n}\n\nfunction getSigningDomainPrefixedEncoder<const T extends TEncoderFields>(...fields: T) {\n    return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);\n}\n\nfunction getVersionTransformer(fixedVersion?: OffchainMessageVersion) {\n    return (version: number) => {\n        if (version > 1) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                unsupportedVersion: version,\n            });\n        }\n        if (fixedVersion != null && version !== fixedVersion) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {\n                actualVersion: version,\n                expectedVersion: fixedVersion,\n            });\n        }\n        return version;\n    };\n}\n\nexport function createOffchainMessagePreambleDecoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TDecoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer(version)) as FixedSizeDecoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function createOffchainMessagePreambleEncoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TEncoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedEncoder(\n        ['version', transformEncoder(getU8Encoder(), getVersionTransformer(version)) as FixedSizeEncoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function decodeRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer())],\n        ['bytesAfterVersion', getBytesDecoder()],\n    ).decode(bytes);\n    return offsetDecoder(\n        transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n            if (signatoryAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses;\n        }),\n        {\n            preOffset: ({ preOffset }) =>\n                preOffset +\n                (version === 0\n                    ? 32 + 1 // skip the application domain and message format of v0 messages\n                    : 0),\n        },\n    ).decode(bytesAfterVersion);\n}\n\nexport function getSignatoriesComparator(): (a: ReadonlyUint8Array, b: ReadonlyUint8Array) => -1 | 0 | 1 {\n    return (x, y) => {\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for (let ii = 0; ii < x.length; ii++) {\n            if (x[ii] === y[ii]) {\n                continue;\n            } else {\n                return x[ii] < y[ii] ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\n\nfunction getSignaturesToEncode(signaturesMap: OffchainMessageEnvelope['signatures']): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<OffchainMessageEnvelope['signatures']> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getU8Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { Address, address } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\nimport { OffchainMessageBytes } from '../message';\nimport { decodeRequiredSignatoryAddresses } from './preamble-common';\nimport { getSignaturesEncoder } from './signatures';\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageEnvelope} to a byte array\n * appropriate for sharing with a third party for validation.\n */\nexport function getOffchainMessageEnvelopeEncoder(): VariableSizeEncoder<OffchainMessageEnvelope> {\n    return transformEncoder(\n        getStructEncoder([\n            ['signatures', getSignaturesEncoder()],\n            ['content', getBytesEncoder()],\n        ]),\n        envelope => {\n            const signaturesMapAddresses = Object.keys(envelope.signatures).map(address);\n            if (signaturesMapAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n            }\n            const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);\n            const missingRequiredSigners = [];\n            const unexpectedSigners = [];\n            for (const address of signatoryAddresses) {\n                if (!signaturesMapAddresses.includes(address)) {\n                    missingRequiredSigners.push(address);\n                }\n            }\n            for (const address of signaturesMapAddresses) {\n                if (!signatoryAddresses.includes(address)) {\n                    unexpectedSigners.push(address);\n                }\n            }\n            if (missingRequiredSigners.length || unexpectedSigners.length) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {\n                    missingRequiredSigners,\n                    unexpectedSigners,\n                });\n            }\n            const orderedSignatureMap: OffchainMessageEnvelope['signatures'] = {};\n            for (const address of signatoryAddresses) {\n                orderedSignatureMap[address] = envelope.signatures[address];\n            }\n            return {\n                ...envelope,\n                signatures: orderedSignatureMap,\n            };\n        },\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana offchain message format\n * to a {@link OffchainMessageEnvelope} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageEnvelopeDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelopeDecoder = getOffchainMessageEnvelopeDecoder();\n * const offchainMessageEnvelope = offchainMessageEnvelopeDecoder.decode(offchainMessageEnvelopeBytes);\n * for (const [address, signature] in Object.entries(offchainMessageEnvelope.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\nexport function getOffchainMessageEnvelopeDecoder(): VariableSizeDecoder<OffchainMessageEnvelope> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getU8Decoder() })],\n            ['content', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedOffchainMessageEnvelope,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageEnvelope}\n *\n * @see {@link getOffchainMessageEnvelopeDecoder}\n * @see {@link getOffchainMessageEnvelopeEncoder}\n */\nexport function getOffchainMessageEnvelopeCodec() {\n    return combineCodec(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());\n}\n\ntype PartiallyDecodedOffchainMessageEnvelope = {\n    content: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedOffchainMessageEnvelope(\n    offchainMessageEnvelope: PartiallyDecodedOffchainMessageEnvelope,\n): OffchainMessageEnvelope {\n    const { content, signatures } = offchainMessageEnvelope;\n\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);\n\n    // Signer addresses and signatures must be the same length\n    // We encode an all-zero signature when the signature is missing\n    if (signatoryAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: signatoryAddresses.length,\n            signatoryAddresses,\n            signaturesLength: signatures.length,\n        });\n    }\n\n    // Combine the signer addresses + signatures into the signatures map\n    const signaturesMap: OffchainMessageEnvelope['signatures'] = {};\n    signatoryAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return Object.freeze({\n        content: content as OffchainMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    });\n}\n\nfunction decodeAndValidateRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);\n\n    if (signatoryAddresses.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n    }\n\n    return signatoryAddresses;\n}\n","import { getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nconst MAX_BODY_BYTES =\n    // Largest 16-bit unsigned integer\n    0xffff;\nconst MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE =\n    // Space remaining in the mininum IPv6 MTU after network header overhead\n    1232;\n\n/**\n * A restriction on what characters the message text can contain and how long it can be.\n *\n * The aim of this restriction is to make a message more likely to be signable by a hardware wallet\n * that imposes limits on message size. In the case of wanting a message to be clear-signable,\n * restricting the character set to ASCII may ensure that certain models of hardware wallet without\n * extended character sets can display it onscreen.\n *\n * @remarks This only applies to v0 messages.\n */\nexport enum OffchainMessageContentFormat {\n    RESTRICTED_ASCII_1232_BYTES_MAX = 0,\n    UTF8_1232_BYTES_MAX = 1,\n    UTF8_65535_BYTES_MAX = 2,\n}\n\n/**\n * Describes message text that is no more than 1232 bytes long and made up of characters with ASCII\n * character codes in the range [0x20, 0x7e].\n *\n * @remarks This type aims to restrict text to that which can be clear-signed by hardware wallets\n * that can only display ASCII characters onscreen.\n */\nexport type OffchainMessageContentRestrictedAsciiOf1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentRestrictedAsciiOf1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 1232 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 65535 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of65535BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of65535BytesMax'>;\n}>;\n\nexport type OffchainMessageContent =\n    | OffchainMessageContentRestrictedAsciiOf1232BytesMax\n    | OffchainMessageContentUtf8Of1232BytesMax\n    | OffchainMessageContentUtf8Of65535BytesMax;\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (isTextRestrictedAscii(putativeContent.text) === false) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX ||\n        putativeContent.text.length === 0 ||\n        isTextRestrictedAscii(putativeContent.text) === false\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is restricted ASCII with\n * _coercing_ it to the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type. It's most\n * useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageContentRestrictedAsciiOf1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: offchainMessageContentRestrictedAsciiOf1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentRestrictedAsciiOf1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good ASCII content as a string, it's more efficient to typecast it\n * > rather than to use the {@link offchainMessageContentRestrictedAsciiOf1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n * >         text: 'Hello world',\n * >     } as OffchainMessageContentRestrictedAsciiOf1232BytesMax<'Hello world'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentRestrictedAsciiOf1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentRestrictedAsciiOf1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        });\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 1232 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of1232BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 1232 bytes, it's more efficient\n * > to typecast it rather than to use the {@link offchainMessageContentUtf8Of1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of1232BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of65535BytesMax}\n * type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of65535BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 65535 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of65535BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of65535BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of65535BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of65535BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 65535 bytes, it's more efficient\n * > to typecast it rather than to use the {@link OffchainMessageContentUtf8Of65535BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of65535BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of65535BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of65535BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);\n    return putativeContent;\n}\n\nfunction isTextRestrictedAscii(putativeRestrictedAsciiString: string): boolean {\n    return /^[\\x20-\\x7e]+$/.test(putativeRestrictedAsciiString);\n}\n","import {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of65535BytesMax,\n    OffchainMessageContentFormat,\n    OffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    OffchainMessageContentUtf8Of1232BytesMax,\n    OffchainMessageContentUtf8Of65535BytesMax,\n} from './content';\nimport { OffchainMessagePreambleV0 } from './preamble-v0';\nimport { OffchainMessageWithRequiredSignatories } from './signatures';\n\nexport type BaseOffchainMessageV0 = Omit<\n    OffchainMessagePreambleV0,\n    'messageFormat' | 'messageLength' | 'requiredSignatories'\n>;\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax}\n */\nexport interface OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent {\n    readonly content: OffchainMessageContentRestrictedAsciiOf1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link offchainMessageContentUtf8Of1232BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of1232BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentUtf8Of65535BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of65535BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of65535BytesMax;\n}\n\n/**\n * A union of the formats a v0 message's contents can take.\n *\n * @remarks From v1 and onward, an offchain message has only one format: UTF-8 text of arbitrary\n * length.\n */\nexport type OffchainMessageWithContent =\n    | OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent\n    | OffchainMessageWithUtf8Of1232BytesMaxContent\n    | OffchainMessageWithUtf8Of65535BytesMaxContent;\n\nexport type OffchainMessageV0 = BaseOffchainMessageV0 &\n    OffchainMessageWithContent &\n    OffchainMessageWithRequiredSignatories;\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n        }>,\n): asserts putativeMessage is OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link offchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link offchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentUtf8Of65535BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of65535BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of65535BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getEnumDecoder, getEnumEncoder } from '@solana/codecs-data-structures';\n\nimport { OffchainMessageContentFormat } from '../content';\n\nexport function getOffchainMessageContentFormatDecoder(): FixedSizeDecoder<OffchainMessageContentFormat, 1> {\n    return getEnumDecoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatEncoder(): FixedSizeEncoder<OffchainMessageContentFormat, 1> {\n    return getEnumEncoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatCodec(): FixedSizeCodec<\n    OffchainMessageContentFormat,\n    OffchainMessageContentFormat,\n    1\n> {\n    return combineCodec(getOffchainMessageContentFormatEncoder(), getOffchainMessageContentFormatDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder, getU16Decoder, getU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\n\nimport { OffchainMessagePreambleV0 } from '../preamble-v0';\nimport {\n    getOffchainMessageApplicationDomainDecoder,\n    getOffchainMessageApplicationDomainEncoder,\n} from './application-domain';\nimport { getOffchainMessageContentFormatDecoder, getOffchainMessageContentFormatEncoder } from './content';\nimport { createOffchainMessagePreambleDecoder, createOffchainMessagePreambleEncoder } from './preamble-common';\n\nexport function getOffchainMessageV0PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleDecoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainDecoder()],\n        ['messageFormat', getOffchainMessageContentFormatDecoder()],\n        [\n            'requiredSignatories',\n            transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                return signatoryAddresses.map(address => Object.freeze({ address }));\n            }),\n        ],\n        ['messageLength', getU16Decoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleEncoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainEncoder()],\n        ['messageFormat', getOffchainMessageContentFormatEncoder()],\n        [\n            'requiredSignatories',\n            transformEncoder(\n                getArrayEncoder(getAddressEncoder(), { size: getU8Encoder() }),\n                (signatoryAddresses: OffchainMessagePreambleV0['requiredSignatories']) => {\n                    if (signatoryAddresses.length === 0) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                    }\n                    return signatoryAddresses.map(({ address }) => address);\n                },\n            ),\n        ],\n        ['messageLength', getU16Encoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV0> {\n    return combineCodec(getOffchainMessageV0PreambleEncoder(), getOffchainMessageV0PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageContentFormat } from '../content';\nimport {\n    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageUtf8Of1232BytesMax,\n    assertIsOffchainMessageUtf8Of65535BytesMax,\n    OffchainMessageV0,\n} from '../message-v0';\nimport { getOffchainMessageV0PreambleDecoder, getOffchainMessageV0PreambleEncoder } from './preamble-v0';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV0} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV0Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV0Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v0 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 0.\n */\nexport function getOffchainMessageV0Decoder(): VariableSizeDecoder<OffchainMessageV0> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]),\n        ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {\n            const actualLength = getUtf8Encoder().getSizeFromValue(text);\n            if (messageLength !== actualLength) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {\n                    actualLength: actualLength,\n                    specifiedLength: messageLength,\n                });\n            }\n            const offchainMessage: Omit<OffchainMessageV0, 'content'> &\n                Readonly<{\n                    content: {\n                        format: OffchainMessageContentFormat;\n                        text: string;\n                    };\n                }> = Object.freeze({\n                ...preambleRest,\n                content: Object.freeze({\n                    format: messageFormat,\n                    text,\n                }),\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n            switch (messageFormat) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: messageFormat satisfies never,\n                    });\n                }\n            }\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV0} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV0Encoder(): VariableSizeEncoder<OffchainMessageV0> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...preamble } = offchainMessage;\n            switch (offchainMessage.content.format) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    break;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: offchainMessage.content satisfies never,\n                    });\n                }\n            }\n            const messageLength = getUtf8Encoder().getSizeFromValue(content.text);\n            const compiledPreamble = {\n                ...preamble,\n                messageFormat: content.format,\n                messageLength,\n            };\n            return [compiledPreamble, content.text] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV0}\n *\n * @see {@link getOffchainMessageV0Decoder}\n * @see {@link getOffchainMessageV0Encoder}\n */\nexport function getOffchainMessageV0Codec(): VariableSizeCodec<OffchainMessageV0> {\n    return combineCodec(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessagePreambleV1 } from '../preamble-v1';\nimport {\n    createOffchainMessagePreambleDecoder,\n    createOffchainMessagePreambleEncoder,\n    getSignatoriesComparator,\n} from './preamble-common';\n\nexport function getOffchainMessageV1PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleDecoder(/* version */ 1, [\n        'requiredSignatories',\n        transformDecoder(\n            getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: getU8Decoder() }),\n            signatoryAddressesBytes => {\n                if (signatoryAddressesBytes.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const comparator = getSignatoriesComparator();\n                for (let ii = 0; ii < signatoryAddressesBytes.length - 1; ii++) {\n                    switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {\n                        case 0:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                        case 1:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);\n                    }\n                }\n                const addressDecoder = getAddressDecoder();\n                return signatoryAddressesBytes.map(addressBytes =>\n                    Object.freeze({\n                        address: addressDecoder.decode(addressBytes),\n                    }),\n                );\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleEncoder(/* version */ 1, [\n        'requiredSignatories',\n        transformEncoder(\n            transformEncoder(\n                getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }),\n                (signatoryAddressesBytes: readonly ReadonlyUint8Array[]) => {\n                    return signatoryAddressesBytes.toSorted(getSignatoriesComparator());\n                },\n            ),\n            (signatoryAddresses: OffchainMessagePreambleV1['requiredSignatories']) => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const seenSignatories = new Set();\n                for (const { address } of signatoryAddresses) {\n                    if (seenSignatories.has(address)) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                    }\n                    seenSignatories.add(address);\n                }\n                const addressEncoder = getAddressEncoder();\n                return signatoryAddresses.map(({ address }) => addressEncoder.encode(address));\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV1> {\n    return combineCodec(getOffchainMessageV1PreambleEncoder(), getOffchainMessageV1PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY, SolanaError } from '@solana/errors';\n\nimport { OffchainMessageV1 } from '../message-v1';\nimport { getOffchainMessageV1PreambleDecoder, getOffchainMessageV1PreambleEncoder } from './preamble-v1';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV1} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV1Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV1Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v1 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 1.\n */\nexport function getOffchainMessageV1Decoder(): VariableSizeDecoder<OffchainMessageV1> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]),\n        ([{ requiredSignatories, ...preambleRest }, text]) => {\n            if (text.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return Object.freeze({\n                ...preambleRest,\n                content: text,\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV1} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV1Encoder(): VariableSizeEncoder<OffchainMessageV1> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...compiledPreamble } = offchainMessage;\n            if (content.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return [compiledPreamble, content] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV1}\n *\n * @see {@link getOffchainMessageV1Decoder}\n * @see {@link getOffchainMessageV1Encoder}\n */\nexport function getOffchainMessageV1Codec(): VariableSizeCodec<OffchainMessageV1> {\n    return combineCodec(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getHiddenPrefixDecoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, SolanaError } from '@solana/errors';\n\nimport { OffchainMessage } from '../message';\nimport { getOffchainMessageV0Decoder, getOffchainMessageV0Encoder } from './message-v0';\nimport { getOffchainMessageV1Decoder, getOffchainMessageV1Encoder } from './message-v1';\nimport { getOffchainMessageSigningDomainDecoder } from './signing-domain';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessage} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageDecoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded an offchain message (version: ${offchainMessage.version}`);\n * ```\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the decoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageDecoder(): VariableSizeDecoder<OffchainMessage> {\n    return createDecoder({\n        read(bytes, offset): [OffchainMessage, number] {\n            const version = getHiddenPrefixDecoder(getU8Decoder(), [\n                // Discard the signing domain\n                getOffchainMessageSigningDomainDecoder(),\n            ]).decode(bytes, offset);\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Decoder().read(bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Decoder().read(bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessage} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the encoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageEncoder(): VariableSizeEncoder<OffchainMessage> {\n    return createEncoder({\n        getSizeFromValue: offchainMessage => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);\n                case 1:\n                    return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n        write: (offchainMessage, bytes, offset) => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessage}\n *\n * @see {@link getOffchainMessageDecoder}\n * @see {@link getOffchainMessageEncoder}\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the codecs specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageCodec(): VariableSizeCodec<OffchainMessage> {\n    return combineCodec(getOffchainMessageEncoder(), getOffchainMessageDecoder());\n}\n","import { VariableSizeEncoder } from '@solana/codecs-core';\n\nimport { OffchainMessageEnvelope } from './envelope';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\nexport function compileOffchainMessageEnvelopeUsingEncoder<T extends OffchainMessage>(\n    offchainMessage: T,\n    encoder: VariableSizeEncoder<T>,\n) {\n    const offchainMessageBytes = encoder.encode(offchainMessage) as OffchainMessageBytes;\n    const signatures: OffchainMessageEnvelope['signatures'] = {};\n    for (const { address } of offchainMessage.requiredSignatories) {\n        signatures[address] = null;\n    }\n    return Object.freeze({\n        content: offchainMessageBytes,\n        signatures: Object.freeze(signatures),\n    });\n}\n","import { getOffchainMessageV0Encoder } from './codecs/message-v0';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV0 } from './message-v0';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV0}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV0Envelope(offchainMessage: OffchainMessageV0): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());\n}\n","import { getOffchainMessageV1Encoder } from './codecs/message-v1';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV1 } from './message-v1';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV1}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV1Envelope(offchainMessage: OffchainMessageV1): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { compileOffchainMessageV0Envelope } from './envelope-v0';\nimport { compileOffchainMessageV1Envelope } from './envelope-v1';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\ntype OrderedMap<K extends string, V> = Record<K, V>;\ntype OffchainMessageSignaturesMap = OrderedMap<Address, SignatureBytes | null>;\n\nexport interface OffchainMessageEnvelope {\n    /** The bytes of the combined offchain message preamble and content */\n    readonly content: OffchainMessageBytes;\n    /**\n     * A map between the addresses of an offchain message's signers, and the 64-byte Ed25519\n     * signature of the combined message preamble and message content by the private key associated\n     * with each.\n     */\n    readonly signatures: OffchainMessageSignaturesMap;\n}\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessage}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the compile functions\n * specific to that version so as not to bundle more code than you need.\n */\nexport function compileOffchainMessageEnvelope(offchainMessage: OffchainMessage): OffchainMessageEnvelope {\n    const { version } = offchainMessage;\n    switch (version) {\n        case 0:\n            return compileOffchainMessageV0Envelope(offchainMessage);\n        case 1:\n            return compileOffchainMessageV1Envelope(offchainMessage);\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: version satisfies never,\n            });\n    }\n}\n","import { Address, getAddressFromPublicKey, getPublicKeyFromAddress } from '@solana/addresses';\nimport { bytesEqual } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes, signBytes, verifySignature } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { decodeRequiredSignatoryAddresses } from './codecs/preamble-common';\nimport { OffchainMessageEnvelope } from './envelope';\n\n/**\n * Represents an offchain message envelope that is signed by all of its required signers.\n */\nexport type FullySignedOffchainMessageEnvelope = NominalType<'offchainMessageEnvelopeSignedness', 'fullySigned'>;\n\n/**\n * Represents an address that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatory<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n}>;\n\n/**\n * An offchain message having a list of accounts that must sign it in order for it to be valid.\n */\nexport interface OffchainMessageWithRequiredSignatories<\n    TSignatory extends OffchainMessageSignatory = OffchainMessageSignatory,\n> {\n    requiredSignatories: readonly TSignatory[];\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message, this method will return a new signed offchain message\n * envelope of type {@link OffchainMessageEnvelope}.\n *\n * Though the resulting message might be signed by all required signers, this function will not\n * assert that it is. A partially signed message is not complete, but can be serialized and\n * deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const partiallySignedOffchainMessage = await partiallySignOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link signOffchainMessageEnvelope} if you want to assert that the message is signed by all\n * its required signers after signing.\n */\nexport async function partiallySignOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<TOffchainMessageEnvelope> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n\n            // Check if the address is expected to sign the message\n            if (!requiredSignatoryAddresses.includes(address)) {\n                // address is not an expected signer for this message\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const existingSignature = offchainMessageEnvelope.signatures[address];\n            const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);\n\n            if (existingSignature != null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {\n            expectedAddresses: requiredSignatoryAddresses,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return offchainMessageEnvelope;\n    }\n\n    return Object.freeze({\n        ...offchainMessageEnvelope,\n        signatures: Object.freeze({\n            ...offchainMessageEnvelope.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message envelope, this method will return a new signed envelope of\n * type {@link FullySignedOffchainMessageEnvelope}.\n *\n * This function will throw unless the resulting message is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const signedOffchainMessage = await signOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link partiallySignOffchainMessageEnvelope} if you want to sign the message without\n * asserting that the resulting message envelope is fully signed.\n */\nexport async function signOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<FullySignedOffchainMessageEnvelope & TOffchainMessageEnvelope> {\n    const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);\n    assertIsFullySignedOffchainMessageEnvelope(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * A type guard that returns `true` if the input {@link OffchainMessageEnvelope} is fully signed,\n * and refines its type for use in your program, adding the\n * {@link FullySignedOffchainMessageEnvelope} type.\n *\n * @example\n * ```ts\n * import { isFullySignedOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * if (isFullySignedOffchainMessageEnvelope(offchainMessageEnvelope)) {\n *   // At this point we know that the offchain message is fully signed.\n * }\n * ```\n */\nexport function isFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    return Object.entries(offchainMessage.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link OffchainMessageEnvelope}, that you expect to be\n * fully signed, from an untrusted network API or user input. Use this function to assert that such\n * an offchain message is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedOffchainMessage } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast\n *     // `offchainMessageEnvelope` to `FullySignedOffchainMessageEnvelope`.\n *     assertIsFullySignedOffchainMessageEnvelope(offchainMessage);\n *     // At this point we know that the offchain message is signed by all required signers.\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function assertIsFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): asserts offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    const missingSigs: Address[] = [];\n    Object.entries(offchainMessage.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n\n/**\n * Asserts that there are signatures present for all of an offchain message's required signatories,\n * and that those signatures are valid given the message.\n *\n * @example\n * ```ts\n * import { isSolanaError, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE } from '@solana/errors';\n * import { verifyOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * try {\n *     await verifyOffchainMessageEnvelope(offchainMessageEnvelope);\n *     // At this point the message is valid and signed by all of the required signatories.\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE)) {\n *         if (e.context.signatoriesWithMissingSignatures.length) {\n *             console.error(\n *                 'Missing signatures for the following addresses',\n *                 e.context.signatoriesWithMissingSignatures,\n *             );\n *         }\n *         if (e.context.signatoriesWithInvalidSignatures.length) {\n *             console.error(\n *                 'Signatures for the following addresses are invalid',\n *                 e.context.signatoriesWithInvalidSignatures,\n *             );\n *         }\n *     }\n *     throw e;\n * }\n */\nexport async function verifyOffchainMessageEnvelope(offchainMessageEnvelope: OffchainMessageEnvelope): Promise<void> {\n    let errorContext;\n    const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(\n        requiredSignatories.map(async address => {\n            const signature = offchainMessageEnvelope.signatures[address];\n            if (signature == null) {\n                errorContext ||= {};\n                errorContext.signatoriesWithMissingSignatures ||= [];\n                errorContext.signatoriesWithMissingSignatures.push(address);\n            } else {\n                const publicKey = await getPublicKeyFromAddress(address);\n                if (await verifySignature(publicKey, signature, offchainMessageEnvelope.content)) {\n                    return true;\n                } else {\n                    errorContext ||= {};\n                    errorContext.signatoriesWithInvalidSignatures ||= [];\n                    errorContext.signatoriesWithInvalidSignatures.push(address);\n                }\n            }\n        }),\n    );\n    if (errorContext) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);\n    }\n}\n"]}