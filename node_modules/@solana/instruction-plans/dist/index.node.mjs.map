{"version":3,"sources":["../src/instruction-plan.ts","../src/append-instruction-plan.ts","../src/transaction-plan.ts","../src/transaction-plan-result.ts","../src/transaction-plan-executor.ts","../src/transaction-planner.ts"],"names":["appendTransactionMessageInstruction","SolanaError","context","traverse","traverseSequential","traverseParallel","traverseSingle","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND","candidate","message","appendTransactionMessageInstructions","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","isSolanaError","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND"],"mappings":"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","file":"index.node.mjs","sourcesContent":["import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomically — either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message — when possible — and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Checks if the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a single instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * if (isSingleInstructionPlan(plan)) {\n *   console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * }\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link assertIsSingleInstructionPlan}\n */\nexport function isSingleInstructionPlan(plan: InstructionPlan): plan is SingleInstructionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a single instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * assertIsSingleInstructionPlan(plan);\n * console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link isSingleInstructionPlan}\n */\nexport function assertIsSingleInstructionPlan(plan: InstructionPlan): asserts plan is SingleInstructionPlan {\n    if (!isSingleInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a message packer instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * if (isMessagePackerInstructionPlan(plan)) {\n *   const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link assertIsMessagePackerInstructionPlan}\n */\nexport function isMessagePackerInstructionPlan(plan: InstructionPlan): plan is MessagePackerInstructionPlan {\n    return plan.kind === 'messagePacker';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a message packer instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * assertIsMessagePackerInstructionPlan(plan);\n * const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link isMessagePackerInstructionPlan}\n */\nexport function assertIsMessagePackerInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is MessagePackerInstructionPlan {\n    if (!isMessagePackerInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'messagePacker',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isSequentialInstructionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsSequentialInstructionPlan}\n */\nexport function isSequentialInstructionPlan(plan: InstructionPlan): plan is SequentialInstructionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsSequentialInstructionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isSequentialInstructionPlan}\n */\nexport function assertIsSequentialInstructionPlan(plan: InstructionPlan): asserts plan is SequentialInstructionPlan {\n    if (!isSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically — either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a non-divisible sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isNonDivisibleSequentialInstructionPlan(plan)) {\n *   // All instructions must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsNonDivisibleSequentialInstructionPlan}\n */\nexport function isNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): plan is SequentialInstructionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically — either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a non-divisible sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsNonDivisibleSequentialInstructionPlan(plan);\n * // All instructions must be executed atomically.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isNonDivisibleSequentialInstructionPlan}\n */\nexport function assertIsNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is SequentialInstructionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a parallel instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * if (isParallelInstructionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * }\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link assertIsParallelInstructionPlan}\n */\nexport function isParallelInstructionPlan(plan: InstructionPlan): plan is ParallelInstructionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a parallel instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * assertIsParallelInstructionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link isParallelInstructionPlan}\n */\nexport function assertIsParallelInstructionPlan(plan: InstructionPlan): asserts plan is ParallelInstructionPlan {\n    if (!isParallelInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Finds the first instruction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the instruction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param instructionPlan - The instruction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @returns The first matching instruction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const nonDivisible = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing instructionC and instructionD.\n * ```\n *\n * @example\n * Finding a specific single instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const found = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.instruction === instructionB,\n * );\n * // Returns the SingleInstructionPlan wrapping instructionB.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function findInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): InstructionPlan | undefined {\n    if (predicate(instructionPlan)) {\n        return instructionPlan;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return undefined;\n    }\n    for (const subPlan of instructionPlan.plans) {\n        const foundPlan = findInstructionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every instruction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the instruction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param instructionPlan - The instruction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const allDivisible = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single instructions use a specific program.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const allUseSameProgram = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.instruction.programAddress === myProgramAddress,\n * );\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function everyInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): boolean {\n    if (!predicate(instructionPlan)) {\n        return false;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return true;\n    }\n    return instructionPlan.plans.every(p => everyInstructionPlan(p, predicate));\n}\n\n/**\n * Transforms an instruction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the instruction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param instructionPlan - The instruction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed instruction plan tree.\n *\n * @example\n * Making all sequential plans non-divisible to ensure atomicity.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' && p.divisible) {\n *     return nonDivisibleSequentialInstructionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Filtering out debug instructions before production execution.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, debugInstruction, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' || p.kind === 'parallel') {\n *     return { ...p, plans: p.plans.filter((p) => !isDebugInstruction(p)) };\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function transformInstructionPlan(\n    instructionPlan: InstructionPlan,\n    fn: (plan: InstructionPlan) => InstructionPlan,\n): InstructionPlan {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return Object.freeze(fn(instructionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...instructionPlan,\n                plans: instructionPlan.plans.map(p => transformInstructionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleInstructionPlan} and {@link MessagePackerInstructionPlan}\n * instances from an instruction plan tree.\n *\n * This function recursively traverses any nested structure of instruction plans and extracts\n * all the leaf plans they contain. It's useful when you need to access all the individual\n * instructions or message packers that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param instructionPlan - The instruction plan to extract leaf plans from\n * @returns An array of all single and message packer instruction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n *   instructionE,\n * ]);\n *\n * const leafPlans = flattenInstructionPlan(plan);\n * // Array of `SingleInstructionPlan` containing:\n * // instructionA, instructionB, instructionC, instructionD and instructionE.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n */\nexport function flattenInstructionPlan(\n    instructionPlan: InstructionPlan,\n): (MessagePackerInstructionPlan | SingleInstructionPlan)[] {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return [instructionPlan];\n    }\n    return instructionPlan.plans.flatMap(flattenInstructionPlan);\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n * — e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, SolanaError } from '@solana/errors';\nimport { type Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport { flattenInstructionPlan, InstructionPlan } from './instruction-plan';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\n\ntype AppendTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> = ReturnType<\n    typeof appendTransactionMessageInstructions<TTransactionMessage, Instruction[]>\n>;\n\n/**\n * Appends all instructions from an instruction plan to a transaction message.\n *\n * This function flattens the instruction plan into its leaf plans and sequentially\n * appends each instruction to the provided transaction message. It handles both\n * single instructions and message packer plans.\n *\n * Note that any {@link MessagePackerInstructionPlan} is assumed to only append\n * instructions. If it modifies other properties of the transaction message, the\n * type of the returned transaction message may not accurately reflect those changes.\n *\n * @typeParam TTransactionMessage - The type of transaction message being modified.\n *\n * @param transactionMessage - The transaction message to append instructions to.\n * @param instructionPlan - The instruction plan containing the instructions to append.\n * @returns The transaction message with all instructions from the plan appended.\n *\n * @example\n * Appending a simple instruction plan to a transaction message.\n * ```ts\n * import { appendTransactionMessageInstructionPlan } from '@solana/instruction-plans';\n * import { createTransactionMessage, setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const message = setTransactionMessageFeePayer(feePayer, createTransactionMessage({ version: 0 }));\n * const plan = singleInstructionPlan(myInstruction);\n *\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @example\n * Appending a sequential instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function appendTransactionMessageInstructionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer,\n>(\n    instructionPlan: InstructionPlan,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage> {\n    type Out = AppendTransactionMessageInstructions<TTransactionMessage>;\n\n    const leafInstructionPlans = flattenInstructionPlan(instructionPlan);\n\n    return leafInstructionPlans.reduce(\n        (messageSoFar, plan) => {\n            const kind = plan.kind;\n            if (kind === 'single') {\n                return appendTransactionMessageInstruction(plan.instruction, messageSoFar) as unknown as Out;\n            }\n            if (kind === 'messagePacker') {\n                const messagerPacker = plan.getMessagePacker();\n                let nextMessage: Out = messageSoFar;\n                while (!messagerPacker.done()) {\n                    nextMessage = messagerPacker.packMessageToCapacity(nextMessage) as Out;\n                }\n                return nextMessage;\n            }\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n                kind,\n            });\n        },\n        transactionMessage as unknown as Out,\n    );\n}\n","import { SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, SolanaError } from '@solana/errors';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically — usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Checks if the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a single transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * if (isSingleTransactionPlan(plan)) {\n *   console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link assertIsSingleTransactionPlan}\n */\nexport function isSingleTransactionPlan(plan: TransactionPlan): plan is SingleTransactionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a single transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * assertIsSingleTransactionPlan(plan);\n * console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link isSingleTransactionPlan}\n */\nexport function assertIsSingleTransactionPlan(plan: TransactionPlan): asserts plan is SingleTransactionPlan {\n    if (!isSingleTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * if (isSequentialTransactionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsSequentialTransactionPlan}\n */\nexport function isSequentialTransactionPlan(plan: TransactionPlan): plan is SequentialTransactionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsSequentialTransactionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isSequentialTransactionPlan}\n */\nexport function assertIsSequentialTransactionPlan(plan: TransactionPlan): asserts plan is SequentialTransactionPlan {\n    if (!isSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically — usually in a transaction bundle.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a non-divisible sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * if (isNonDivisibleSequentialTransactionPlan(plan)) {\n *   // All transaction messages must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlan}\n */\nexport function isNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): plan is SequentialTransactionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically — usually in a transaction bundle.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a non-divisible sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlan(plan);\n * // All transaction messages must be executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isNonDivisibleSequentialTransactionPlan}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): asserts plan is SequentialTransactionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a parallel transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * if (isParallelTransactionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link assertIsParallelTransactionPlan}\n */\nexport function isParallelTransactionPlan(plan: TransactionPlan): plan is ParallelTransactionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a parallel transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * assertIsParallelTransactionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link isParallelTransactionPlan}\n */\nexport function assertIsParallelTransactionPlan(plan: TransactionPlan): asserts plan is ParallelTransactionPlan {\n    if (!isParallelTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * @deprecated Use {@link flattenTransactionPlan} instead.\n */\nexport const getAllSingleTransactionPlans = flattenTransactionPlan;\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = flattenTransactionPlan(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * ```\n */\nexport function flattenTransactionPlan(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(flattenTransactionPlan);\n}\n\n/**\n * Finds the first transaction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param transactionPlan - The transaction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @return The first matching transaction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const nonDivisible = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing messageC and messageD.\n * ```\n *\n * @example\n * Finding a specific single transaction plan.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB, messageC]);\n *\n * const found = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.message === messageB,\n * );\n * // Returns the SingleTransactionPlan wrapping messageB.\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function findTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): TransactionPlan | undefined {\n    if (predicate(transactionPlan)) {\n        return transactionPlan;\n    }\n    if (transactionPlan.kind === 'single') {\n        return undefined;\n    }\n    for (const subPlan of transactionPlan.plans) {\n        const foundPlan = findTransactionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every transaction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param transactionPlan - The transaction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const allDivisible = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single plans have a specific fee payer.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const allUseSameFeePayer = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.message.feePayer.address === myFeePayer,\n * );\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function everyTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): boolean {\n    if (!predicate(transactionPlan)) {\n        return false;\n    }\n    if (transactionPlan.kind === 'single') {\n        return true;\n    }\n    return transactionPlan.plans.every(p => everyTransactionPlan(p, predicate));\n}\n\n/**\n * Transforms a transaction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlan - The transaction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed transaction plan tree.\n *\n * @example\n * Removing parallelism by converting parallel plans to sequential.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'parallel') {\n *     return sequentialTransactionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Updating the fee payer on all transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'single') {\n *     return singleTransactionPlan({ ...p.message, feePayer: newFeePayer });\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function transformTransactionPlan(\n    transactionPlan: TransactionPlan,\n    fn: (plan: TransactionPlan) => TransactionPlan,\n): TransactionPlan {\n    if (transactionPlan.kind === 'single') {\n        return Object.freeze(fn(transactionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlan,\n                plans: transactionPlan.plans.map(p => transformTransactionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { getSignatureFromTransaction, Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = ParallelTransactionPlanResult<TContext, TSingle> | SequentialTransactionPlanResult<TContext, TSingle> | TSingle;\n\n/**\n * A {@link TransactionPlanResult} where all single transaction results are successful.\n *\n * This type represents a transaction plan result tree where every\n * {@link SingleTransactionPlanResult} has a 'successful' status. It can be used\n * to ensure that an entire execution completed without any failures or cancellations.\n *\n * Note: This is different from {@link SuccessfulSingleTransactionPlanResult} which\n * represents a single successful transaction, whereas this type represents an entire\n * plan result tree (which may contain parallel/sequential structures) where all\n * leaf nodes are successful.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link SuccessfulSingleTransactionPlanResult}\n */\nexport type SuccessfulTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = TransactionPlanResult<TContext, SuccessfulSingleTransactionPlanResult<TContext>>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; signature: Signature; transaction?: Transaction }>\n    | Readonly<{ error: Error; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? ({} as TContext),\n            kind: 'successful',\n            signature: getSignatureFromTransaction(transaction),\n            transaction,\n        }),\n    });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and signature.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the signature of the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param signature - The signature of the successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   signature\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResultFromSignature<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    signature: Signature,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', signature }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage, error: Error): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSingleTransactionPlanResult(result)) {\n *   console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link assertIsSingleTransactionPlanResult}\n */\nexport function isSingleTransactionPlanResult(plan: TransactionPlanResult): plan is SingleTransactionPlanResult {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSingleTransactionPlanResult(result);\n * console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link isSingleTransactionPlanResult}\n */\nexport function assertIsSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SingleTransactionPlanResult {\n    if (!isSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a successful single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSuccessfulSingleTransactionPlanResult(result)) {\n *   console.log(result.status.signature); // TypeScript knows this is a successful result.\n * }\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'successful';\n}\n\n/**\n * Asserts that the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a successful single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSuccessfulSingleTransactionPlanResult(result);\n * console.log(result.status.signature); // TypeScript knows this is a successful result.\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulSingleTransactionPlanResult {\n    if (!isSuccessfulSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'successful single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a failed single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * if (isFailedSingleTransactionPlanResult(result)) {\n *   console.log(result.status.error); // TypeScript knows this is a failed result.\n * }\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link assertIsFailedSingleTransactionPlanResult}\n */\nexport function isFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is FailedSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'failed';\n}\n\n/**\n * Asserts that the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a failed single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * assertIsFailedSingleTransactionPlanResult(result);\n * console.log(result.status.error); // TypeScript knows this is a failed result.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link isFailedSingleTransactionPlanResult}\n */\nexport function assertIsFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is FailedSingleTransactionPlanResult {\n    if (!isFailedSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'failed single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a canceled single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * if (isCanceledSingleTransactionPlanResult(result)) {\n *   console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * }\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link assertIsCanceledSingleTransactionPlanResult}\n */\nexport function isCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is CanceledSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'canceled';\n}\n\n/**\n * Asserts that the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a canceled single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * assertIsCanceledSingleTransactionPlanResult(result);\n * console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link isCanceledSingleTransactionPlanResult}\n */\nexport function assertIsCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is CanceledSingleTransactionPlanResult {\n    if (!isCanceledSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'canceled single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isSequentialTransactionPlanResult(result)) {\n *   console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsSequentialTransactionPlanResult}\n */\nexport function isSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsSequentialTransactionPlanResult(result);\n * console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isSequentialTransactionPlanResult}\n */\nexport function assertIsSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult {\n    if (!isSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically — usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a non-divisible sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isNonDivisibleSequentialTransactionPlanResult(result)) {\n *   // Transactions were executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlanResult}\n */\nexport function isNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically — usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a non-divisible sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlanResult(result);\n * // Transactions were executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isNonDivisibleSequentialTransactionPlanResult}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a parallel transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * if (isParallelTransactionPlanResult(result)) {\n *   console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link assertIsParallelTransactionPlanResult}\n */\nexport function isParallelTransactionPlanResult(plan: TransactionPlanResult): plan is ParallelTransactionPlanResult {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a parallel transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * assertIsParallelTransactionPlanResult(result);\n * console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link isParallelTransactionPlanResult}\n */\nexport function assertIsParallelTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is ParallelTransactionPlanResult {\n    if (!isParallelTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It recursively checks all nested results\n * to ensure every {@link SingleTransactionPlanResult} has a 'successful' status.\n *\n * Note: This is different from {@link isSuccessfulSingleTransactionPlanResult} which\n * checks if a single result is successful. This function checks that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if all single transaction results in the tree are successful, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * if (isSuccessfulTransactionPlanResult(result)) {\n *   // All transactions were successful.\n *   result satisfies SuccessfulTransactionPlanResult;\n * }\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulTransactionPlanResult {\n    return everyTransactionPlanResult(\n        plan,\n        r => !isSingleTransactionPlanResult(r) || isSuccessfulSingleTransactionPlanResult(r),\n    );\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It throws if any {@link SingleTransactionPlanResult}\n * in the tree has a 'failed' or 'canceled' status.\n *\n * Note: This is different from {@link assertIsSuccessfulSingleTransactionPlanResult} which\n * asserts that a single result is successful. This function asserts that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT` if\n * any single transaction result in the tree is not successful.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * assertIsSuccessfulTransactionPlanResult(result);\n * // All transactions were successful.\n * result satisfies SuccessfulTransactionPlanResult;\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulTransactionPlanResult {\n    if (!isSuccessfulTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT, {\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Finds the first transaction plan result in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan result tree,\n * returning the first result that satisfies the predicate. It checks the root result\n * first, then recursively searches through nested results.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @param predicate - A function that returns `true` for the result to find.\n * @returns The first matching transaction plan result, or `undefined` if no match is found.\n *\n * @example\n * Finding a failed transaction result.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n * ]);\n *\n * const failed = findTransactionPlanResult(\n *   result,\n *   (r) => r.kind === 'single' && r.status.kind === 'failed',\n * );\n * // Returns the failed single transaction plan result for messageB.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function findTransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionPlanResult: TransactionPlanResult<TContext>,\n    predicate: (result: TransactionPlanResult<TContext>) => boolean,\n): TransactionPlanResult<TContext> | undefined {\n    if (predicate(transactionPlanResult)) {\n        return transactionPlanResult;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return undefined;\n    }\n    for (const subResult of transactionPlanResult.plans) {\n        const foundResult = findTransactionPlanResult(subResult, predicate);\n        if (foundResult) {\n            return foundResult;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Retrieves the first failed transaction plan result from a transaction plan result tree.\n *\n * This function searches the transaction plan result tree using a depth-first traversal\n * and returns the first single transaction result with a 'failed' status. If no failed\n * result is found, it throws a {@link SolanaError}.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @return The first failed single transaction plan result.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND` if no\n * failed transaction plan result is found. The error context contains a non-enumerable\n * `transactionPlanResult` property for recovery purposes.\n *\n * @example\n * Retrieving the first failed result from a parallel execution.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n *   failedSingleTransactionPlanResult(messageC, anotherError),\n * ]);\n *\n * const firstFailed = getFirstFailedSingleTransactionPlanResult(result);\n * // Returns the failed result for messageB.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n */\nexport function getFirstFailedSingleTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n): FailedSingleTransactionPlanResult {\n    const result = findTransactionPlanResult(\n        transactionPlanResult,\n        r => r.kind === 'single' && r.status.kind === 'failed',\n    );\n\n    if (!result) {\n        // Here we want the `transactionPlanResult` to be available in the error context\n        // so applications can recover but we don't want this object to be\n        // serialized with the error. This is why we set it as a non-enumerable property.\n        const context = {};\n        Object.defineProperty(context, 'transactionPlanResult', {\n            configurable: false,\n            enumerable: false,\n            value: transactionPlanResult,\n            writable: false,\n        });\n        throw new SolanaError(\n            SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n            context,\n        );\n    }\n\n    return result as FailedSingleTransactionPlanResult;\n}\n\n/**\n * Checks if every transaction plan result in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan result tree,\n * returning `true` only if the predicate returns `true` for every result in the tree\n * (including the root result and all nested results).\n *\n * @param transactionPlanResult - The transaction plan result tree to check.\n * @param predicate - A function that returns `true` if the result satisfies the condition.\n * @return `true` if every result in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all transactions were successful.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * const allSuccessful = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind === 'successful',\n * );\n * // Returns true because all single results are successful.\n * ```\n *\n * @example\n * Checking if no transactions were canceled.\n * ```ts\n * const result = sequentialTransactionPlanResult([resultA, resultB, resultC]);\n *\n * const noCanceled = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind !== 'canceled',\n * );\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function everyTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    predicate: (plan: TransactionPlanResult) => boolean,\n): boolean {\n    if (!predicate(transactionPlanResult)) {\n        return false;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return true;\n    }\n    return transactionPlanResult.plans.every(p => everyTransactionPlanResult(p, predicate));\n}\n\n/**\n * Transforms a transaction plan result tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan result tree, applying the\n * transformation function to each result. The transformation is applied bottom-up,\n * meaning nested results are transformed first, then the parent results receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed results are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlanResult - The transaction plan result tree to transform.\n * @param fn - A function that transforms each result and returns a new result.\n * @return A new transformed transaction plan result tree.\n *\n * @example\n * Converting all canceled results to failed results.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   canceledSingleTransactionPlanResult(messageB),\n * ]);\n *\n * const transformed = transformTransactionPlanResult(result, (r) => {\n *   if (r.kind === 'single' && r.status.kind === 'canceled') {\n *     return failedSingleTransactionPlanResult(r.message, new Error('Execution canceled'));\n *   }\n *   return r;\n * });\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function transformTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    fn: (plan: TransactionPlanResult) => TransactionPlanResult,\n): TransactionPlanResult {\n    if (transactionPlanResult.kind === 'single') {\n        return Object.freeze(fn(transactionPlanResult));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlanResult,\n                plans: transactionPlanResult.plans.map(p => transformTransactionPlanResult(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlanResult} instances from a transaction plan result tree.\n *\n * This function recursively traverses any nested structure of transaction plan results and extracts\n * all the single results they contain. It's useful when you need to access all the individual\n * transaction results, regardless of their organization in the result tree (parallel or sequential).\n *\n * @param result - The transaction plan result to extract single results from\n * @returns An array of all single transaction plan results contained in the tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   sequentialTransactionPlanResult([resultA, resultB]),\n *   nonDivisibleSequentialTransactionPlanResult([resultC, resultD]),\n *   resultE,\n * ]);\n *\n * const singleResults = flattenTransactionPlanResult(result);\n * // Array of `SingleTransactionPlanResult` containing:\n * // resultA, resultB, resultC, resultD and resultE.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n */\nexport function flattenTransactionPlanResult(result: TransactionPlanResult): SingleTransactionPlanResult[] {\n    if (result.kind === 'single') {\n        return [result];\n    }\n    return result.plans.flatMap(flattenTransactionPlanResult);\n}\n\n/**\n * A {@link SingleTransactionPlanResult} with 'successful' status.\n */\nexport type SuccessfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = SingleTransactionPlanResult<TContext> & { status: { kind: 'successful' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'failed' status.\n */\nexport type FailedSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'failed' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'canceled' status.\n */\nexport type CanceledSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'canceled' } };\n\n/**\n * A summary of a {@link TransactionPlanResult}, categorizing transactions by their execution status.\n * - `successful`: Indicates whether all transactions were successful (i.e., no failed or canceled transactions).\n * - `successfulTransactions`: An array of successful transactions, each including its signature.\n * - `failedTransactions`: An array of failed transactions, each including the error that caused the failure.\n * - `canceledTransactions`: An array of canceled transactions.\n */\nexport type TransactionPlanResultSummary = Readonly<{\n    canceledTransactions: CanceledSingleTransactionPlanResult[];\n    failedTransactions: FailedSingleTransactionPlanResult[];\n    successful: boolean;\n    successfulTransactions: SuccessfulSingleTransactionPlanResult[];\n}>;\n\n/**\n * Summarize a {@link TransactionPlanResult} into a {@link TransactionPlanResultSummary}.\n * @param result The transaction plan result to summarize\n * @returns A summary of the transaction plan result\n */\nexport function summarizeTransactionPlanResult(result: TransactionPlanResult): TransactionPlanResultSummary {\n    const successfulTransactions: TransactionPlanResultSummary['successfulTransactions'] = [];\n    const failedTransactions: TransactionPlanResultSummary['failedTransactions'] = [];\n    const canceledTransactions: TransactionPlanResultSummary['canceledTransactions'] = [];\n\n    const flattenedResults = flattenTransactionPlanResult(result);\n\n    for (const singleResult of flattenedResults) {\n        switch (singleResult.status.kind) {\n            case 'successful': {\n                successfulTransactions.push(singleResult as SuccessfulSingleTransactionPlanResult);\n                break;\n            }\n            case 'failed': {\n                failedTransactions.push(singleResult as FailedSingleTransactionPlanResult);\n                break;\n            }\n            case 'canceled': {\n                canceledTransactions.push(singleResult as CanceledSingleTransactionPlanResult);\n                break;\n            }\n        }\n    }\n\n    return Object.freeze({\n        canceledTransactions,\n        failedTransactions,\n        successful: failedTransactions.length === 0 && canceledTransactions.length === 0,\n        successfulTransactions,\n    });\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { getAbortablePromise } from '@solana/promises';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    SingleTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    successfulSingleTransactionPlanResultFromSignature,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\n/**\n * Executes a transaction plan and returns the execution results.\n *\n * This function traverses the transaction plan tree, executing each transaction\n * message and collecting results that mirror the structure of the original plan.\n *\n * @typeParam TContext - The type of the context object that may be passed along with successful results.\n * @param transactionPlan - The transaction plan to execute.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel execution.\n * @return A promise that resolves to the execution results.\n *\n * @see {@link TransactionPlan}\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteResult<TContext extends TransactionPlanResultContext> = {\n    context?: TContext;\n} & ({ signature: Signature } | { transaction: Transaction });\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<ExecuteResult<TContext>>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @param config - Configuration object containing the transaction message executor function.\n * @return A {@link TransactionPlanExecutor} function that can execute transaction plans.\n *\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n *   if any transaction in the plan fails to execute. The error context contains a\n *   `transactionPlanResult` property with the partial results up to the point of failure.\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED}\n *   if the transaction plan contains non-divisible sequential plans, which are not\n *   supported by this executor.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: async (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlanExecutorConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        // Fail early if there are non-divisible sequential plans in the\n        // transaction plan as they are not supported by this executor.\n        assertDivisibleSequentialPlansOnly(plan);\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (!transactionPlan.divisible) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n    }\n\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return sequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        if ('transaction' in result) {\n            return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n        } else {\n            return successfulSingleTransactionPlanResultFromSignature(\n                transactionPlan.message,\n                result.signature,\n                result.context,\n            );\n        }\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as Error);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): Error | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n\nfunction assertDivisibleSequentialPlansOnly(transactionPlan: TransactionPlan): void {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            if (!transactionPlan.divisible) {\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n            }\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'parallel':\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'single':\n        default:\n            return;\n    }\n}\n\n/**\n * Wraps a transaction plan execution promise to return a\n * {@link TransactionPlanResult} even on execution failure.\n *\n * When a transaction plan executor throws a\n * {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n * error, this helper catches it and returns the `TransactionPlanResult`\n * from the error context instead of throwing.\n *\n * This allows us to handle the result of an execution in a single unified way\n * instead of using try/catch and examine the `TransactionPlanResult` in both\n * success and failure cases.\n *\n * Any other errors are re-thrown as normal.\n *\n * @param promise - A promise returned by a transaction plan executor.\n * @return A promise that resolves to the transaction plan result, even if some transactions failed.\n *\n * @example\n * Handling failures using a single result object:\n * ```ts\n * const result = await passthroughFailedTransactionPlanExecution(\n *   transactionPlanExecutor(transactionPlan)\n * );\n *\n * const summary = summarizeTransactionPlanResult(result);\n * if (summary.successful) {\n *   console.log('All transactions executed successfully');\n * } else {\n *   console.log(`${summary.successfulTransactions.length} succeeded`);\n *   console.log(`${summary.failedTransactions.length} failed`);\n *   console.log(`${summary.canceledTransactions.length} canceled`);\n * }\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n * @see {@link summarizeTransactionPlanResult}\n */\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<SingleTransactionPlanResult>,\n): Promise<SingleTransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult> {\n    try {\n        return await promise;\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN)) {\n            return error.context.transactionPlanResult as TransactionPlanResult;\n        }\n        throw error;\n    }\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    flattenTransactionPlan,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated — e.g. new instructions were added.\n     * This function must return the updated transaction message back — even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: TransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return flattenTransactionPlan(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<TransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: TransactionMessage & TransactionMessageWithFeePayer,\n): TransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: TransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(newMessage);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n"]}