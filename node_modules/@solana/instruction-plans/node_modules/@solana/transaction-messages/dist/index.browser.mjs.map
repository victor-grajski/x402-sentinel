{"version":3,"sources":["../src/blockhash.ts","../../codecs-strings/src/assertions.ts","../../codecs-strings/src/baseX.ts","../../codecs-strings/src/base58.ts","../src/codecs/address-table-lookup.ts","../src/codecs/header.ts","../src/codecs/instruction.ts","../src/transaction-message.ts","../src/codecs/transaction-version.ts","../src/codecs/message.ts","../src/compile/accounts.ts","../src/compile/address-table-lookups.ts","../src/compile/header.ts","../src/compile/instructions.ts","../src/compile/lifetime-token.ts","../src/compile/static-accounts.ts","../src/compile/message.ts","../src/compress-transaction-message.ts","../src/create-transaction-message.ts","../src/durable-nonce-instruction.ts","../src/durable-nonce.ts","../src/fee-payer.ts","../src/instructions.ts","../src/decompile-message.ts"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","transformDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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","file":"index.browser.mjs","sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends Partial<TransactionMessageWithLifetime> & TransactionMessage,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\n/**\n * @deprecated Use `TransactionMessage` instead.\n */\n// TODO(#1147) Stop exporting this in a future major version.\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\nexport type NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = TTransactionMessage extends unknown\n    ? Omit<\n          // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n          TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n              ? TTransactionMessage\n              : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n          // 2. Remove the instructions array as we are going to replace it with a new one.\n          'instructions'\n      > & {\n          // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n          readonly instructions: TTransactionMessage['instructions'] extends readonly [\n              AdvanceNonceAccountInstruction,\n              ...infer TTail extends readonly Instruction[],\n          ]\n              ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n              : readonly [\n                    AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n                    ...TTransactionMessage['instructions'],\n                ];\n          // 4. Set the lifetime constraint to the nonce value.\n          readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n      }\n    : never;\n","import { Address } from '@solana/addresses';\n\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends unknown ? Omit<TTransactionMessage, 'feePayer'> : never;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends Partial<TransactionMessageWithFeePayer> & TransactionMessage,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n        TransactionMessageWithFeePayer<TFeePayerAddress>;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n          readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n      }\n    : never;\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<\n          ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n          'instructions'\n      > & {\n          readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n      }\n    : never;\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    }) as AppendTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    }) as unknown as PrependTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BlockhashLifetimeConstraint, setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | BlockhashLifetimeConstraint\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as TransactionMessage,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    ) as TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime;\n}\n"]}