{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":";;;AA2KO,SAAS,iBAAA,GAAoC;AAChD,EAAA,OAAO,MAAA,CAAO,EAAE,CAAA;AACpB;AAEA,SAAS,OAA6B,KAAA,EAA6B;AAC/D,EAAA,OAAO,OAAO,MAAA,CAAO;AAAA,IACjB,GAAG,KAAA;AAAA,IACH,IAA8C,MAAA,EAAsC;AAChF,MAAA,MAAM,MAAA,GAAS,OAAO,KAAK,CAAA;AAC3B,MAAA,OAAO,kBAAkB,OAAA,GAAU,iBAAA,CAAkB,MAAM,CAAA,GAAI,OAAO,MAAM,CAAA;AAAA,IAChF;AAAA,GACc,CAAA;AACtB;AAEA,SAAS,kBAAwC,OAAA,EAA6C;AAC1F,EAAA,OAAO,OAAO,MAAA,CAAO;AAAA,IACjB,MAAM,UAAA,EAAY;AACd,MAAA,OAAO,OAAA,CAAQ,KAAK,CAAA,CAAA,KAAK,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,MAAM,UAAU,CAAA;AAAA,IACxD,CAAA;AAAA,IACA,QAAQ,SAAA,EAAW;AACf,MAAA,OAAO,OAAA,CAAQ,KAAK,CAAA,CAAA,KAAK,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,QAAQ,SAAS,CAAA;AAAA,IACzD,CAAA;AAAA,IACA,IAAA,CAAK,aAAa,UAAA,EAAY;AAC1B,MAAA,OAAO,OAAA,CAAQ,KAAK,CAAA,CAAA,KAAK,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,IAAA,CAAK,WAAA,EAAa,UAAU,CAAA;AAAA,IACpE,CAAA;AAAA,IACA,IAA8C,MAAA,EAAsC;AAChF,MAAA,OAAO,iBAAA,CAAkB,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAC,CAAA;AAAA,IACjD;AAAA,GACmB,CAAA;AAC3B","file":"index.browser.cjs","sourcesContent":["/**\n * Defines a plugin that transforms or extends a client with additional functionality.\n *\n * For instance, plugins may add RPC capabilities, wallet integration, transaction building,\n * or other features necessary for interacting with the Solana blockchain.\n *\n * Plugins are functions that take a client object as input and return a new client object\n * or a promise that resolves to a new client object. This allows for both synchronous\n * and asynchronous transformations and extensions of the client.\n *\n * Plugins are usually applied using the `use` method on a {@link Client} or {@link AsyncClient}\n * instance, which {@link createEmptyClient} provides as a starting point.\n *\n * @typeParam TInput - The input client object type that this plugin accepts.\n * @typeParam TOutput - The output type. Either a new client object or a promise resolving to one.\n *\n * @example Basic RPC plugin\n * Given an RPC endpoint, this plugin adds an `rpc` property to the client.\n *\n * ```ts\n * import { createEmptyClient, createSolanaRpc } from '@solana/kit';\n *\n * // Define a simple RPC plugin.\n * function rpcPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpc(endpoint) });\n * }\n *\n * // Use the plugin.\n * const client = createEmptyClient().use(rpcPlugin('https://api.mainnet-beta.solana.com'));\n * await client.rpc.getLatestBlockhash().send();\n * ```\n *\n * @example Async plugin that generates a payer wallet\n * The following plugin shows how to create an asynchronous plugin that generates a new keypair signer.\n *\n * ```ts\n * import { createEmptyClient, generateKeypairSigner } from '@solana/kit';\n *\n * // Define a plugin that generates a new keypair signer.\n * function generatedPayerPlugin() {\n *     return async <T extends object>(client: T) => ({...client, payer: await generateKeypairSigner() });\n * }\n *\n * // Use the plugin.\n * const client = await createEmptyClient().use(generatedPayerPlugin());\n * console.log(client.payer.address);\n * ```\n *\n * @example Plugins with input requirements\n * A plugin can specify required properties on the input client. The example below requires the\n * client to already have a `payer` signer attached to the client in order to perform an airdrop.\n *\n * ```ts\n * import { createEmptyClient, TransactionSigner, Lamports, lamports } from '@solana/kit';\n *\n * // Define a plugin that airdrops lamports to the payer set on the client.\n * function airdropPayerPlugin(lamports: Lamports) {\n *     return async <T extends { payer: TransactionSigner }>(client: T) => {\n *         await myAirdropFunction(client.payer, lamports);\n *         return client;\n *     };\n * }\n *\n * // Use the plugins.\n * const client = await createEmptyClient()\n *     .use(generatedPayerPlugin()) // This is required before using the airdrop plugin.\n *     .use(airdropPayerPlugin(lamports(1_000_000_000n)));\n * ```\n *\n * @example Chaining plugins\n * Multiple plugins — asynchronous or not — can be chained together to build up complex clients.\n * The example below demonstrates how to gradually build a client with multiple plugins.\n * Notice how, despite having multiple asynchronous plugins, we only need to `await` the final result.\n * This is because the `use` method on `AsyncClient` returns another `AsyncClient`, allowing for seamless chaining.\n *\n * ```ts\n * import { createEmptyClient, createSolanaRpc, createSolanaRpcSubscriptions, generateKeypairSigner } from '@solana/kit';\n *\n * // Define multiple plugins.\n * function rpcPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpc(endpoint) });\n * }\n * function rpcSubscriptionsPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpcSubscriptions(endpoint) });\n * }\n * function generatedPayerPlugin() {\n *     return async <T extends object>(client: T) => ({...client, payer: await generateKeypairSigner() });\n * }\n * function generatedAuthorityPlugin() {\n *     return async <T extends object>(client: T) => ({...client, authority: await generateKeypairSigner() });\n * }\n *\n * // Chain plugins together.\n * const client = await createEmptyClient()\n *     .use(rpcPlugin('https://api.mainnet-beta.solana.com'))\n *     .use(rpcSubscriptionsPlugin('wss://api.mainnet-beta.solana.com'))\n *     .use(generatedPayerPlugin())\n *     .use(generatedAuthorityPlugin());\n * ```\n */\nexport type ClientPlugin<TInput extends object, TOutput extends Promise<object> | object> = (input: TInput) => TOutput;\n\n/**\n * A client that can be extended with plugins.\n *\n * The `Client` type represents a client object that can be built up through\n * the application of one or more plugins. It provides a `use` method to\n * apply plugins, either synchronously (returning a new `Client`) or\n * asynchronously (returning an {@link AsyncClient}).\n *\n * @typeParam TSelf - The current shape of the client object including all applied plugins.\n */\nexport type Client<TSelf extends object> = TSelf & {\n    /**\n     * Applies a plugin to extend or transform the client.\n     *\n     * @param plugin The plugin function to apply to this client.\n     * @returns Either a new `Client` (for sync plugins) or {@link AsyncClient} (for async plugins).\n     */\n    readonly use: <TOutput extends Promise<object> | object>(\n        plugin: ClientPlugin<TSelf, TOutput>,\n    ) => TOutput extends Promise<infer U> ? AsyncClient<U extends object ? U : never> : Client<TOutput>;\n};\n\n/**\n * An asynchronous wrapper that represents a promise of a client.\n *\n * The `AsyncClient` type is returned when an async plugin is applied to a client.\n * It behaves like a `Promise<Client<TSelf>>` but with an additional `use` method\n * that allows chaining more plugins before the promise resolves.\n *\n * This enables fluent chaining of both synchronous and asynchronous plugins\n * without having to await intermediate promises.\n *\n * @typeParam TSelf - The shape of the client object that this async client will resolve to.\n */\nexport type AsyncClient<TSelf extends object> = Promise<Client<TSelf>> & {\n    /**\n     * Applies a plugin to the client once it resolves.\n     *\n     * @param plugin The plugin function to apply to the resolved client.\n     * @returns A new `AsyncClient` representing the result of applying the plugin.\n     */\n    readonly use: <TOutput extends Promise<object> | object>(\n        plugin: ClientPlugin<TSelf, TOutput>,\n    ) => AsyncClient<TOutput extends Promise<infer U> ? (U extends object ? U : never) : TOutput>;\n};\n\n// TODO(loris): Add examples in this docblock using real plugins once they have been published.\n\n/**\n * Creates a new empty client that can be extended with plugins.\n *\n * This serves as an entry point for building Solana clients.\n * Start with an empty client and chain the `.use()` method\n * to apply plugins that add various functionalities such as RPC\n * connectivity, wallet integration, transaction building, and more.\n *\n * See {@link ClientPlugin} for detailed examples on creating and using plugins.\n *\n * @returns An empty client object with only the `use` method available.\n *\n * @example Basic client setup\n * ```ts\n * import { createEmptyClient } from '@solana/client';\n *\n * const client = createEmptyClient()\n *     .use(myRpcPlugin('https://api.mainnet-beta.solana.com'))\n *     .use(myWalletPlugin());\n * ```\n */\nexport function createEmptyClient(): Client<object> {\n    return addUse({});\n}\n\nfunction addUse<TSelf extends object>(value: TSelf): Client<TSelf> {\n    return Object.freeze({\n        ...value,\n        use<TOutput extends Promise<object> | object>(plugin: ClientPlugin<TSelf, TOutput>) {\n            const result = plugin(value);\n            return result instanceof Promise ? createAsyncClient(result) : addUse(result);\n        },\n    } as Client<TSelf>);\n}\n\nfunction createAsyncClient<TSelf extends object>(promise: Promise<TSelf>): AsyncClient<TSelf> {\n    return Object.freeze({\n        catch(onrejected) {\n            return promise.then(v => addUse(v)).catch(onrejected);\n        },\n        finally(onfinally) {\n            return promise.then(v => addUse(v)).finally(onfinally);\n        },\n        then(onfulfilled, onrejected) {\n            return promise.then(v => addUse(v)).then(onfulfilled, onrejected);\n        },\n        use<TOutput extends Promise<object> | object>(plugin: ClientPlugin<TSelf, TOutput>) {\n            return createAsyncClient(promise.then(plugin));\n        },\n    } as AsyncClient<TSelf>);\n}\n"]}