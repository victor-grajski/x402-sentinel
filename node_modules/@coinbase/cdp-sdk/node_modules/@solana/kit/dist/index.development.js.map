{"version":3,"sources":["../../errors/src/codes.ts","../../errors/src/messages.ts","../../errors/src/message-formatter.ts","../../errors/src/error.ts","../../errors/src/stack-trace.ts","../../errors/src/rpc-enum-errors.ts","../../errors/src/instruction-error.ts","../../errors/src/transaction-error.ts","../../errors/src/json-rpc-error.ts","../../errors/src/simulation-errors.ts","../../codecs-core/src/bytes.ts","../../codecs-core/src/codec.ts","../../codecs-core/src/combine-codec.ts","../../codecs-core/src/add-codec-sentinel.ts","../../codecs-core/src/assertions.ts","../../codecs-core/src/add-codec-size-prefix.ts","../../codecs-core/src/array-buffers.ts","../../codecs-core/src/decoder-entire-byte-array.ts","../../codecs-core/src/fix-codec-size.ts","../../codecs-core/src/offset-codec.ts","../../codecs-core/src/resize-codec.ts","../../codecs-core/src/pad-codec.ts","../../codecs-core/src/reverse-codec.ts","../../codecs-core/src/transform-codec.ts","../../codecs-strings/src/assertions.ts","../../codecs-strings/src/baseX.ts","../../codecs-strings/src/base10.ts","../../codecs-strings/src/base16.ts","../../codecs-strings/src/base58.ts","../../codecs-strings/src/baseX-reslice.ts","../../codecs-strings/src/base64.ts","../../codecs-strings/src/null-characters.ts","../../text-encoding-impl/src/index.browser.ts","../../codecs-strings/src/utf8.ts","../../accounts/src/account.ts","../../accounts/src/decode-account.ts","../../accounts/src/parse-account.ts","../../accounts/src/fetch-account.ts","../../accounts/src/maybe-account.ts","../../assertions/src/crypto.ts","../../assertions/src/subtle-crypto.ts","../../addresses/src/address.ts","../../addresses/src/vendor/noble/ed25519.ts","../../addresses/src/curve-internal.ts","../../addresses/src/curve.ts","../../addresses/src/program-derived-address.ts","../../addresses/src/public-key.ts","../../codecs-numbers/src/assertions.ts","../../codecs-numbers/src/common.ts","../../codecs-numbers/src/utils.ts","../../codecs-numbers/src/f32.ts","../../codecs-numbers/src/f64.ts","../../codecs-numbers/src/i128.ts","../../codecs-numbers/src/i16.ts","../../codecs-numbers/src/i32.ts","../../codecs-numbers/src/i64.ts","../../codecs-numbers/src/i8.ts","../../codecs-numbers/src/short-u16.ts","../../codecs-numbers/src/u128.ts","../../codecs-numbers/src/u16.ts","../../codecs-numbers/src/u32.ts","../../codecs-numbers/src/u64.ts","../../codecs-numbers/src/u8.ts","../../codecs-data-structures/src/assertions.ts","../../codecs-data-structures/src/utils.ts","../../codecs-data-structures/src/array.ts","../../codecs-data-structures/src/bit-array.ts","../../codecs-data-structures/src/boolean.ts","../../codecs-data-structures/src/bytes.ts","../../codecs-data-structures/src/constant.ts","../../codecs-data-structures/src/tuple.ts","../../codecs-data-structures/src/union.ts","../../codecs-data-structures/src/discriminated-union.ts","../../codecs-data-structures/src/enum-helpers.ts","../../codecs-data-structures/src/enum.ts","../../codecs-data-structures/src/hidden-prefix.ts","../../codecs-data-structures/src/hidden-suffix.ts","../../codecs-data-structures/src/literal-union.ts","../../codecs-data-structures/src/map.ts","../../codecs-data-structures/src/unit.ts","../../codecs-data-structures/src/nullable.ts","../../codecs-data-structures/src/set.ts","../../codecs-data-structures/src/struct.ts","../../options/src/option.ts","../../options/src/unwrap-option.ts","../../options/src/option-codec.ts","../../options/src/unwrap-option-recursively.ts","../../functional/src/pipe.ts","../../instructions/src/instruction.ts","../../instructions/src/roles.ts","../../rpc-types/src/blockhash.ts","../../rpc-types/src/cluster-url.ts","../../rpc-types/src/commitment.ts","../../rpc-types/src/lamports.ts","../../rpc-types/src/stringified-bigint.ts","../../rpc-types/src/stringified-number.ts","../../rpc-types/src/unix-timestamp.ts","../../transaction-messages/src/blockhash.ts","../../transaction-messages/src/codecs/address-table-lookup.ts","../../transaction-messages/src/codecs/header.ts","../../transaction-messages/src/codecs/instruction.ts","../../transaction-messages/src/transaction-message.ts","../../transaction-messages/src/codecs/transaction-version.ts","../../transaction-messages/src/codecs/message.ts","../../transaction-messages/src/compile/accounts.ts","../../transaction-messages/src/compile/address-table-lookups.ts","../../transaction-messages/src/compile/header.ts","../../transaction-messages/src/compile/instructions.ts","../../transaction-messages/src/compile/lifetime-token.ts","../../transaction-messages/src/compile/static-accounts.ts","../../transaction-messages/src/compile/message.ts","../../transaction-messages/src/compress-transaction-message.ts","../../transaction-messages/src/create-transaction-message.ts","../../transaction-messages/src/durable-nonce-instruction.ts","../../transaction-messages/src/durable-nonce.ts","../../transaction-messages/src/fee-payer.ts","../../transaction-messages/src/instructions.ts","../../transaction-messages/src/decompile-message.ts","../../keys/src/algorithm.ts","../../keys/src/private-key.ts","../../keys/src/public-key.ts","../../keys/src/signatures.ts","../../keys/src/key-pair.ts","../../transactions/src/codecs/signatures-encoder.ts","../../transactions/src/codecs/transaction-codec.ts","../../transactions/src/lifetime.ts","../../transactions/src/compile-transaction.ts","../../transactions/src/signatures.ts","../../transactions/src/wire-transaction.ts","../../transactions/src/transaction-size.ts","../../transactions/src/sendable-transaction.ts","../../transactions/src/transaction-message-size.ts","../../promises/src/race.ts","../../promises/src/abortable.ts","../../instruction-plans/src/instruction-plan.ts","../../instruction-plans/src/append-instruction-plan.ts","../../instruction-plans/src/transaction-plan.ts","../../instruction-plans/src/transaction-plan-result.ts","../../instruction-plans/src/transaction-plan-executor.ts","../../instruction-plans/src/transaction-planner.ts","../../offchain-messages/src/application-domain.ts","../../offchain-messages/src/codecs/application-domain.ts","../../offchain-messages/src/codecs/signing-domain.ts","../../offchain-messages/src/codecs/preamble-common.ts","../../offchain-messages/src/codecs/signatures.ts","../../offchain-messages/src/codecs/envelope.ts","../../offchain-messages/src/content.ts","../../offchain-messages/src/message-v0.ts","../../offchain-messages/src/codecs/content.ts","../../offchain-messages/src/codecs/preamble-v0.ts","../../offchain-messages/src/codecs/message-v0.ts","../../offchain-messages/src/codecs/preamble-v1.ts","../../offchain-messages/src/codecs/message-v1.ts","../../offchain-messages/src/codecs/message.ts","../../offchain-messages/src/envelope-common.ts","../../offchain-messages/src/envelope-v0.ts","../../offchain-messages/src/envelope-v1.ts","../../offchain-messages/src/envelope.ts","../../offchain-messages/src/signatures.ts","../../plugin-core/src/client.ts","../../programs/src/program-error.ts","../../rpc-spec-types/src/parse-json-with-bigints.ts","../../rpc-spec-types/src/rpc-message.ts","../../rpc-spec-types/src/stringify-json-with-bigints.ts","../../rpc-spec/src/rpc.ts","../../rpc-spec/src/rpc-api.ts","../../rpc-spec/src/rpc-transport.ts","../../rpc-transformers/src/request-transformer-bigint-downcast-internal.ts","../../rpc-transformers/src/tree-traversal.ts","../../rpc-transformers/src/request-transformer-bigint-downcast.ts","../../rpc-transformers/src/request-transformer-default-commitment-internal.ts","../../rpc-transformers/src/request-transformer-default-commitment.ts","../../rpc-transformers/src/request-transformer-integer-overflow-internal.ts","../../rpc-transformers/src/request-transformer-integer-overflow.ts","../../rpc-transformers/src/request-transformer-options-object-position-config.ts","../../rpc-transformers/src/request-transformer.ts","../../rpc-transformers/src/response-transformer-bigint-upcast-internal.ts","../../rpc-transformers/src/response-transformer-bigint-upcast.ts","../../rpc-transformers/src/response-transformer-result.ts","../../rpc-transformers/src/response-transformer-allowed-numeric-values.ts","../../rpc-transformers/src/response-transformer-throw-solana-error.ts","../../rpc-transformers/src/response-transformer.ts","../../rpc-api/src/index.ts","../../rpc-transport-http/src/http-transport-headers.ts","../../rpc-transport-http/src/http-transport.ts","../../rpc-transport-http/src/is-solana-request.ts","../../rpc-transport-http/src/http-transport-for-solana-rpc.ts","../../fast-stable-stringify/src/index.ts","../../rpc/src/rpc-integer-overflow-error.ts","../../rpc/src/rpc-default-config.ts","../../event-target-impl/src/index.browser.ts","../../rpc/src/rpc-request-coalescer.ts","../../rpc/src/rpc-request-deduplication.ts","../../rpc/src/rpc-transport.ts","../../rpc/src/rpc.ts","../../subscribable/src/async-iterable.ts","../../subscribable/src/data-publisher.ts","../../subscribable/src/demultiplex.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions-api.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions-channel.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions-pubsub-plan.ts","../../rpc-subscriptions-api/src/index.ts","../../ws-impl/src/index.browser.ts","../../rpc-subscriptions-channel-websocket/src/websocket-channel.ts","../../rpc-subscriptions/src/rpc-integer-overflow-error.ts","../../rpc-subscriptions/src/rpc-default-config.ts","../../rpc-subscriptions/src/rpc-subscriptions-autopinger.ts","../../rpc-subscriptions/src/rpc-subscriptions-channel-pool-internal.ts","../../rpc-subscriptions/src/rpc-subscriptions-channel-pool.ts","../../rpc-subscriptions/src/rpc-subscriptions-json.ts","../../rpc-subscriptions/src/rpc-subscriptions-json-bigint.ts","../../rpc-subscriptions/src/rpc-subscriptions-channel.ts","../../rpc-subscriptions/src/rpc-subscriptions-coalescer.ts","../../rpc-subscriptions/src/rpc-subscriptions-transport.ts","../../rpc-subscriptions/src/rpc-subscriptions.ts","../../signers/src/deduplicate-signers.ts","../../signers/src/transaction-modifying-signer.ts","../../signers/src/transaction-partial-signer.ts","../../signers/src/transaction-sending-signer.ts","../../signers/src/transaction-signer.ts","../../signers/src/account-signer-meta.ts","../../signers/src/add-signers.ts","../../signers/src/fee-payer-signer.ts","../../signers/src/message-partial-signer.ts","../../signers/src/keypair-signer.ts","../../signers/src/message-modifying-signer.ts","../../signers/src/message-signer.ts","../../signers/src/noop-signer.ts","../../signers/src/offchain-message-signer.ts","../../signers/src/sign-offchain-message.ts","../../signers/src/transaction-with-single-sending-signer.ts","../../signers/src/sign-transaction.ts","../../signers/src/signable-message.ts","../../transaction-confirmation/src/confirmation-strategy-blockheight.ts","../../transaction-confirmation/src/confirmation-strategy-nonce.ts","../../transaction-confirmation/src/confirmation-strategy-recent-signature.ts","../../transaction-confirmation/src/confirmation-strategy-timeout.ts","../../transaction-confirmation/src/confirmation-strategy-racer.ts","../../transaction-confirmation/src/waiters.ts","../src/airdrop-internal.ts","../src/airdrop.ts","../src/fetch-lookup-tables.ts","../src/decompile-transaction-message-fetching-lookup-tables.ts","../src/get-minimum-balance-for-rent-exemption.ts","../src/send-transaction-internal.ts","../src/send-and-confirm-durable-nonce-transaction.ts","../src/send-and-confirm-transaction.ts","../src/send-transaction-without-confirming.ts"],"names":["e","isSolanaError","ORDERED_ERROR_NAMES","SolanaError","alphabet","createEncoder","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","hexBytes","createDecoder","combineCodec","TextDecoder","TextEncoder","address","base58Encoder","Endian","newOffset","_a","getBase16Decoder","getEncodedSize","isFixedSize","getU8Encoder","transformEncoder","getU8Decoder","transformDecoder","containsBytes","AccountRole","assertValidBaseString","getBaseXEncoder","partitionLeadingZeroes","getBigIntFromBaseX","getBaseXDecoder","getBaseXFromBigInt","getBase58Encoder","getBase58Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","getAddressEncoder","getAddressDecoder","TYPE","getAddressComparator","isWritableRole","isSignerRole","signature","privateKey","getBytesEncoder","SYSTEM_PROGRAM_ADDRESS","isAdvanceNonceAccountInstructionData","signatureBytes","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT","appendTransactionMessageInstruction","context","traverse","traverseSequential","traverseParallel","traverseSingle","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND","candidate","message","appendTransactionMessageInstructions","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND","getSignaturesToEncode","getSignaturesEncoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO","getBytesDecoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO","OffchainMessageContentFormat","getUtf8Encoder","fixDecoderSize","getTupleDecoder","getUtf8Decoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY","getTupleEncoder","getHiddenPrefixDecoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED","SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE","unwrapBigIntValueObject","wrapBigIntValueObject","pipe","AbortController","o","normalizeHeaders","EventTarget","EXPLICIT_ABORT_TOKEN","createExplicitAbortToken","getAllowedNumericKeypaths","memoizedKeypaths","index_browser_default","t","createSolanaJsonRpcIntegerOverflowError","transformChannelInboundMessages","transformChannelOutboundMessages","cache","offchainMessageEnvelope","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","transaction","base58Decoder","safeRace","getTimeoutPromise","lamports"],"mappings":"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","file":"index.development.js","sourcesContent":["/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors  e.g. under the same package  can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names  e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Offchain-message-related errors.\n// Reserve error codes in the range [5607000-5607999].\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED = 5607000;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE = 5607001;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE = 5607002;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH = 5607003;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH = 5607004;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO = 5607005;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED = 5607006;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH = 5607007;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH = 5607008;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY = 5607009;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO = 5607010;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING = 5607011;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH = 5607012;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE = 5607013;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION = 5607014;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED = 5607015;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE = 5607016;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE = 5607017;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nexport const SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Instruction plan related errors.\n// Reserve error codes in the range [7618000-7618999].\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED = 7618004;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND = 7618005;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN = 7618006;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN = 7618007;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT = 7618008;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT = 7618009;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nexport const SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n\n/**\n * Errors of this type have a deprecated `cause` property. Consumers should use the error's\n * `context` instead to access relevant error information.\n */\nexport type SolanaErrorCodeWithDeprecatedCause =\n    typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN;\n","/* eslint-disable sort-keys-fix/sort-keys-fix */\n/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]:\n        'This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: 'Invalid instruction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: 'The provided instruction plan is empty.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND]:\n        'No failed transaction plan result was found in the provided transaction plan result.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED]:\n        'This transaction plan executor does not support non-divisible sequential plans. To support them, you may create your own executor such that multi-transaction atomicity is preserved  e.g. by targetting RPCs that support transaction bundles.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]:\n        'The provided transaction plan failed to execute. See the `transactionPlanResult` attribute for more details. Note that the `cause` property is deprecated, and a future version will not set it.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]:\n        'The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: 'Invalid transaction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]:\n        'No more instructions to pack; the message packer has completed the instruction plan.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN]:\n        'Unexpected instruction plan. Expected $expectedKind plan, got $actualKind plan.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN]:\n        'Unexpected transaction plan. Expected $expectedKind plan, got $actualKind plan.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT]:\n        'Unexpected transaction plan result. Expected $expectedKind plan, got $actualKind plan.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT]:\n        'Expected a successful transaction plan result. I.e. there is at least one failed or cancelled transaction in the plan.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]:\n        'Epoch rewards period still active at slot $slot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]:\n        'Failed to query long-term storage; please try again',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]:\n        \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]:\n        'Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]:\n        'Attempted to sign an offchain message with an address that is not a signer for it',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]:\n        'The signer addresses in this offchain message envelope do not match the list of ' +\n        'required signers in the message preamble. These unexpected signers were present in the ' +\n        'envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope ' +\n        '`[$missingSigners]`.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]:\n        'The message body provided has a byte-length of $actualBytes. The maximum allowable ' +\n        'byte-length is $maxBytes',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]:\n        'Expected message format $expectedMessageFormat, got $actualMessageFormat',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]:\n        'The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY]: 'Offchain message content must be non-empty',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO]:\n        'Offchain message must specify the address of at least one required signer',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO]:\n        'Offchain message envelope must reserve space for at least one signature',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]:\n        'The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED]:\n        'The signatories of this offchain message must be listed in lexicographical order',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE]:\n        'An address must be listed no more than once among the signatories of an offchain message',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]:\n        'Offchain message is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]:\n        'Offchain message signature verification failed. Signature mismatch for required ' +\n        'signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories ' +\n        '[$signatoriesWithMissingSignatures]',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE]:\n        'The message body provided contains characters whose codes fall outside the allowed ' +\n        'range. In order to ensure clear-signing compatiblity with hardware wallets, the message ' +\n        'may only contain line feeds and characters in the range [\\\\x20-\\\\x7e].',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]:\n        'Expected offchain message version $expectedVersion. Got $actualVersion.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding offchain messages with version ' +\n        '$unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]:\n        'The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause, SolanaErrorCodeWithDeprecatedCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A variant of {@link SolanaError} where the `cause` property is deprecated.\n *\n * This type is returned by {@link isSolanaError} when checking for error codes in\n * {@link SolanaErrorCodeWithDeprecatedCause}. Accessing `cause` on these errors will show\n * a deprecation warning in IDEs that support JSDoc `@deprecated` tags.\n */\nexport interface SolanaErrorWithDeprecatedCause<\n    TErrorCode extends SolanaErrorCodeWithDeprecatedCause = SolanaErrorCodeWithDeprecatedCause,\n> extends Omit<SolanaError<TErrorCode>, 'cause'> {\n    /**\n     * @deprecated The `cause` property is deprecated for this error code.\n     * Use the error's `context` property instead to access relevant error information.\n     */\n    readonly cause?: unknown;\n}\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCodeWithDeprecatedCause>(\n    e: unknown,\n    code: TErrorCode,\n): e is SolanaErrorWithDeprecatedCause<TErrorCode>;\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode>;\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = {\n    [P in SolanaErrorCode]: Readonly<{\n        __code: P;\n    }> &\n        (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]);\n};\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n                // If the `ErrorOptions` type ever changes, update this code.\n                if (name === 'cause') {\n                    errorOptions = { cause: descriptor.value };\n                } else {\n                    if (context === undefined) {\n                        context = {\n                            __code: code,\n                        } as unknown as SolanaErrorContext[TErrorCode];\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = Object.freeze(\n            context === undefined\n                ? {\n                      __code: code,\n                  }\n                : context,\n        ) as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import { SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN } from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/solana-sdk/blob/master/instruction-error/src/lib.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: bigint;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: bigint;\n              owner: string;\n              rentEpoch: bigint;\n              space?: bigint;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    loadedAccountsDataSize: number | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SolanaErrorCode,\n} from './codes';\nimport { isSolanaError } from './error';\n\n/**\n * Extracts the underlying cause from a simulation-related error.\n *\n * When a transaction simulation fails, the error is often wrapped in a\n * simulation-specific {@link SolanaError}. This function unwraps such errors\n * by returning the `cause` property, giving you access to the actual error\n * that triggered the simulation failure.\n *\n * If the provided error is not a simulation-related error, it is returned unchanged.\n *\n * The following error codes are considered simulation errors:\n * - {@link SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE}\n * - {@link SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT}\n *\n * @param error - The error to unwrap.\n * @return The underlying cause if the error is a simulation error, otherwise the original error.\n *\n * @example\n * Unwrapping a preflight failure to access the root cause.\n * ```ts\n * import { unwrapSimulationError } from '@solana/errors';\n *\n * try {\n *     await sendTransaction(signedTransaction);\n * } catch (e) {\n *     const cause = unwrapSimulationError(e);\n *     console.log('Send transaction failed due to:', cause);\n * }\n * ```\n */\nexport function unwrapSimulationError(error: unknown): unknown {\n    const simulationCodes: SolanaErrorCode[] = [\n        SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    ];\n    if (isSolanaError(error) && !!error.cause && simulationCodes.includes(error.context.__code)) {\n        return error.cause;\n    }\n    return error;\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    return bytesEqual(slice, bytes);\n}\n\n/**\n * Returns true if and only if the provided `bytes1` and `bytes2` byte arrays are equal.\n *\n * @param bytes1 - The first byte array to compare.\n * @param bytes2 - The second byte array to compare.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const bytes2 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * bytesEqual(bytes1, bytes2); // true\n * ```\n */\nexport function bytesEqual(bytes1: ReadonlyUint8Array | Uint8Array, bytes2: ReadonlyUint8Array | Uint8Array): boolean {\n    return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array<ArrayBuffer>;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts a `Uint8Array` to an `ArrayBuffer`. If the underlying buffer is a `SharedArrayBuffer`,\n * it will be copied to a non-shared buffer, for safety.\n *\n * @remarks\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nexport function toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    let buffer: ArrayBuffer;\n    if (typeof SharedArrayBuffer === 'undefined') {\n        buffer = bytes.buffer as ArrayBuffer;\n    } else if (bytes.buffer instanceof SharedArrayBuffer) {\n        buffer = new ArrayBuffer(bytes.length);\n        new Uint8Array(buffer).set(new Uint8Array(bytes));\n    } else {\n        buffer = bytes.buffer;\n    }\n    return (bytesOffset === 0 || bytesOffset === -bytes.byteLength) && bytesLength === bytes.byteLength\n        ? buffer\n        : buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SolanaError } from '@solana/errors';\n\nimport { createDecoder, Decoder } from './codec';\n\n/**\n * Create a {@link Decoder} that asserts that the bytes provided to `decode` or `read` are fully consumed by the inner decoder\n * @param decoder A decoder to wrap\n * @returns A new decoder that will throw if provided with a byte array that it does not fully consume\n *\n * @typeParam T - The type of the decoder\n *\n * @remarks\n * Note that this compares the offset after encoding to the length of the input byte array\n *\n * The `offset` parameter to `decode` and `read` is still considered, and will affect the new offset that is compared to the byte array length\n *\n * The error that is thrown by the returned decoder is a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY`\n *\n * @example\n * Create a decoder that decodes a `u32` (4 bytes) and ensures the entire byte array is consumed\n * ```ts\n * const decoder = createDecoderThatUsesExactByteArray(getU32Decoder());\n * decoder.decode(new Uint8Array([0, 0, 0, 0])); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0])); // throws\n *\n * // with an offset\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0]), 1); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0, 0]), 1); // throws\n * ```\n */\nexport function createDecoderThatConsumesEntireByteArray<T>(decoder: Decoder<T>): Decoder<T> {\n    return createDecoder({\n        ...decoder,\n        read(bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset,\n                });\n            }\n            return [value, newOffset];\n        },\n    });\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    toArrayBuffer,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(toArrayBuffer(bytes), offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\ntype ParsedAccountMeta = { program: string; type?: string };\ntype JsonParsedAccountData<TData extends object> = TData & { parsedAccountMeta?: ParsedAccountMeta };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<JsonParsedAccountData<TData>, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<JsonParsedAccountData<TData>, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<JsonParsedAccountData<TData>, TAddress> | MaybeAccount<JsonParsedAccountData<TData>, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = (rpcAccount.data.parsed.info || {}) as TData;\n\n    if (rpcAccount.data.program || rpcAccount.data.parsed.type) {\n        (data as JsonParsedAccountData<TData>).parsedAccountMeta = {\n            program: rpcAccount.data.program,\n            type: rpcAccount.data.parsed.type,\n        };\n    }\n\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<\n    | MaybeAccount<TData & { parsedAccountMeta?: { program: string; type?: string } }, TAddress>\n    | MaybeEncodedAccount<TAddress>\n> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<\n                  TData[P & keyof TData] & { parsedAccountMeta?: { program: string; type?: string } },\n                  TAddresses[P]\n              >\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<\n                  TData[P] & { parsedAccountMeta?: { program: string; type?: string } },\n                  TAddresses[P & keyof TAddresses]\n              >\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the Software), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7); // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y\n    const u = mod(y2 - 1n); // u=y-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport { bytesEqual, type ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        bytesEqual(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    toArrayBuffer,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //    The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //    Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //    Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   ------ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |          Value (5)\n * //   |   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |          Value (42)\n * //   |    Key (\"alice\", 5 bytes fixed)\n * //    2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rusts `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rusts `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rusts `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   -- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   -- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[],\n> extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer  is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends Partial<TransactionMessageWithLifetime> & TransactionMessage,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\n/**\n * @deprecated Use `TransactionMessage` instead.\n */\n// TODO(#1147) Stop exporting this in a future major version.\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\nexport type NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = TTransactionMessage extends unknown\n    ? Omit<\n          // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n          TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n              ? TTransactionMessage\n              : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n          // 2. Remove the instructions array as we are going to replace it with a new one.\n          'instructions'\n      > & {\n          // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n          readonly instructions: TTransactionMessage['instructions'] extends readonly [\n              AdvanceNonceAccountInstruction,\n              ...infer TTail extends readonly Instruction[],\n          ]\n              ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n              : readonly [\n                    AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n                    ...TTransactionMessage['instructions'],\n                ];\n          // 4. Set the lifetime constraint to the nonce value.\n          readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n      }\n    : never;\n","import { Address } from '@solana/addresses';\n\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends unknown ? Omit<TTransactionMessage, 'feePayer'> : never;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends Partial<TransactionMessageWithFeePayer> & TransactionMessage,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n        TransactionMessageWithFeePayer<TFeePayerAddress>;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n          readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n      }\n    : never;\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<\n          ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n          'instructions'\n      > & {\n          readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n      }\n    : never;\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    }) as AppendTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    }) as unknown as PrependTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BlockhashLifetimeConstraint, setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | BlockhashLifetimeConstraint\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as TransactionMessage,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    ) as TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime;\n}\n","export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array<ArrayBuffer> {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array, toArrayBuffer } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\n\n/**\n * Asserts that an arbitrary `ReadonlyUint8Array` is an Ed25519 signature.\n *\n * Useful when you receive a `ReadonlyUint8Array` from an external interface (like the browser wallets' `signMessage` API) that you expect to\n * represent an Ed25519 signature.\n *\n * @example\n * ```ts\n * import { assertIsSignatureBytes } from '@solana/keys';\n *\n * // Imagine a function that verifies a signature.\n * function verifySignature() {\n *     // We know only that the input conforms to the `ReadonlyUint8Array` type.\n *     const signatureBytes: ReadonlyUint8Array = signatureBytesInput;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signatureBytes` to `SignatureBytes`.\n *         assertIsSignatureBytes(signatureBytes);\n *         // At this point, `signatureBytes` is a `SignatureBytes` that can be used with `verifySignature`.\n *         if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *             throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *         }\n *     } catch (e) {\n *         // `signatureBytes` turned out not to be a 64-byte Ed25519 signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignatureBytes(\n    putativeSignatureBytes: ReadonlyUint8Array,\n): asserts putativeSignatureBytes is SignatureBytes {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\n\n/**\n * A type guard that accepts a `ReadonlyUint8Array` as input. It will both return `true` if the `ReadonlyUint8Array` conforms to\n * the {@link SignatureBytes} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignatureBytes } from '@solana/keys';\n *\n * if (isSignatureBytes(signatureBytes)) {\n *     // At this point, `signatureBytes` has been refined to a\n *     // `SignatureBytes` that can be used with `verifySignature`.\n *     if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *         throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *     }\n * } else {\n *     setError(`${signatureBytes} is not a 64-byte Ed25519 signature`);\n * }\n * ```\n */\nexport function isSignatureBytes(putativeSignatureBytes: ReadonlyUint8Array): putativeSignatureBytes is SignatureBytes {\n    return putativeSignatureBytes.byteLength === 64;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, toArrayBuffer(data));\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * This helper combines _asserting_ that a `ReadonlyUint8Array` is an Ed25519 signature with _coercing_ it to the\n * {@link SignatureBytes} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signatureBytes } from '@solana/keys';\n *\n * const signature = signatureBytes(userSuppliedSignatureBytes);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport function signatureBytes(putativeSignatureBytes: ReadonlyUint8Array): SignatureBytes {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, toArrayBuffer(signature), toArrayBuffer(data));\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import { type Address, isAddress } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SolanaError,\n} from '@solana/errors';\nimport { type Blockhash, isBlockhash, type Slot } from '@solana/rpc-types';\nimport type {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    Nonce,\n    TransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport type { Transaction } from './transaction';\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network. The transaction will continue to be eligible to land until the network considers the\n * `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type TransactionBlockhashLifetime = {\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction eligible to land.\n     */\n    lastValidBlockHeight: Slot;\n};\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionDurableNonceLifetime = {\n    /**\n     * A value contained in the account with address `nonceAccountAddress` at the time the\n     * transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce;\n    /** The account that contains the `nonce` value */\n    nonceAccountAddress: Address;\n};\n\n/**\n * A transaction whose ability to land on the network is determined by some evanescent criteria.\n *\n * This describes a window of time after which a transaction is constructed and before which it will\n * no longer be accepted by the network.\n *\n * No transaction can land on Solana without having a `lifetimeConstraint` set.\n */\nexport type TransactionWithLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime | TransactionDurableNonceLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by the age of a blockhash observed on the network.\n *\n * The transaction will continue to be eligible to land until the network considers the `blockhash`\n * to be expired.\n */\nexport type TransactionWithBlockhashLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by a nonce.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionWithDurableNonceLifetime = {\n    readonly lifetimeConstraint: TransactionDurableNonceLifetime;\n};\n\n/**\n * Helper type that sets the lifetime constraint of a transaction to be the same as the\n * lifetime constraint of the provided transaction message.\n *\n * If the transaction message has no explicit lifetime constraint, neither will the transaction.\n */\nexport type SetTransactionLifetimeFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends TransactionMessage,\n> = TTransactionMessage extends { lifetimeConstraint: unknown }\n    ? TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithBlockhashLifetime['lifetimeConstraint']\n        ? TransactionWithBlockhashLifetime & TTransaction\n        : TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithDurableNonceLifetime['lifetimeConstraint']\n          ? TransactionWithDurableNonceLifetime & TTransaction\n          : TransactionWithLifetime & TTransaction\n    : TTransaction;\n\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address;\n\nfunction compiledInstructionIsAdvanceNonceInstruction(\n    instruction: CompiledTransactionMessage['instructions'][number],\n    staticAddresses: Address[],\n): instruction is typeof instruction & { accountIndices: [number, number, number] } {\n    return (\n        staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accountIndices?.length === 3\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): boolean {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * Get the lifetime constraint for a transaction from a compiled transaction message that includes a lifetime token.\n * @param compiledTransactionMessage A compiled transaction message that includes a lifetime token\n * @returns A lifetime constraint for the transaction\n * Note that this is less precise than checking a decompiled instruction, as we can't inspect\n * the address or role of input accounts (which may be in lookup tables). However, this is\n * sufficient for all valid advance durable nonce instructions.\n * Note that the program address must not be in a lookup table, see [this answer on StackExchange](https://solana.stackexchange.com/a/16224/289)\n * @see {@link isAdvanceNonceAccountInstruction}\n * Note that this function is async to allow for future implementations that may fetch `lastValidBlockHeight` using an RPC\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n): Promise<TransactionBlockhashLifetime | TransactionDurableNonceLifetime> {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n\n    // We need to check if the first instruction is an AdvanceNonceAccount instruction\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken,\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken as Nonce,\n            nonceAccountAddress,\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken as Blockhash,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn,\n        };\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * if (isTransactionWithBlockhashLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a `TransactionWithBlockhashLifetime`.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'blockhash' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transaction.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * blockhash-based lifetime, from for example a wallet. Use this function to\n * assert that such a transaction actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithBlockhashLifetime`.\n *     assertIsTransactionWithBlockhashLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `transaction` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithDurableNonceLifetime } from '@solana/transactions';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionWithDurableNonceLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a\n *     // `TransactionWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'nonce' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        typeof transaction.lifetimeConstraint.nonceAccountAddress === 'string' &&\n        isAddress(transaction.lifetimeConstraint.nonceAccountAddress)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * nonce-based lifetime, from for example a wallet. Use this function to assert\n * that such a transaction actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithDurableNonceLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithDurableNonceLifetime`.\n *     assertIsTransactionWithDurableNonceLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `transaction` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithDurableNonceLifetime {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n","import {\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link TransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { bytesEqual, Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n *  such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\n/**\n * An implementation of [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n * that causes all of the losing promises to settle. This allows them to be released and garbage\n * collected, preventing memory leaks.\n *\n * Read more here: https://github.com/nodejs/node/issues/17469\n */\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\n/**\n * Returns a new promise that will reject if the abort signal fires before the original promise\n * settles. Resolves or rejects with the value of the original promise otherwise.\n *\n * @example\n * ```ts\n * const result = await getAbortablePromise(\n *     // Resolves or rejects when `fetch` settles.\n *     fetch('https://example.com/json').then(r => r.json()),\n *     // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n *     AbortSignal.timeout(5000),\n * );\n * ```\n */\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomically  either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message  when possible  and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Checks if the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a single instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * if (isSingleInstructionPlan(plan)) {\n *   console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * }\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link assertIsSingleInstructionPlan}\n */\nexport function isSingleInstructionPlan(plan: InstructionPlan): plan is SingleInstructionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a single instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * assertIsSingleInstructionPlan(plan);\n * console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link isSingleInstructionPlan}\n */\nexport function assertIsSingleInstructionPlan(plan: InstructionPlan): asserts plan is SingleInstructionPlan {\n    if (!isSingleInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a message packer instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * if (isMessagePackerInstructionPlan(plan)) {\n *   const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link assertIsMessagePackerInstructionPlan}\n */\nexport function isMessagePackerInstructionPlan(plan: InstructionPlan): plan is MessagePackerInstructionPlan {\n    return plan.kind === 'messagePacker';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a message packer instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * assertIsMessagePackerInstructionPlan(plan);\n * const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link isMessagePackerInstructionPlan}\n */\nexport function assertIsMessagePackerInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is MessagePackerInstructionPlan {\n    if (!isMessagePackerInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'messagePacker',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isSequentialInstructionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsSequentialInstructionPlan}\n */\nexport function isSequentialInstructionPlan(plan: InstructionPlan): plan is SequentialInstructionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsSequentialInstructionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isSequentialInstructionPlan}\n */\nexport function assertIsSequentialInstructionPlan(plan: InstructionPlan): asserts plan is SequentialInstructionPlan {\n    if (!isSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically  either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a non-divisible sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isNonDivisibleSequentialInstructionPlan(plan)) {\n *   // All instructions must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsNonDivisibleSequentialInstructionPlan}\n */\nexport function isNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): plan is SequentialInstructionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically  either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a non-divisible sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsNonDivisibleSequentialInstructionPlan(plan);\n * // All instructions must be executed atomically.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isNonDivisibleSequentialInstructionPlan}\n */\nexport function assertIsNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is SequentialInstructionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a parallel instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * if (isParallelInstructionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * }\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link assertIsParallelInstructionPlan}\n */\nexport function isParallelInstructionPlan(plan: InstructionPlan): plan is ParallelInstructionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a parallel instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * assertIsParallelInstructionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link isParallelInstructionPlan}\n */\nexport function assertIsParallelInstructionPlan(plan: InstructionPlan): asserts plan is ParallelInstructionPlan {\n    if (!isParallelInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Finds the first instruction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the instruction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param instructionPlan - The instruction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @returns The first matching instruction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const nonDivisible = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing instructionC and instructionD.\n * ```\n *\n * @example\n * Finding a specific single instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const found = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.instruction === instructionB,\n * );\n * // Returns the SingleInstructionPlan wrapping instructionB.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function findInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): InstructionPlan | undefined {\n    if (predicate(instructionPlan)) {\n        return instructionPlan;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return undefined;\n    }\n    for (const subPlan of instructionPlan.plans) {\n        const foundPlan = findInstructionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every instruction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the instruction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param instructionPlan - The instruction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const allDivisible = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single instructions use a specific program.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const allUseSameProgram = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.instruction.programAddress === myProgramAddress,\n * );\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function everyInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): boolean {\n    if (!predicate(instructionPlan)) {\n        return false;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return true;\n    }\n    return instructionPlan.plans.every(p => everyInstructionPlan(p, predicate));\n}\n\n/**\n * Transforms an instruction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the instruction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param instructionPlan - The instruction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed instruction plan tree.\n *\n * @example\n * Making all sequential plans non-divisible to ensure atomicity.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' && p.divisible) {\n *     return nonDivisibleSequentialInstructionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Filtering out debug instructions before production execution.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, debugInstruction, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' || p.kind === 'parallel') {\n *     return { ...p, plans: p.plans.filter((p) => !isDebugInstruction(p)) };\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function transformInstructionPlan(\n    instructionPlan: InstructionPlan,\n    fn: (plan: InstructionPlan) => InstructionPlan,\n): InstructionPlan {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return Object.freeze(fn(instructionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...instructionPlan,\n                plans: instructionPlan.plans.map(p => transformInstructionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleInstructionPlan} and {@link MessagePackerInstructionPlan}\n * instances from an instruction plan tree.\n *\n * This function recursively traverses any nested structure of instruction plans and extracts\n * all the leaf plans they contain. It's useful when you need to access all the individual\n * instructions or message packers that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param instructionPlan - The instruction plan to extract leaf plans from\n * @returns An array of all single and message packer instruction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n *   instructionE,\n * ]);\n *\n * const leafPlans = flattenInstructionPlan(plan);\n * // Array of `SingleInstructionPlan` containing:\n * // instructionA, instructionB, instructionC, instructionD and instructionE.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n */\nexport function flattenInstructionPlan(\n    instructionPlan: InstructionPlan,\n): (MessagePackerInstructionPlan | SingleInstructionPlan)[] {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return [instructionPlan];\n    }\n    return instructionPlan.plans.flatMap(flattenInstructionPlan);\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n *  e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, SolanaError } from '@solana/errors';\nimport { type Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport { flattenInstructionPlan, InstructionPlan } from './instruction-plan';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\n\ntype AppendTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> = ReturnType<\n    typeof appendTransactionMessageInstructions<TTransactionMessage, Instruction[]>\n>;\n\n/**\n * Appends all instructions from an instruction plan to a transaction message.\n *\n * This function flattens the instruction plan into its leaf plans and sequentially\n * appends each instruction to the provided transaction message. It handles both\n * single instructions and message packer plans.\n *\n * Note that any {@link MessagePackerInstructionPlan} is assumed to only append\n * instructions. If it modifies other properties of the transaction message, the\n * type of the returned transaction message may not accurately reflect those changes.\n *\n * @typeParam TTransactionMessage - The type of transaction message being modified.\n *\n * @param transactionMessage - The transaction message to append instructions to.\n * @param instructionPlan - The instruction plan containing the instructions to append.\n * @returns The transaction message with all instructions from the plan appended.\n *\n * @example\n * Appending a simple instruction plan to a transaction message.\n * ```ts\n * import { appendTransactionMessageInstructionPlan } from '@solana/instruction-plans';\n * import { createTransactionMessage, setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const message = setTransactionMessageFeePayer(feePayer, createTransactionMessage({ version: 0 }));\n * const plan = singleInstructionPlan(myInstruction);\n *\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @example\n * Appending a sequential instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function appendTransactionMessageInstructionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer,\n>(\n    instructionPlan: InstructionPlan,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage> {\n    type Out = AppendTransactionMessageInstructions<TTransactionMessage>;\n\n    const leafInstructionPlans = flattenInstructionPlan(instructionPlan);\n\n    return leafInstructionPlans.reduce(\n        (messageSoFar, plan) => {\n            const kind = plan.kind;\n            if (kind === 'single') {\n                return appendTransactionMessageInstruction(plan.instruction, messageSoFar) as unknown as Out;\n            }\n            if (kind === 'messagePacker') {\n                const messagerPacker = plan.getMessagePacker();\n                let nextMessage: Out = messageSoFar;\n                while (!messagerPacker.done()) {\n                    nextMessage = messagerPacker.packMessageToCapacity(nextMessage) as Out;\n                }\n                return nextMessage;\n            }\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n                kind,\n            });\n        },\n        transactionMessage as unknown as Out,\n    );\n}\n","import { SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, SolanaError } from '@solana/errors';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically  usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Checks if the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a single transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * if (isSingleTransactionPlan(plan)) {\n *   console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link assertIsSingleTransactionPlan}\n */\nexport function isSingleTransactionPlan(plan: TransactionPlan): plan is SingleTransactionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a single transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * assertIsSingleTransactionPlan(plan);\n * console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link isSingleTransactionPlan}\n */\nexport function assertIsSingleTransactionPlan(plan: TransactionPlan): asserts plan is SingleTransactionPlan {\n    if (!isSingleTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * if (isSequentialTransactionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsSequentialTransactionPlan}\n */\nexport function isSequentialTransactionPlan(plan: TransactionPlan): plan is SequentialTransactionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsSequentialTransactionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isSequentialTransactionPlan}\n */\nexport function assertIsSequentialTransactionPlan(plan: TransactionPlan): asserts plan is SequentialTransactionPlan {\n    if (!isSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a non-divisible sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * if (isNonDivisibleSequentialTransactionPlan(plan)) {\n *   // All transaction messages must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlan}\n */\nexport function isNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): plan is SequentialTransactionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a non-divisible sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlan(plan);\n * // All transaction messages must be executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isNonDivisibleSequentialTransactionPlan}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): asserts plan is SequentialTransactionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a parallel transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * if (isParallelTransactionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link assertIsParallelTransactionPlan}\n */\nexport function isParallelTransactionPlan(plan: TransactionPlan): plan is ParallelTransactionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a parallel transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * assertIsParallelTransactionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link isParallelTransactionPlan}\n */\nexport function assertIsParallelTransactionPlan(plan: TransactionPlan): asserts plan is ParallelTransactionPlan {\n    if (!isParallelTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * @deprecated Use {@link flattenTransactionPlan} instead.\n */\nexport const getAllSingleTransactionPlans = flattenTransactionPlan;\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = flattenTransactionPlan(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * ```\n */\nexport function flattenTransactionPlan(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(flattenTransactionPlan);\n}\n\n/**\n * Finds the first transaction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param transactionPlan - The transaction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @return The first matching transaction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const nonDivisible = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing messageC and messageD.\n * ```\n *\n * @example\n * Finding a specific single transaction plan.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB, messageC]);\n *\n * const found = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.message === messageB,\n * );\n * // Returns the SingleTransactionPlan wrapping messageB.\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function findTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): TransactionPlan | undefined {\n    if (predicate(transactionPlan)) {\n        return transactionPlan;\n    }\n    if (transactionPlan.kind === 'single') {\n        return undefined;\n    }\n    for (const subPlan of transactionPlan.plans) {\n        const foundPlan = findTransactionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every transaction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param transactionPlan - The transaction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const allDivisible = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single plans have a specific fee payer.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const allUseSameFeePayer = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.message.feePayer.address === myFeePayer,\n * );\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function everyTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): boolean {\n    if (!predicate(transactionPlan)) {\n        return false;\n    }\n    if (transactionPlan.kind === 'single') {\n        return true;\n    }\n    return transactionPlan.plans.every(p => everyTransactionPlan(p, predicate));\n}\n\n/**\n * Transforms a transaction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlan - The transaction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed transaction plan tree.\n *\n * @example\n * Removing parallelism by converting parallel plans to sequential.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'parallel') {\n *     return sequentialTransactionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Updating the fee payer on all transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'single') {\n *     return singleTransactionPlan({ ...p.message, feePayer: newFeePayer });\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function transformTransactionPlan(\n    transactionPlan: TransactionPlan,\n    fn: (plan: TransactionPlan) => TransactionPlan,\n): TransactionPlan {\n    if (transactionPlan.kind === 'single') {\n        return Object.freeze(fn(transactionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlan,\n                plans: transactionPlan.plans.map(p => transformTransactionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { getSignatureFromTransaction, Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = ParallelTransactionPlanResult<TContext, TSingle> | SequentialTransactionPlanResult<TContext, TSingle> | TSingle;\n\n/**\n * A {@link TransactionPlanResult} where all single transaction results are successful.\n *\n * This type represents a transaction plan result tree where every\n * {@link SingleTransactionPlanResult} has a 'successful' status. It can be used\n * to ensure that an entire execution completed without any failures or cancellations.\n *\n * Note: This is different from {@link SuccessfulSingleTransactionPlanResult} which\n * represents a single successful transaction, whereas this type represents an entire\n * plan result tree (which may contain parallel/sequential structures) where all\n * leaf nodes are successful.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link SuccessfulSingleTransactionPlanResult}\n */\nexport type SuccessfulTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = TransactionPlanResult<TContext, SuccessfulSingleTransactionPlanResult<TContext>>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; signature: Signature; transaction?: Transaction }>\n    | Readonly<{ error: Error; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? ({} as TContext),\n            kind: 'successful',\n            signature: getSignatureFromTransaction(transaction),\n            transaction,\n        }),\n    });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and signature.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the signature of the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param signature - The signature of the successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   signature\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResultFromSignature<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    signature: Signature,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', signature }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage, error: Error): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSingleTransactionPlanResult(result)) {\n *   console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link assertIsSingleTransactionPlanResult}\n */\nexport function isSingleTransactionPlanResult(plan: TransactionPlanResult): plan is SingleTransactionPlanResult {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSingleTransactionPlanResult(result);\n * console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link isSingleTransactionPlanResult}\n */\nexport function assertIsSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SingleTransactionPlanResult {\n    if (!isSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a successful single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSuccessfulSingleTransactionPlanResult(result)) {\n *   console.log(result.status.signature); // TypeScript knows this is a successful result.\n * }\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'successful';\n}\n\n/**\n * Asserts that the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a successful single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSuccessfulSingleTransactionPlanResult(result);\n * console.log(result.status.signature); // TypeScript knows this is a successful result.\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulSingleTransactionPlanResult {\n    if (!isSuccessfulSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'successful single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a failed single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * if (isFailedSingleTransactionPlanResult(result)) {\n *   console.log(result.status.error); // TypeScript knows this is a failed result.\n * }\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link assertIsFailedSingleTransactionPlanResult}\n */\nexport function isFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is FailedSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'failed';\n}\n\n/**\n * Asserts that the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a failed single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * assertIsFailedSingleTransactionPlanResult(result);\n * console.log(result.status.error); // TypeScript knows this is a failed result.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link isFailedSingleTransactionPlanResult}\n */\nexport function assertIsFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is FailedSingleTransactionPlanResult {\n    if (!isFailedSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'failed single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a canceled single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * if (isCanceledSingleTransactionPlanResult(result)) {\n *   console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * }\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link assertIsCanceledSingleTransactionPlanResult}\n */\nexport function isCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is CanceledSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'canceled';\n}\n\n/**\n * Asserts that the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a canceled single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * assertIsCanceledSingleTransactionPlanResult(result);\n * console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link isCanceledSingleTransactionPlanResult}\n */\nexport function assertIsCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is CanceledSingleTransactionPlanResult {\n    if (!isCanceledSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'canceled single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isSequentialTransactionPlanResult(result)) {\n *   console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsSequentialTransactionPlanResult}\n */\nexport function isSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsSequentialTransactionPlanResult(result);\n * console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isSequentialTransactionPlanResult}\n */\nexport function assertIsSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult {\n    if (!isSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a non-divisible sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isNonDivisibleSequentialTransactionPlanResult(result)) {\n *   // Transactions were executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlanResult}\n */\nexport function isNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a non-divisible sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlanResult(result);\n * // Transactions were executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isNonDivisibleSequentialTransactionPlanResult}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a parallel transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * if (isParallelTransactionPlanResult(result)) {\n *   console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link assertIsParallelTransactionPlanResult}\n */\nexport function isParallelTransactionPlanResult(plan: TransactionPlanResult): plan is ParallelTransactionPlanResult {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a parallel transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * assertIsParallelTransactionPlanResult(result);\n * console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link isParallelTransactionPlanResult}\n */\nexport function assertIsParallelTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is ParallelTransactionPlanResult {\n    if (!isParallelTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It recursively checks all nested results\n * to ensure every {@link SingleTransactionPlanResult} has a 'successful' status.\n *\n * Note: This is different from {@link isSuccessfulSingleTransactionPlanResult} which\n * checks if a single result is successful. This function checks that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if all single transaction results in the tree are successful, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * if (isSuccessfulTransactionPlanResult(result)) {\n *   // All transactions were successful.\n *   result satisfies SuccessfulTransactionPlanResult;\n * }\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulTransactionPlanResult {\n    return everyTransactionPlanResult(\n        plan,\n        r => !isSingleTransactionPlanResult(r) || isSuccessfulSingleTransactionPlanResult(r),\n    );\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It throws if any {@link SingleTransactionPlanResult}\n * in the tree has a 'failed' or 'canceled' status.\n *\n * Note: This is different from {@link assertIsSuccessfulSingleTransactionPlanResult} which\n * asserts that a single result is successful. This function asserts that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT` if\n * any single transaction result in the tree is not successful.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * assertIsSuccessfulTransactionPlanResult(result);\n * // All transactions were successful.\n * result satisfies SuccessfulTransactionPlanResult;\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulTransactionPlanResult {\n    if (!isSuccessfulTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT, {\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Finds the first transaction plan result in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan result tree,\n * returning the first result that satisfies the predicate. It checks the root result\n * first, then recursively searches through nested results.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @param predicate - A function that returns `true` for the result to find.\n * @returns The first matching transaction plan result, or `undefined` if no match is found.\n *\n * @example\n * Finding a failed transaction result.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n * ]);\n *\n * const failed = findTransactionPlanResult(\n *   result,\n *   (r) => r.kind === 'single' && r.status.kind === 'failed',\n * );\n * // Returns the failed single transaction plan result for messageB.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function findTransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionPlanResult: TransactionPlanResult<TContext>,\n    predicate: (result: TransactionPlanResult<TContext>) => boolean,\n): TransactionPlanResult<TContext> | undefined {\n    if (predicate(transactionPlanResult)) {\n        return transactionPlanResult;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return undefined;\n    }\n    for (const subResult of transactionPlanResult.plans) {\n        const foundResult = findTransactionPlanResult(subResult, predicate);\n        if (foundResult) {\n            return foundResult;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Retrieves the first failed transaction plan result from a transaction plan result tree.\n *\n * This function searches the transaction plan result tree using a depth-first traversal\n * and returns the first single transaction result with a 'failed' status. If no failed\n * result is found, it throws a {@link SolanaError}.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @return The first failed single transaction plan result.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND` if no\n * failed transaction plan result is found. The error context contains a non-enumerable\n * `transactionPlanResult` property for recovery purposes.\n *\n * @example\n * Retrieving the first failed result from a parallel execution.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n *   failedSingleTransactionPlanResult(messageC, anotherError),\n * ]);\n *\n * const firstFailed = getFirstFailedSingleTransactionPlanResult(result);\n * // Returns the failed result for messageB.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n */\nexport function getFirstFailedSingleTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n): FailedSingleTransactionPlanResult {\n    const result = findTransactionPlanResult(\n        transactionPlanResult,\n        r => r.kind === 'single' && r.status.kind === 'failed',\n    );\n\n    if (!result) {\n        // Here we want the `transactionPlanResult` to be available in the error context\n        // so applications can recover but we don't want this object to be\n        // serialized with the error. This is why we set it as a non-enumerable property.\n        const context = {};\n        Object.defineProperty(context, 'transactionPlanResult', {\n            configurable: false,\n            enumerable: false,\n            value: transactionPlanResult,\n            writable: false,\n        });\n        throw new SolanaError(\n            SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n            context,\n        );\n    }\n\n    return result as FailedSingleTransactionPlanResult;\n}\n\n/**\n * Checks if every transaction plan result in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan result tree,\n * returning `true` only if the predicate returns `true` for every result in the tree\n * (including the root result and all nested results).\n *\n * @param transactionPlanResult - The transaction plan result tree to check.\n * @param predicate - A function that returns `true` if the result satisfies the condition.\n * @return `true` if every result in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all transactions were successful.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * const allSuccessful = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind === 'successful',\n * );\n * // Returns true because all single results are successful.\n * ```\n *\n * @example\n * Checking if no transactions were canceled.\n * ```ts\n * const result = sequentialTransactionPlanResult([resultA, resultB, resultC]);\n *\n * const noCanceled = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind !== 'canceled',\n * );\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function everyTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    predicate: (plan: TransactionPlanResult) => boolean,\n): boolean {\n    if (!predicate(transactionPlanResult)) {\n        return false;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return true;\n    }\n    return transactionPlanResult.plans.every(p => everyTransactionPlanResult(p, predicate));\n}\n\n/**\n * Transforms a transaction plan result tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan result tree, applying the\n * transformation function to each result. The transformation is applied bottom-up,\n * meaning nested results are transformed first, then the parent results receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed results are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlanResult - The transaction plan result tree to transform.\n * @param fn - A function that transforms each result and returns a new result.\n * @return A new transformed transaction plan result tree.\n *\n * @example\n * Converting all canceled results to failed results.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   canceledSingleTransactionPlanResult(messageB),\n * ]);\n *\n * const transformed = transformTransactionPlanResult(result, (r) => {\n *   if (r.kind === 'single' && r.status.kind === 'canceled') {\n *     return failedSingleTransactionPlanResult(r.message, new Error('Execution canceled'));\n *   }\n *   return r;\n * });\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function transformTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    fn: (plan: TransactionPlanResult) => TransactionPlanResult,\n): TransactionPlanResult {\n    if (transactionPlanResult.kind === 'single') {\n        return Object.freeze(fn(transactionPlanResult));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlanResult,\n                plans: transactionPlanResult.plans.map(p => transformTransactionPlanResult(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlanResult} instances from a transaction plan result tree.\n *\n * This function recursively traverses any nested structure of transaction plan results and extracts\n * all the single results they contain. It's useful when you need to access all the individual\n * transaction results, regardless of their organization in the result tree (parallel or sequential).\n *\n * @param result - The transaction plan result to extract single results from\n * @returns An array of all single transaction plan results contained in the tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   sequentialTransactionPlanResult([resultA, resultB]),\n *   nonDivisibleSequentialTransactionPlanResult([resultC, resultD]),\n *   resultE,\n * ]);\n *\n * const singleResults = flattenTransactionPlanResult(result);\n * // Array of `SingleTransactionPlanResult` containing:\n * // resultA, resultB, resultC, resultD and resultE.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n */\nexport function flattenTransactionPlanResult(result: TransactionPlanResult): SingleTransactionPlanResult[] {\n    if (result.kind === 'single') {\n        return [result];\n    }\n    return result.plans.flatMap(flattenTransactionPlanResult);\n}\n\n/**\n * A {@link SingleTransactionPlanResult} with 'successful' status.\n */\nexport type SuccessfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = SingleTransactionPlanResult<TContext> & { status: { kind: 'successful' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'failed' status.\n */\nexport type FailedSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'failed' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'canceled' status.\n */\nexport type CanceledSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'canceled' } };\n\n/**\n * A summary of a {@link TransactionPlanResult}, categorizing transactions by their execution status.\n * - `successful`: Indicates whether all transactions were successful (i.e., no failed or canceled transactions).\n * - `successfulTransactions`: An array of successful transactions, each including its signature.\n * - `failedTransactions`: An array of failed transactions, each including the error that caused the failure.\n * - `canceledTransactions`: An array of canceled transactions.\n */\nexport type TransactionPlanResultSummary = Readonly<{\n    canceledTransactions: CanceledSingleTransactionPlanResult[];\n    failedTransactions: FailedSingleTransactionPlanResult[];\n    successful: boolean;\n    successfulTransactions: SuccessfulSingleTransactionPlanResult[];\n}>;\n\n/**\n * Summarize a {@link TransactionPlanResult} into a {@link TransactionPlanResultSummary}.\n * @param result The transaction plan result to summarize\n * @returns A summary of the transaction plan result\n */\nexport function summarizeTransactionPlanResult(result: TransactionPlanResult): TransactionPlanResultSummary {\n    const successfulTransactions: TransactionPlanResultSummary['successfulTransactions'] = [];\n    const failedTransactions: TransactionPlanResultSummary['failedTransactions'] = [];\n    const canceledTransactions: TransactionPlanResultSummary['canceledTransactions'] = [];\n\n    const flattenedResults = flattenTransactionPlanResult(result);\n\n    for (const singleResult of flattenedResults) {\n        switch (singleResult.status.kind) {\n            case 'successful': {\n                successfulTransactions.push(singleResult as SuccessfulSingleTransactionPlanResult);\n                break;\n            }\n            case 'failed': {\n                failedTransactions.push(singleResult as FailedSingleTransactionPlanResult);\n                break;\n            }\n            case 'canceled': {\n                canceledTransactions.push(singleResult as CanceledSingleTransactionPlanResult);\n                break;\n            }\n        }\n    }\n\n    return Object.freeze({\n        canceledTransactions,\n        failedTransactions,\n        successful: failedTransactions.length === 0 && canceledTransactions.length === 0,\n        successfulTransactions,\n    });\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { getAbortablePromise } from '@solana/promises';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    SingleTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    successfulSingleTransactionPlanResultFromSignature,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\n/**\n * Executes a transaction plan and returns the execution results.\n *\n * This function traverses the transaction plan tree, executing each transaction\n * message and collecting results that mirror the structure of the original plan.\n *\n * @typeParam TContext - The type of the context object that may be passed along with successful results.\n * @param transactionPlan - The transaction plan to execute.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel execution.\n * @return A promise that resolves to the execution results.\n *\n * @see {@link TransactionPlan}\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteResult<TContext extends TransactionPlanResultContext> = {\n    context?: TContext;\n} & ({ signature: Signature } | { transaction: Transaction });\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<ExecuteResult<TContext>>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @param config - Configuration object containing the transaction message executor function.\n * @return A {@link TransactionPlanExecutor} function that can execute transaction plans.\n *\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n *   if any transaction in the plan fails to execute. The error context contains a\n *   `transactionPlanResult` property with the partial results up to the point of failure.\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED}\n *   if the transaction plan contains non-divisible sequential plans, which are not\n *   supported by this executor.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: async (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlanExecutorConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        // Fail early if there are non-divisible sequential plans in the\n        // transaction plan as they are not supported by this executor.\n        assertDivisibleSequentialPlansOnly(plan);\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (!transactionPlan.divisible) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n    }\n\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return sequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        if ('transaction' in result) {\n            return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n        } else {\n            return successfulSingleTransactionPlanResultFromSignature(\n                transactionPlan.message,\n                result.signature,\n                result.context,\n            );\n        }\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as Error);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): Error | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n\nfunction assertDivisibleSequentialPlansOnly(transactionPlan: TransactionPlan): void {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            if (!transactionPlan.divisible) {\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n            }\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'parallel':\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'single':\n        default:\n            return;\n    }\n}\n\n/**\n * Wraps a transaction plan execution promise to return a\n * {@link TransactionPlanResult} even on execution failure.\n *\n * When a transaction plan executor throws a\n * {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n * error, this helper catches it and returns the `TransactionPlanResult`\n * from the error context instead of throwing.\n *\n * This allows us to handle the result of an execution in a single unified way\n * instead of using try/catch and examine the `TransactionPlanResult` in both\n * success and failure cases.\n *\n * Any other errors are re-thrown as normal.\n *\n * @param promise - A promise returned by a transaction plan executor.\n * @return A promise that resolves to the transaction plan result, even if some transactions failed.\n *\n * @example\n * Handling failures using a single result object:\n * ```ts\n * const result = await passthroughFailedTransactionPlanExecution(\n *   transactionPlanExecutor(transactionPlan)\n * );\n *\n * const summary = summarizeTransactionPlanResult(result);\n * if (summary.successful) {\n *   console.log('All transactions executed successfully');\n * } else {\n *   console.log(`${summary.successfulTransactions.length} succeeded`);\n *   console.log(`${summary.failedTransactions.length} failed`);\n *   console.log(`${summary.canceledTransactions.length} canceled`);\n * }\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n * @see {@link summarizeTransactionPlanResult}\n */\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<SingleTransactionPlanResult>,\n): Promise<SingleTransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult> {\n    try {\n        return await promise;\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN)) {\n            return error.context.transactionPlanResult as TransactionPlanResult;\n        }\n        throw error;\n    }\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    flattenTransactionPlan,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated  e.g. new instructions were added.\n     * This function must return the updated transaction message back  even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: TransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return flattenTransactionPlan(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<TransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: TransactionMessage & TransactionMessageWithFeePayer,\n): TransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: TransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(newMessage);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n","import { assertIsAddress, isAddress } from '@solana/addresses';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * A 32-byte array identifying the application requesting off-chain message signing.\n *\n * This may be any arbitrary bytes. For instance the on-chain address of a program, DAO instance,\n * Candy Machine, et cetera.\n *\n * This field SHOULD be displayed to users as a base58-encoded ASCII string rather than interpreted\n * otherwise.\n */\nexport type OffchainMessageApplicationDomain = Brand<\n    EncodedString<string, 'base58'>,\n    'OffchainMessageApplicationDomain'\n>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the\n * {@link OffchainMessageApplicationDomain} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * if (isOffchainMessageApplicationDomain(applicationDomain)) {\n *     // At this point, `applicationDomain` has been refined to an\n *     // `OffchainMessageApplcationDomain` that can be used to craft a message.\n *     const offchainMessage: OffchainMessageV0 = {\n *         applicationDomain:\n *             offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *     };\n * } else {\n *     setError(`${applicationDomain} is not a valid application domain for an offchain message`);\n * }\n * ```\n */\nexport function isOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): putativeApplicationDomain is OffchainMessageApplicationDomain {\n    return isAddress(putativeApplicationDomain);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an offchain message\n * application domain, from an untrusted network API or user input. Use this function to assert that\n * such an arbitrary string is a base58-encoded application domain.\n *\n * @example\n * ```ts\n * import { assertIsOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * // Imagine a function that determines whether an application domain is valid.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const applicationDomain: string = applicationDomainInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `applicationDomain` to `OffchainMessageApplicationDomain`.\n *         assertIsOffchainMessageApplicationDomain(applicationDomain);\n *         // At this point, `applicationDomain` is a `OffchainMessageApplicationDomain` that can be\n *         // used to craft an offchain message.\n *         const offchainMessage: OffchainMessageV0 = {\n *             applicationDomain:\n *                 offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `applicationDomain` turned out not to be a base58-encoded application domain\n *     }\n * }\n * ```\n */\nexport function assertIsOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): asserts putativeApplicationDomain is OffchainMessageApplicationDomain {\n    try {\n        assertIsAddress(putativeApplicationDomain);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n                error.context,\n            );\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n                error.context,\n            );\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an offchain message application domain with _coercing_ it\n * to the {@link OffchainMessageApplicationDomain} type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * const offchainMessage: OffchainMessageV0 = {\n *     applicationDomain:\n *         offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *     // ...\n * };\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good application domain as a string, it's more efficient to typecast\n * > it rather than to use the {@link offchainMessageApplicationDomain} helper, because the helper\n * > unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageApplicationDomain } from '@solana/offchain-messages';\n * >\n * > const applicationDomain =\n * >     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * > ```\n */\nexport function offchainMessageApplicationDomain(putativeApplicationDomain: string): OffchainMessageApplicationDomain {\n    assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);\n    return putativeApplicationDomain;\n}\n","import { Address, getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformEncoder,\n} from '@solana/codecs-core';\n\nimport { OffchainMessageApplicationDomain, offchainMessageApplicationDomain } from '../application-domain';\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded offchain message application\n * domain to a byte array.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainEncoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomain =\n *     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * const offchainMessageApplicationDomainEncoder = getOffchainMessageApplicationDomainEncoder();\n * const offchainMessageApplicationDomainBytes =\n *     offchainMessageApplicationDomainEncoder.encode(offchainMessageApplicationDomain);\n * // Uint8Array(32) [\n * //   247, 203,  28,  80,  52, 240, 169,  19,\n * //    21, 103, 107, 119,  91, 235,  13,  48,\n * //   194, 169, 148, 160,  78, 105, 235,  37,\n * //   232, 160,  49,  47,  64,  89,  18, 153,\n * // ]\n * ```\n */\nexport function getOffchainMessageApplicationDomainEncoder(): FixedSizeEncoder<OffchainMessageApplicationDomain, 32> {\n    return transformEncoder(\n        getAddressEncoder(),\n        putativeApplicationDomain => offchainMessageApplicationDomain(putativeApplicationDomain) as string as Address,\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an offchain\n * message application domain to the base58-encoded representation of that application domain.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomainBytes = new Uint8Array([\n *     247, 203,  28,  80,  52, 240, 169,  19,\n *      21, 103, 107, 119,  91, 235,  13,  48,\n *     194, 169, 148, 160,  78, 105, 235,  37,\n *     232, 160,  49,  47,  64,  89,  18, 153,\n * ]);\n * const offchainMessageApplicationDomainDecoder = getOffchainMessageApplicationDomainDecoder();\n * const offchainMessageApplicationDomain =\n *     offchainMessageApplicationDomainDecoder.decode(offchainMessageApplicationDomainBytes);\n *     // HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx\n * ```\n */\nexport function getOffchainMessageApplicationDomainDecoder(): FixedSizeDecoder<OffchainMessageApplicationDomain, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<\n        OffchainMessageApplicationDomain,\n        32\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded offchain message\n * application domain.\n *\n * @see {@link getOffchainMessageApplicationDomainDecoder}\n * @see {@link getOffchainMessageApplicationDomainEncoder}\n */\nexport function getOffchainMessageApplicationDomainCodec(): FixedSizeCodec<\n    OffchainMessageApplicationDomain,\n    OffchainMessageApplicationDomain,\n    32\n> {\n    return combineCodec(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getConstantDecoder, getConstantEncoder } from '@solana/codecs-data-structures';\n\n// The string `'\\xffsolana offchain'`\nconst OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES: ReadonlyUint8Array = new Uint8Array([\n    0xff, 0x73, 0x6f, 0x6c, 0x61, 0x6e, 0x61, 0x20, 0x6f, 0x66, 0x66, 0x63, 0x68, 0x61, 0x69, 0x6e,\n]);\n\nexport function getOffchainMessageSigningDomainDecoder(): FixedSizeDecoder<void, 16> {\n    return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeDecoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainEncoder(): FixedSizeEncoder<void, 16> {\n    return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeEncoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainCodec(): FixedSizeCodec<void, void, 16> {\n    return combineCodec(getOffchainMessageSigningDomainEncoder(), getOffchainMessageSigningDomainDecoder());\n}\n","import { Address, getAddressDecoder } from '@solana/addresses';\nimport {\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    offsetDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getHiddenPrefixDecoder,\n    getHiddenPrefixEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageVersion } from '../version';\nimport { getOffchainMessageSigningDomainDecoder, getOffchainMessageSigningDomainEncoder } from './signing-domain';\n\ntype TDecoderFields = Parameters<typeof getStructDecoder>[0];\ntype TEncoderFields = Parameters<typeof getStructEncoder>[0];\n\nfunction getSigningDomainPrefixedDecoder<const T extends TDecoderFields>(...fields: T) {\n    return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);\n}\n\nfunction getSigningDomainPrefixedEncoder<const T extends TEncoderFields>(...fields: T) {\n    return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);\n}\n\nfunction getVersionTransformer(fixedVersion?: OffchainMessageVersion) {\n    return (version: number) => {\n        if (version > 1) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                unsupportedVersion: version,\n            });\n        }\n        if (fixedVersion != null && version !== fixedVersion) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {\n                actualVersion: version,\n                expectedVersion: fixedVersion,\n            });\n        }\n        return version;\n    };\n}\n\nexport function createOffchainMessagePreambleDecoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TDecoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer(version)) as FixedSizeDecoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function createOffchainMessagePreambleEncoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TEncoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedEncoder(\n        ['version', transformEncoder(getU8Encoder(), getVersionTransformer(version)) as FixedSizeEncoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function decodeRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer())],\n        ['bytesAfterVersion', getBytesDecoder()],\n    ).decode(bytes);\n    return offsetDecoder(\n        transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n            if (signatoryAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses;\n        }),\n        {\n            preOffset: ({ preOffset }) =>\n                preOffset +\n                (version === 0\n                    ? 32 + 1 // skip the application domain and message format of v0 messages\n                    : 0),\n        },\n    ).decode(bytesAfterVersion);\n}\n\nexport function getSignatoriesComparator(): (a: ReadonlyUint8Array, b: ReadonlyUint8Array) => -1 | 0 | 1 {\n    return (x, y) => {\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for (let ii = 0; ii < x.length; ii++) {\n            if (x[ii] === y[ii]) {\n                continue;\n            } else {\n                return x[ii] < y[ii] ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\n\nfunction getSignaturesToEncode(signaturesMap: OffchainMessageEnvelope['signatures']): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<OffchainMessageEnvelope['signatures']> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getU8Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { Address, address } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\nimport { OffchainMessageBytes } from '../message';\nimport { decodeRequiredSignatoryAddresses } from './preamble-common';\nimport { getSignaturesEncoder } from './signatures';\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageEnvelope} to a byte array\n * appropriate for sharing with a third party for validation.\n */\nexport function getOffchainMessageEnvelopeEncoder(): VariableSizeEncoder<OffchainMessageEnvelope> {\n    return transformEncoder(\n        getStructEncoder([\n            ['signatures', getSignaturesEncoder()],\n            ['content', getBytesEncoder()],\n        ]),\n        envelope => {\n            const signaturesMapAddresses = Object.keys(envelope.signatures).map(address);\n            if (signaturesMapAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n            }\n            const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);\n            const missingRequiredSigners = [];\n            const unexpectedSigners = [];\n            for (const address of signatoryAddresses) {\n                if (!signaturesMapAddresses.includes(address)) {\n                    missingRequiredSigners.push(address);\n                }\n            }\n            for (const address of signaturesMapAddresses) {\n                if (!signatoryAddresses.includes(address)) {\n                    unexpectedSigners.push(address);\n                }\n            }\n            if (missingRequiredSigners.length || unexpectedSigners.length) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {\n                    missingRequiredSigners,\n                    unexpectedSigners,\n                });\n            }\n            const orderedSignatureMap: OffchainMessageEnvelope['signatures'] = {};\n            for (const address of signatoryAddresses) {\n                orderedSignatureMap[address] = envelope.signatures[address];\n            }\n            return {\n                ...envelope,\n                signatures: orderedSignatureMap,\n            };\n        },\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana offchain message format\n * to a {@link OffchainMessageEnvelope} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageEnvelopeDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelopeDecoder = getOffchainMessageEnvelopeDecoder();\n * const offchainMessageEnvelope = offchainMessageEnvelopeDecoder.decode(offchainMessageEnvelopeBytes);\n * for (const [address, signature] in Object.entries(offchainMessageEnvelope.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\nexport function getOffchainMessageEnvelopeDecoder(): VariableSizeDecoder<OffchainMessageEnvelope> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getU8Decoder() })],\n            ['content', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedOffchainMessageEnvelope,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageEnvelope}\n *\n * @see {@link getOffchainMessageEnvelopeDecoder}\n * @see {@link getOffchainMessageEnvelopeEncoder}\n */\nexport function getOffchainMessageEnvelopeCodec() {\n    return combineCodec(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());\n}\n\ntype PartiallyDecodedOffchainMessageEnvelope = {\n    content: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedOffchainMessageEnvelope(\n    offchainMessageEnvelope: PartiallyDecodedOffchainMessageEnvelope,\n): OffchainMessageEnvelope {\n    const { content, signatures } = offchainMessageEnvelope;\n\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);\n\n    // Signer addresses and signatures must be the same length\n    // We encode an all-zero signature when the signature is missing\n    if (signatoryAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: signatoryAddresses.length,\n            signatoryAddresses,\n            signaturesLength: signatures.length,\n        });\n    }\n\n    // Combine the signer addresses + signatures into the signatures map\n    const signaturesMap: OffchainMessageEnvelope['signatures'] = {};\n    signatoryAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return Object.freeze({\n        content: content as OffchainMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    });\n}\n\nfunction decodeAndValidateRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);\n\n    if (signatoryAddresses.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n    }\n\n    return signatoryAddresses;\n}\n","import { getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nconst MAX_BODY_BYTES =\n    // Largest 16-bit unsigned integer\n    0xffff;\nconst MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE =\n    // Space remaining in the mininum IPv6 MTU after network header overhead\n    1232;\n\n/**\n * A restriction on what characters the message text can contain and how long it can be.\n *\n * The aim of this restriction is to make a message more likely to be signable by a hardware wallet\n * that imposes limits on message size. In the case of wanting a message to be clear-signable,\n * restricting the character set to ASCII may ensure that certain models of hardware wallet without\n * extended character sets can display it onscreen.\n *\n * @remarks This only applies to v0 messages.\n */\nexport enum OffchainMessageContentFormat {\n    RESTRICTED_ASCII_1232_BYTES_MAX = 0,\n    UTF8_1232_BYTES_MAX = 1,\n    UTF8_65535_BYTES_MAX = 2,\n}\n\n/**\n * Describes message text that is no more than 1232 bytes long and made up of characters with ASCII\n * character codes in the range [0x20, 0x7e].\n *\n * @remarks This type aims to restrict text to that which can be clear-signed by hardware wallets\n * that can only display ASCII characters onscreen.\n */\nexport type OffchainMessageContentRestrictedAsciiOf1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentRestrictedAsciiOf1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 1232 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 65535 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of65535BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of65535BytesMax'>;\n}>;\n\nexport type OffchainMessageContent =\n    | OffchainMessageContentRestrictedAsciiOf1232BytesMax\n    | OffchainMessageContentUtf8Of1232BytesMax\n    | OffchainMessageContentUtf8Of65535BytesMax;\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (isTextRestrictedAscii(putativeContent.text) === false) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX ||\n        putativeContent.text.length === 0 ||\n        isTextRestrictedAscii(putativeContent.text) === false\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is restricted ASCII with\n * _coercing_ it to the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type. It's most\n * useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageContentRestrictedAsciiOf1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: offchainMessageContentRestrictedAsciiOf1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentRestrictedAsciiOf1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good ASCII content as a string, it's more efficient to typecast it\n * > rather than to use the {@link offchainMessageContentRestrictedAsciiOf1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n * >         text: 'Hello world',\n * >     } as OffchainMessageContentRestrictedAsciiOf1232BytesMax<'Hello world'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentRestrictedAsciiOf1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentRestrictedAsciiOf1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        });\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 1232 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of1232BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 1232 bytes, it's more efficient\n * > to typecast it rather than to use the {@link offchainMessageContentUtf8Of1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of1232BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of65535BytesMax}\n * type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of65535BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 65535 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of65535BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of65535BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of65535BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of65535BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 65535 bytes, it's more efficient\n * > to typecast it rather than to use the {@link OffchainMessageContentUtf8Of65535BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of65535BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of65535BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of65535BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);\n    return putativeContent;\n}\n\nfunction isTextRestrictedAscii(putativeRestrictedAsciiString: string): boolean {\n    return /^[\\x20-\\x7e]+$/.test(putativeRestrictedAsciiString);\n}\n","import {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of65535BytesMax,\n    OffchainMessageContentFormat,\n    OffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    OffchainMessageContentUtf8Of1232BytesMax,\n    OffchainMessageContentUtf8Of65535BytesMax,\n} from './content';\nimport { OffchainMessagePreambleV0 } from './preamble-v0';\nimport { OffchainMessageWithRequiredSignatories } from './signatures';\n\nexport type BaseOffchainMessageV0 = Omit<\n    OffchainMessagePreambleV0,\n    'messageFormat' | 'messageLength' | 'requiredSignatories'\n>;\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax}\n */\nexport interface OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent {\n    readonly content: OffchainMessageContentRestrictedAsciiOf1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link offchainMessageContentUtf8Of1232BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of1232BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentUtf8Of65535BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of65535BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of65535BytesMax;\n}\n\n/**\n * A union of the formats a v0 message's contents can take.\n *\n * @remarks From v1 and onward, an offchain message has only one format: UTF-8 text of arbitrary\n * length.\n */\nexport type OffchainMessageWithContent =\n    | OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent\n    | OffchainMessageWithUtf8Of1232BytesMaxContent\n    | OffchainMessageWithUtf8Of65535BytesMaxContent;\n\nexport type OffchainMessageV0 = BaseOffchainMessageV0 &\n    OffchainMessageWithContent &\n    OffchainMessageWithRequiredSignatories;\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n        }>,\n): asserts putativeMessage is OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link offchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link offchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentUtf8Of65535BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of65535BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of65535BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getEnumDecoder, getEnumEncoder } from '@solana/codecs-data-structures';\n\nimport { OffchainMessageContentFormat } from '../content';\n\nexport function getOffchainMessageContentFormatDecoder(): FixedSizeDecoder<OffchainMessageContentFormat, 1> {\n    return getEnumDecoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatEncoder(): FixedSizeEncoder<OffchainMessageContentFormat, 1> {\n    return getEnumEncoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatCodec(): FixedSizeCodec<\n    OffchainMessageContentFormat,\n    OffchainMessageContentFormat,\n    1\n> {\n    return combineCodec(getOffchainMessageContentFormatEncoder(), getOffchainMessageContentFormatDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder, getU16Decoder, getU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\n\nimport { OffchainMessagePreambleV0 } from '../preamble-v0';\nimport {\n    getOffchainMessageApplicationDomainDecoder,\n    getOffchainMessageApplicationDomainEncoder,\n} from './application-domain';\nimport { getOffchainMessageContentFormatDecoder, getOffchainMessageContentFormatEncoder } from './content';\nimport { createOffchainMessagePreambleDecoder, createOffchainMessagePreambleEncoder } from './preamble-common';\n\nexport function getOffchainMessageV0PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleDecoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainDecoder()],\n        ['messageFormat', getOffchainMessageContentFormatDecoder()],\n        [\n            'requiredSignatories',\n            transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                return signatoryAddresses.map(address => Object.freeze({ address }));\n            }),\n        ],\n        ['messageLength', getU16Decoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleEncoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainEncoder()],\n        ['messageFormat', getOffchainMessageContentFormatEncoder()],\n        [\n            'requiredSignatories',\n            transformEncoder(\n                getArrayEncoder(getAddressEncoder(), { size: getU8Encoder() }),\n                (signatoryAddresses: OffchainMessagePreambleV0['requiredSignatories']) => {\n                    if (signatoryAddresses.length === 0) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                    }\n                    return signatoryAddresses.map(({ address }) => address);\n                },\n            ),\n        ],\n        ['messageLength', getU16Encoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV0> {\n    return combineCodec(getOffchainMessageV0PreambleEncoder(), getOffchainMessageV0PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageContentFormat } from '../content';\nimport {\n    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageUtf8Of1232BytesMax,\n    assertIsOffchainMessageUtf8Of65535BytesMax,\n    OffchainMessageV0,\n} from '../message-v0';\nimport { getOffchainMessageV0PreambleDecoder, getOffchainMessageV0PreambleEncoder } from './preamble-v0';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV0} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV0Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV0Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v0 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 0.\n */\nexport function getOffchainMessageV0Decoder(): VariableSizeDecoder<OffchainMessageV0> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]),\n        ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {\n            const actualLength = getUtf8Encoder().getSizeFromValue(text);\n            if (messageLength !== actualLength) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {\n                    actualLength: actualLength,\n                    specifiedLength: messageLength,\n                });\n            }\n            const offchainMessage: Omit<OffchainMessageV0, 'content'> &\n                Readonly<{\n                    content: {\n                        format: OffchainMessageContentFormat;\n                        text: string;\n                    };\n                }> = Object.freeze({\n                ...preambleRest,\n                content: Object.freeze({\n                    format: messageFormat,\n                    text,\n                }),\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n            switch (messageFormat) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: messageFormat satisfies never,\n                    });\n                }\n            }\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV0} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV0Encoder(): VariableSizeEncoder<OffchainMessageV0> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...preamble } = offchainMessage;\n            switch (offchainMessage.content.format) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    break;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: offchainMessage.content satisfies never,\n                    });\n                }\n            }\n            const messageLength = getUtf8Encoder().getSizeFromValue(content.text);\n            const compiledPreamble = {\n                ...preamble,\n                messageFormat: content.format,\n                messageLength,\n            };\n            return [compiledPreamble, content.text] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV0}\n *\n * @see {@link getOffchainMessageV0Decoder}\n * @see {@link getOffchainMessageV0Encoder}\n */\nexport function getOffchainMessageV0Codec(): VariableSizeCodec<OffchainMessageV0> {\n    return combineCodec(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessagePreambleV1 } from '../preamble-v1';\nimport {\n    createOffchainMessagePreambleDecoder,\n    createOffchainMessagePreambleEncoder,\n    getSignatoriesComparator,\n} from './preamble-common';\n\nexport function getOffchainMessageV1PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleDecoder(/* version */ 1, [\n        'requiredSignatories',\n        transformDecoder(\n            getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: getU8Decoder() }),\n            signatoryAddressesBytes => {\n                if (signatoryAddressesBytes.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const comparator = getSignatoriesComparator();\n                for (let ii = 0; ii < signatoryAddressesBytes.length - 1; ii++) {\n                    switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {\n                        case 0:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                        case 1:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);\n                    }\n                }\n                const addressDecoder = getAddressDecoder();\n                return signatoryAddressesBytes.map(addressBytes =>\n                    Object.freeze({\n                        address: addressDecoder.decode(addressBytes),\n                    }),\n                );\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleEncoder(/* version */ 1, [\n        'requiredSignatories',\n        transformEncoder(\n            transformEncoder(\n                getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }),\n                (signatoryAddressesBytes: readonly ReadonlyUint8Array[]) => {\n                    return signatoryAddressesBytes.toSorted(getSignatoriesComparator());\n                },\n            ),\n            (signatoryAddresses: OffchainMessagePreambleV1['requiredSignatories']) => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const seenSignatories = new Set();\n                for (const { address } of signatoryAddresses) {\n                    if (seenSignatories.has(address)) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                    }\n                    seenSignatories.add(address);\n                }\n                const addressEncoder = getAddressEncoder();\n                return signatoryAddresses.map(({ address }) => addressEncoder.encode(address));\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV1> {\n    return combineCodec(getOffchainMessageV1PreambleEncoder(), getOffchainMessageV1PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY, SolanaError } from '@solana/errors';\n\nimport { OffchainMessageV1 } from '../message-v1';\nimport { getOffchainMessageV1PreambleDecoder, getOffchainMessageV1PreambleEncoder } from './preamble-v1';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV1} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV1Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV1Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v1 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 1.\n */\nexport function getOffchainMessageV1Decoder(): VariableSizeDecoder<OffchainMessageV1> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]),\n        ([{ requiredSignatories, ...preambleRest }, text]) => {\n            if (text.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return Object.freeze({\n                ...preambleRest,\n                content: text,\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV1} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV1Encoder(): VariableSizeEncoder<OffchainMessageV1> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...compiledPreamble } = offchainMessage;\n            if (content.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return [compiledPreamble, content] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV1}\n *\n * @see {@link getOffchainMessageV1Decoder}\n * @see {@link getOffchainMessageV1Encoder}\n */\nexport function getOffchainMessageV1Codec(): VariableSizeCodec<OffchainMessageV1> {\n    return combineCodec(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getHiddenPrefixDecoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, SolanaError } from '@solana/errors';\n\nimport { OffchainMessage } from '../message';\nimport { getOffchainMessageV0Decoder, getOffchainMessageV0Encoder } from './message-v0';\nimport { getOffchainMessageV1Decoder, getOffchainMessageV1Encoder } from './message-v1';\nimport { getOffchainMessageSigningDomainDecoder } from './signing-domain';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessage} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageDecoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded an offchain message (version: ${offchainMessage.version}`);\n * ```\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the decoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageDecoder(): VariableSizeDecoder<OffchainMessage> {\n    return createDecoder({\n        read(bytes, offset): [OffchainMessage, number] {\n            const version = getHiddenPrefixDecoder(getU8Decoder(), [\n                // Discard the signing domain\n                getOffchainMessageSigningDomainDecoder(),\n            ]).decode(bytes, offset);\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Decoder().read(bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Decoder().read(bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessage} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the encoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageEncoder(): VariableSizeEncoder<OffchainMessage> {\n    return createEncoder({\n        getSizeFromValue: offchainMessage => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);\n                case 1:\n                    return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n        write: (offchainMessage, bytes, offset) => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessage}\n *\n * @see {@link getOffchainMessageDecoder}\n * @see {@link getOffchainMessageEncoder}\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the codecs specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageCodec(): VariableSizeCodec<OffchainMessage> {\n    return combineCodec(getOffchainMessageEncoder(), getOffchainMessageDecoder());\n}\n","import { VariableSizeEncoder } from '@solana/codecs-core';\n\nimport { OffchainMessageEnvelope } from './envelope';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\nexport function compileOffchainMessageEnvelopeUsingEncoder<T extends OffchainMessage>(\n    offchainMessage: T,\n    encoder: VariableSizeEncoder<T>,\n) {\n    const offchainMessageBytes = encoder.encode(offchainMessage) as OffchainMessageBytes;\n    const signatures: OffchainMessageEnvelope['signatures'] = {};\n    for (const { address } of offchainMessage.requiredSignatories) {\n        signatures[address] = null;\n    }\n    return Object.freeze({\n        content: offchainMessageBytes,\n        signatures: Object.freeze(signatures),\n    });\n}\n","import { getOffchainMessageV0Encoder } from './codecs/message-v0';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV0 } from './message-v0';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV0}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV0Envelope(offchainMessage: OffchainMessageV0): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());\n}\n","import { getOffchainMessageV1Encoder } from './codecs/message-v1';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV1 } from './message-v1';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV1}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV1Envelope(offchainMessage: OffchainMessageV1): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { compileOffchainMessageV0Envelope } from './envelope-v0';\nimport { compileOffchainMessageV1Envelope } from './envelope-v1';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\ntype OrderedMap<K extends string, V> = Record<K, V>;\ntype OffchainMessageSignaturesMap = OrderedMap<Address, SignatureBytes | null>;\n\nexport interface OffchainMessageEnvelope {\n    /** The bytes of the combined offchain message preamble and content */\n    readonly content: OffchainMessageBytes;\n    /**\n     * A map between the addresses of an offchain message's signers, and the 64-byte Ed25519\n     * signature of the combined message preamble and message content by the private key associated\n     * with each.\n     */\n    readonly signatures: OffchainMessageSignaturesMap;\n}\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessage}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the compile functions\n * specific to that version so as not to bundle more code than you need.\n */\nexport function compileOffchainMessageEnvelope(offchainMessage: OffchainMessage): OffchainMessageEnvelope {\n    const { version } = offchainMessage;\n    switch (version) {\n        case 0:\n            return compileOffchainMessageV0Envelope(offchainMessage);\n        case 1:\n            return compileOffchainMessageV1Envelope(offchainMessage);\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: version satisfies never,\n            });\n    }\n}\n","import { Address, getAddressFromPublicKey, getPublicKeyFromAddress } from '@solana/addresses';\nimport { bytesEqual } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes, signBytes, verifySignature } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { decodeRequiredSignatoryAddresses } from './codecs/preamble-common';\nimport { OffchainMessageEnvelope } from './envelope';\n\n/**\n * Represents an offchain message envelope that is signed by all of its required signers.\n */\nexport type FullySignedOffchainMessageEnvelope = NominalType<'offchainMessageEnvelopeSignedness', 'fullySigned'>;\n\n/**\n * Represents an address that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatory<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n}>;\n\n/**\n * An offchain message having a list of accounts that must sign it in order for it to be valid.\n */\nexport interface OffchainMessageWithRequiredSignatories<\n    TSignatory extends OffchainMessageSignatory = OffchainMessageSignatory,\n> {\n    requiredSignatories: readonly TSignatory[];\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message, this method will return a new signed offchain message\n * envelope of type {@link OffchainMessageEnvelope}.\n *\n * Though the resulting message might be signed by all required signers, this function will not\n * assert that it is. A partially signed message is not complete, but can be serialized and\n * deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const partiallySignedOffchainMessage = await partiallySignOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link signOffchainMessageEnvelope} if you want to assert that the message is signed by all\n * its required signers after signing.\n */\nexport async function partiallySignOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<TOffchainMessageEnvelope> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n\n            // Check if the address is expected to sign the message\n            if (!requiredSignatoryAddresses.includes(address)) {\n                // address is not an expected signer for this message\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const existingSignature = offchainMessageEnvelope.signatures[address];\n            const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);\n\n            if (existingSignature != null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {\n            expectedAddresses: requiredSignatoryAddresses,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return offchainMessageEnvelope;\n    }\n\n    return Object.freeze({\n        ...offchainMessageEnvelope,\n        signatures: Object.freeze({\n            ...offchainMessageEnvelope.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message envelope, this method will return a new signed envelope of\n * type {@link FullySignedOffchainMessageEnvelope}.\n *\n * This function will throw unless the resulting message is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const signedOffchainMessage = await signOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link partiallySignOffchainMessageEnvelope} if you want to sign the message without\n * asserting that the resulting message envelope is fully signed.\n */\nexport async function signOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<FullySignedOffchainMessageEnvelope & TOffchainMessageEnvelope> {\n    const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);\n    assertIsFullySignedOffchainMessageEnvelope(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * A type guard that returns `true` if the input {@link OffchainMessageEnvelope} is fully signed,\n * and refines its type for use in your program, adding the\n * {@link FullySignedOffchainMessageEnvelope} type.\n *\n * @example\n * ```ts\n * import { isFullySignedOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * if (isFullySignedOffchainMessageEnvelope(offchainMessageEnvelope)) {\n *   // At this point we know that the offchain message is fully signed.\n * }\n * ```\n */\nexport function isFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    return Object.entries(offchainMessage.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link OffchainMessageEnvelope}, that you expect to be\n * fully signed, from an untrusted network API or user input. Use this function to assert that such\n * an offchain message is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedOffchainMessage } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast\n *     // `offchainMessageEnvelope` to `FullySignedOffchainMessageEnvelope`.\n *     assertIsFullySignedOffchainMessageEnvelope(offchainMessage);\n *     // At this point we know that the offchain message is signed by all required signers.\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function assertIsFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): asserts offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    const missingSigs: Address[] = [];\n    Object.entries(offchainMessage.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n\n/**\n * Asserts that there are signatures present for all of an offchain message's required signatories,\n * and that those signatures are valid given the message.\n *\n * @example\n * ```ts\n * import { isSolanaError, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE } from '@solana/errors';\n * import { verifyOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * try {\n *     await verifyOffchainMessageEnvelope(offchainMessageEnvelope);\n *     // At this point the message is valid and signed by all of the required signatories.\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE)) {\n *         if (e.context.signatoriesWithMissingSignatures.length) {\n *             console.error(\n *                 'Missing signatures for the following addresses',\n *                 e.context.signatoriesWithMissingSignatures,\n *             );\n *         }\n *         if (e.context.signatoriesWithInvalidSignatures.length) {\n *             console.error(\n *                 'Signatures for the following addresses are invalid',\n *                 e.context.signatoriesWithInvalidSignatures,\n *             );\n *         }\n *     }\n *     throw e;\n * }\n */\nexport async function verifyOffchainMessageEnvelope(offchainMessageEnvelope: OffchainMessageEnvelope): Promise<void> {\n    let errorContext;\n    const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(\n        requiredSignatories.map(async address => {\n            const signature = offchainMessageEnvelope.signatures[address];\n            if (signature == null) {\n                errorContext ||= {};\n                errorContext.signatoriesWithMissingSignatures ||= [];\n                errorContext.signatoriesWithMissingSignatures.push(address);\n            } else {\n                const publicKey = await getPublicKeyFromAddress(address);\n                if (await verifySignature(publicKey, signature, offchainMessageEnvelope.content)) {\n                    return true;\n                } else {\n                    errorContext ||= {};\n                    errorContext.signatoriesWithInvalidSignatures ||= [];\n                    errorContext.signatoriesWithInvalidSignatures.push(address);\n                }\n            }\n        }),\n    );\n    if (errorContext) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);\n    }\n}\n","/**\n * Defines a plugin that transforms or extends a client with additional functionality.\n *\n * For instance, plugins may add RPC capabilities, wallet integration, transaction building,\n * or other features necessary for interacting with the Solana blockchain.\n *\n * Plugins are functions that take a client object as input and return a new client object\n * or a promise that resolves to a new client object. This allows for both synchronous\n * and asynchronous transformations and extensions of the client.\n *\n * Plugins are usually applied using the `use` method on a {@link Client} or {@link AsyncClient}\n * instance, which {@link createEmptyClient} provides as a starting point.\n *\n * @typeParam TInput - The input client object type that this plugin accepts.\n * @typeParam TOutput - The output type. Either a new client object or a promise resolving to one.\n *\n * @example Basic RPC plugin\n * Given an RPC endpoint, this plugin adds an `rpc` property to the client.\n *\n * ```ts\n * import { createEmptyClient, createSolanaRpc } from '@solana/kit';\n *\n * // Define a simple RPC plugin.\n * function rpcPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpc(endpoint) });\n * }\n *\n * // Use the plugin.\n * const client = createEmptyClient().use(rpcPlugin('https://api.mainnet-beta.solana.com'));\n * await client.rpc.getLatestBlockhash().send();\n * ```\n *\n * @example Async plugin that generates a payer wallet\n * The following plugin shows how to create an asynchronous plugin that generates a new keypair signer.\n *\n * ```ts\n * import { createEmptyClient, generateKeypairSigner } from '@solana/kit';\n *\n * // Define a plugin that generates a new keypair signer.\n * function generatedPayerPlugin() {\n *     return async <T extends object>(client: T) => ({...client, payer: await generateKeypairSigner() });\n * }\n *\n * // Use the plugin.\n * const client = await createEmptyClient().use(generatedPayerPlugin());\n * console.log(client.payer.address);\n * ```\n *\n * @example Plugins with input requirements\n * A plugin can specify required properties on the input client. The example below requires the\n * client to already have a `payer` signer attached to the client in order to perform an airdrop.\n *\n * ```ts\n * import { createEmptyClient, TransactionSigner, Lamports, lamports } from '@solana/kit';\n *\n * // Define a plugin that airdrops lamports to the payer set on the client.\n * function airdropPayerPlugin(lamports: Lamports) {\n *     return async <T extends { payer: TransactionSigner }>(client: T) => {\n *         await myAirdropFunction(client.payer, lamports);\n *         return client;\n *     };\n * }\n *\n * // Use the plugins.\n * const client = await createEmptyClient()\n *     .use(generatedPayerPlugin()) // This is required before using the airdrop plugin.\n *     .use(airdropPayerPlugin(lamports(1_000_000_000n)));\n * ```\n *\n * @example Chaining plugins\n * Multiple plugins  asynchronous or not  can be chained together to build up complex clients.\n * The example below demonstrates how to gradually build a client with multiple plugins.\n * Notice how, despite having multiple asynchronous plugins, we only need to `await` the final result.\n * This is because the `use` method on `AsyncClient` returns another `AsyncClient`, allowing for seamless chaining.\n *\n * ```ts\n * import { createEmptyClient, createSolanaRpc, createSolanaRpcSubscriptions, generateKeypairSigner } from '@solana/kit';\n *\n * // Define multiple plugins.\n * function rpcPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpc(endpoint) });\n * }\n * function rpcSubscriptionsPlugin(endpoint: string) {\n *     return <T extends object>(client: T) => ({...client, rpc: createSolanaRpcSubscriptions(endpoint) });\n * }\n * function generatedPayerPlugin() {\n *     return async <T extends object>(client: T) => ({...client, payer: await generateKeypairSigner() });\n * }\n * function generatedAuthorityPlugin() {\n *     return async <T extends object>(client: T) => ({...client, authority: await generateKeypairSigner() });\n * }\n *\n * // Chain plugins together.\n * const client = await createEmptyClient()\n *     .use(rpcPlugin('https://api.mainnet-beta.solana.com'))\n *     .use(rpcSubscriptionsPlugin('wss://api.mainnet-beta.solana.com'))\n *     .use(generatedPayerPlugin())\n *     .use(generatedAuthorityPlugin());\n * ```\n */\nexport type ClientPlugin<TInput extends object, TOutput extends Promise<object> | object> = (input: TInput) => TOutput;\n\n/**\n * A client that can be extended with plugins.\n *\n * The `Client` type represents a client object that can be built up through\n * the application of one or more plugins. It provides a `use` method to\n * apply plugins, either synchronously (returning a new `Client`) or\n * asynchronously (returning an {@link AsyncClient}).\n *\n * @typeParam TSelf - The current shape of the client object including all applied plugins.\n */\nexport type Client<TSelf extends object> = TSelf & {\n    /**\n     * Applies a plugin to extend or transform the client.\n     *\n     * @param plugin The plugin function to apply to this client.\n     * @returns Either a new `Client` (for sync plugins) or {@link AsyncClient} (for async plugins).\n     */\n    readonly use: <TOutput extends Promise<object> | object>(\n        plugin: ClientPlugin<TSelf, TOutput>,\n    ) => TOutput extends Promise<infer U> ? AsyncClient<U extends object ? U : never> : Client<TOutput>;\n};\n\n/**\n * An asynchronous wrapper that represents a promise of a client.\n *\n * The `AsyncClient` type is returned when an async plugin is applied to a client.\n * It behaves like a `Promise<Client<TSelf>>` but with an additional `use` method\n * that allows chaining more plugins before the promise resolves.\n *\n * This enables fluent chaining of both synchronous and asynchronous plugins\n * without having to await intermediate promises.\n *\n * @typeParam TSelf - The shape of the client object that this async client will resolve to.\n */\nexport type AsyncClient<TSelf extends object> = Promise<Client<TSelf>> & {\n    /**\n     * Applies a plugin to the client once it resolves.\n     *\n     * @param plugin The plugin function to apply to the resolved client.\n     * @returns A new `AsyncClient` representing the result of applying the plugin.\n     */\n    readonly use: <TOutput extends Promise<object> | object>(\n        plugin: ClientPlugin<TSelf, TOutput>,\n    ) => AsyncClient<TOutput extends Promise<infer U> ? (U extends object ? U : never) : TOutput>;\n};\n\n// TODO(loris): Add examples in this docblock using real plugins once they have been published.\n\n/**\n * Creates a new empty client that can be extended with plugins.\n *\n * This serves as an entry point for building Solana clients.\n * Start with an empty client and chain the `.use()` method\n * to apply plugins that add various functionalities such as RPC\n * connectivity, wallet integration, transaction building, and more.\n *\n * See {@link ClientPlugin} for detailed examples on creating and using plugins.\n *\n * @returns An empty client object with only the `use` method available.\n *\n * @example Basic client setup\n * ```ts\n * import { createEmptyClient } from '@solana/client';\n *\n * const client = createEmptyClient()\n *     .use(myRpcPlugin('https://api.mainnet-beta.solana.com'))\n *     .use(myWalletPlugin());\n * ```\n */\nexport function createEmptyClient(): Client<object> {\n    return addUse({});\n}\n\nfunction addUse<TSelf extends object>(value: TSelf): Client<TSelf> {\n    return Object.freeze({\n        ...value,\n        use<TOutput extends Promise<object> | object>(plugin: ClientPlugin<TSelf, TOutput>) {\n            const result = plugin(value);\n            return result instanceof Promise ? createAsyncClient(result) : addUse(result);\n        },\n    } as Client<TSelf>);\n}\n\nfunction createAsyncClient<TSelf extends object>(promise: Promise<TSelf>): AsyncClient<TSelf> {\n    return Object.freeze({\n        catch(onrejected) {\n            return promise.then(v => addUse(v)).catch(onrejected);\n        },\n        finally(onfinally) {\n            return promise.then(v => addUse(v)).finally(onfinally);\n        },\n        then(onfulfilled, onrejected) {\n            return promise.then(v => addUse(v)).then(onfulfilled, onrejected);\n        },\n        use<TOutput extends Promise<object> | object>(plugin: ClientPlugin<TSelf, TOutput>) {\n            return createAsyncClient(promise.then(plugin));\n        },\n    } as AsyncClient<TSelf>);\n}\n","import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n","/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\n/**\n * Returns a spec-compliant JSON RPC 2.0 message, given a method name and some params.\n *\n * Generates a new `id` on each call by incrementing a `bigint` and casting it to a string.\n */\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigInts(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n","import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcMethods`.\n *\n * Calling each method returns a {@link PendingRpcRequest | PendingRpcRequest<TResponse>} where\n * `TResponse` is that method's response type.\n */\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\n/**\n * Pending requests are the result of calling a supported method on a {@link Rpc} object. They\n * encapsulate all of the information necessary to make the request without actually making it.\n *\n * Calling the {@link PendingRpcRequest.send | `send(options)`} method on a\n * {@link PendingRpcRequest | PendingRpcRequest<TResponse>} will trigger the request and return a\n * promise for `TResponse`.\n */\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    /**\n     * An optional signal that you can supply when triggering a {@link PendingRpcRequest} that you\n     * might later need to abort.\n     */\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link Rpc} instance given a {@link RpcApi | RpcApi<TRpcMethods>} and a\n * {@link RpcTransport} capable of fulfilling them.\n */\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n","export function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n","import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n","import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\n/**\n * Returns a transformer that extracts the `result` field from the body of the RPC response.\n *\n * For instance, we go from `{ jsonrpc: '2.0', result: 'foo', id: 1 }` to `'foo'`.\n *\n * @example\n * ```ts\n * import { getResultResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getResultResponseTransformer();\n * ```\n */\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { innerInstructionsConfigs, jsonParsedAccountsConfigs } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n// Keypaths for simulateTransaction result that should remain as Number (not BigInt)\n// Note: These are relative to the error.data root, not result.value like in success responses\nfunction getSimulateTransactionAllowedNumericKeypaths(): readonly KeyPath[] {\n    return [\n        ['loadedAccountsDataSize'],\n        ...jsonParsedAccountsConfigs.map(c => ['accounts', KEYPATH_WILDCARD, ...c]),\n        ...innerInstructionsConfigs.map(c => ['innerInstructions', KEYPATH_WILDCARD, ...c]),\n    ];\n}\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return (json, request) => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            const { error } = jsonRpcResponse;\n\n            // Check if this is a sendTransaction preflight failure (error code -32002)\n            // These errors contain RpcSimulateTransactionResult in error.data which needs\n            // BigInt values downcast to Number for fields that should be numbers\n            const isSendTransactionPreflightFailure =\n                error &&\n                typeof error === 'object' &&\n                'code' in error &&\n                (error.code === -32002 || error.code === -32002n);\n\n            if (isSendTransactionPreflightFailure && 'data' in error && error.data) {\n                // Apply BigInt downcast transformation to error.data\n                const treeWalker = getTreeWalkerResponseTransformer(\n                    [getBigIntUpcastVisitor(getSimulateTransactionAllowedNumericKeypaths())],\n                    { keyPath: [] },\n                );\n                const transformedData = treeWalker(error.data, request);\n\n                // Reconstruct error with transformed data\n                const transformedError = { ...error, data: transformedData };\n                throw getSolanaErrorFromJsonRpcError(transformedError);\n            }\n\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n","/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ['value', 'loadedAccountsDataSize'],\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    // Similar to `Accept-Encoding`, we don't have a way to target TypeScript types depending on\n    // which platform you are authoring for. `Origin` is therefore omitted from the forbidden\n    // headers type, but is still a runtime error in dev mode when supplied in a browser context.\n    // | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n    __BROWSER__ ? { origin: true } : undefined,\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests  much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values  e.g. `u64` or `i64`  in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload),\n    });\n}\n","/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\n\nimport { DataPublisher } from './data-publisher';\n\ntype Config = Readonly<{\n    /**\n     * Triggering this abort signal will cause all iterators spawned from this iterator to return\n     * once they have published all queued messages.\n     */\n    abortSignal: AbortSignal;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones yielded through the iterators.\n     *\n     * Messages only begin to be queued after the first time an iterator begins to poll. Channel\n     * messages published before that time will be dropped.\n     */\n    dataChannelName: string;\n    // FIXME: It would be nice to be able to constrain the type of `dataPublisher` to one that\n    //        definitely supports the `dataChannelName` and `errorChannelName` channels, and\n    //        furthermore publishes `TData` on the `dataChannelName` channel. This is more difficult\n    //        than it should be: https://tsplay.dev/NlZelW\n    dataPublisher: DataPublisher;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones thrown through the iterators.\n     *\n     * Any new iterators created after the first error is encountered will reject with that error\n     * when polled.\n     */\n    errorChannelName: string;\n}>;\n\nconst enum PublishType {\n    DATA,\n    ERROR,\n}\n\ntype IteratorKey = symbol;\ntype IteratorState<TData> =\n    | {\n          __hasPolled: false;\n          publishQueue: (\n              | {\n                    __type: PublishType.DATA;\n                    data: TData;\n                }\n              | {\n                    __type: PublishType.ERROR;\n                    err: unknown;\n                }\n          )[];\n      }\n    | {\n          __hasPolled: true;\n          onData: (data: TData) => void;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n      };\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly \" +\n                  'aborted by the user'\n            : undefined,\n    );\n}\n\nconst UNINITIALIZED = Symbol();\n\n/**\n * Returns an `AsyncIterable` given a data publisher.\n *\n * The iterable will produce iterators that vend messages published to `dataChannelName` and will\n * throw the first time a message is published to `errorChannelName`. Triggering the abort signal\n * will cause all iterators spawned from this iterator to return once they have published all queued\n * messages.\n *\n * Things to note:\n *\n * - If a message is published over a channel before the `AsyncIterator` attached to it has polled\n *   for the next result, the message will be queued in memory.\n * - Messages only begin to be queued after the first time an iterator begins to poll. Channel\n *   messages published before that time will be dropped.\n * - If there are messages in the queue and an error occurs, all queued messages will be vended to\n *   the iterator before the error is thrown.\n * - If there are messages in the queue and the abort signal fires, all queued messages will be\n *   vended to the iterator after which it will return.\n * - Any new iterators created after the first error is encountered will reject with that error when\n *   polled.\n *\n * @param config\n *\n * @example\n * ```ts\n * const iterable = createAsyncIterableFromDataPublisher({\n *     abortSignal: AbortSignal.timeout(10_000),\n *     dataChannelName: 'message',\n *     dataPublisher,\n *     errorChannelName: 'error',\n * });\n * try {\n *     for await (const message of iterable) {\n *         console.log('Got message', message);\n *     }\n * } catch (e) {\n *     console.error('An error was published to the error channel', e);\n * } finally {\n *     console.log(\"It's been 10 seconds; that's enough for now.\");\n * }\n * ```\n */\nexport function createAsyncIterableFromDataPublisher<TData>({\n    abortSignal,\n    dataChannelName,\n    dataPublisher,\n    errorChannelName,\n}: Config): AsyncIterable<TData> {\n    const iteratorState: Map<IteratorKey, IteratorState<TData>> = new Map();\n    function publishErrorToAllIterators(reason: unknown) {\n        for (const [iteratorKey, state] of iteratorState.entries()) {\n            if (state.__hasPolled) {\n                iteratorState.delete(iteratorKey);\n                state.onError(reason);\n            } else {\n                state.publishQueue.push({\n                    __type: PublishType.ERROR,\n                    err: reason,\n                });\n            }\n        }\n    }\n    const abortController = new AbortController();\n    abortSignal.addEventListener('abort', () => {\n        abortController.abort();\n        publishErrorToAllIterators((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n    });\n    const options = { signal: abortController.signal } as const;\n    let firstError: unknown = UNINITIALIZED;\n    dataPublisher.on(\n        errorChannelName,\n        err => {\n            if (firstError === UNINITIALIZED) {\n                firstError = err;\n                abortController.abort();\n                publishErrorToAllIterators(err);\n            }\n        },\n        options,\n    );\n    dataPublisher.on(\n        dataChannelName,\n        data => {\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onData } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n                    onData(data as TData);\n                } else {\n                    state.publishQueue.push({\n                        __type: PublishType.DATA,\n                        data: data as TData,\n                    });\n                }\n            });\n        },\n        options,\n    );\n    return {\n        async *[Symbol.asyncIterator]() {\n            if (abortSignal.aborted) {\n                return;\n            }\n            if (firstError !== UNINITIALIZED) {\n                throw firstError;\n            }\n            const iteratorKey = Symbol();\n            iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n            try {\n                while (true) {\n                    const state = iteratorState.get(iteratorKey);\n                    if (!state) {\n                        // There should always be state by now.\n                        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);\n                    }\n                    if (state.__hasPolled) {\n                        // You should never be able to poll twice in a row.\n                        throw new SolanaError(\n                            SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                        );\n                    }\n                    const publishQueue = state.publishQueue;\n                    try {\n                        if (publishQueue.length) {\n                            state.publishQueue = [];\n                            for (const item of publishQueue) {\n                                if (item.__type === PublishType.DATA) {\n                                    yield item.data;\n                                } else {\n                                    throw item.err;\n                                }\n                            }\n                        } else {\n                            yield await new Promise<TData>((resolve, reject) => {\n                                iteratorState.set(iteratorKey, {\n                                    __hasPolled: true,\n                                    onData: resolve,\n                                    onError: reject,\n                                });\n                            });\n                        }\n                    } catch (e) {\n                        if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                            return;\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            } finally {\n                iteratorState.delete(iteratorKey);\n            }\n        },\n    };\n}\n","import { TypedEventEmitter, TypedEventTarget } from './event-emitter';\n\ntype UnsubscribeFn = () => void;\n\n/**\n * Represents an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * @example\n * ```ts\n * let dataPublisher: DataPublisher<{ error: SolanaError }>;\n * dataPublisher.on('data', handleData); // ERROR. `data` is not a known channel name.\n * dataPublisher.on('error', e => {\n *     console.error(e);\n * }); // OK.\n * ```\n */\nexport interface DataPublisher<TDataByChannelName extends Record<string, unknown> = Record<string, unknown>> {\n    /**\n     * Call this to subscribe to data over a named channel.\n     *\n     * @param channelName The name of the channel on which to subscribe for messages\n     * @param subscriber The function to call when a message becomes available\n     * @param options.signal An abort signal you can fire to unsubscribe\n     *\n     * @returns A function that you can call to unsubscribe\n     */\n    on<const TChannelName extends keyof TDataByChannelName>(\n        channelName: TChannelName,\n        subscriber: (data: TDataByChannelName[TChannelName]) => void,\n        options?: { signal: AbortSignal },\n    ): UnsubscribeFn;\n}\n\n/**\n * Returns an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * The `on` function returns an unsubscribe function.\n *\n * @example\n * ```ts\n * const socketDataPublisher = getDataPublisherFromEventEmitter(new WebSocket('wss://api.devnet.solana.com'));\n * const unsubscribe = socketDataPublisher.on('message', message => {\n *     if (JSON.parse(message.data).id === 42) {\n *         console.log('Got response 42');\n *         unsubscribe();\n *     }\n * });\n * ```\n */\nexport function getDataPublisherFromEventEmitter<TEventMap extends Record<string, Event>>(\n    eventEmitter: TypedEventEmitter<TEventMap> | TypedEventTarget<TEventMap>,\n): DataPublisher<{\n    [TEventType in keyof TEventMap]: TEventMap[TEventType] extends CustomEvent ? TEventMap[TEventType]['detail'] : null;\n}> {\n    return {\n        on(channelName, subscriber, options) {\n            function innerListener(ev: Event) {\n                if (ev instanceof CustomEvent) {\n                    const data = (ev as CustomEvent<TEventMap[typeof channelName]>).detail;\n                    (subscriber as unknown as (data: TEventMap[typeof channelName]) => void)(data);\n                } else {\n                    (subscriber as () => void)();\n                }\n            }\n            eventEmitter.addEventListener(channelName, innerListener, options);\n            return () => {\n                eventEmitter.removeEventListener(channelName, innerListener);\n            };\n        },\n    };\n}\n","import { EventTarget } from '@solana/event-target-impl';\n\nimport { DataPublisher, getDataPublisherFromEventEmitter } from './data-publisher';\n\n/**\n * Given a channel that carries messages for multiple subscribers on a single channel name, this\n * function returns a new {@link DataPublisher} that splits them into multiple channel names.\n *\n * @param messageTransformer A function that receives the message as the first argument, and returns\n * a tuple of the derived channel name and the message.\n *\n * @example\n * Imagine a channel that carries multiple notifications whose destination is contained within the\n * message itself.\n *\n * ```ts\n * const demuxedDataPublisher = demultiplexDataPublisher(channel, 'message', message => {\n *     const destinationChannelName = `notification-for:${message.subscriberId}`;\n *     return [destinationChannelName, message];\n * });\n * ```\n *\n * Now you can subscribe to _only_ the messages you are interested in, without having to subscribe\n * to the entire `'message'` channel and filter out the messages that are not for you.\n *\n * ```ts\n * demuxedDataPublisher.on(\n *     'notification-for:123',\n *     message => {\n *         console.log('Got a message for subscriber 123', message);\n *     },\n *     { signal: AbortSignal.timeout(5_000) },\n * );\n * ```\n */\nexport function demultiplexDataPublisher<\n    TDataPublisher extends DataPublisher,\n    const TChannelName extends Parameters<TDataPublisher['on']>[0],\n>(\n    publisher: TDataPublisher,\n    sourceChannelName: TChannelName,\n    messageTransformer: (\n        // FIXME: Deriving the type of the message from `TDataPublisher` and `TChannelName` would\n        //        help callers to constrain their transform functions.\n        message: unknown,\n    ) => [destinationChannelName: string, message: unknown] | void,\n): DataPublisher {\n    let innerPublisherState:\n        | {\n              readonly dispose: () => void;\n              numSubscribers: number;\n          }\n        | undefined;\n    const eventTarget = new EventTarget();\n    const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    return {\n        ...demultiplexedDataPublisher,\n        on(channelName, subscriber, options) {\n            if (!innerPublisherState) {\n                const innerPublisherUnsubscribe = publisher.on(sourceChannelName, sourceMessage => {\n                    const transformResult = messageTransformer(sourceMessage);\n                    if (!transformResult) {\n                        return;\n                    }\n                    const [destinationChannelName, message] = transformResult;\n                    eventTarget.dispatchEvent(\n                        new CustomEvent(destinationChannelName, {\n                            detail: message,\n                        }),\n                    );\n                });\n                innerPublisherState = {\n                    dispose: innerPublisherUnsubscribe,\n                    numSubscribers: 0,\n                };\n            }\n            innerPublisherState.numSubscribers++;\n            const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options);\n            let isActive = true;\n            function handleUnsubscribe() {\n                if (!isActive) {\n                    return;\n                }\n                isActive = false;\n                options?.signal.removeEventListener('abort', handleUnsubscribe);\n                innerPublisherState!.numSubscribers--;\n                if (innerPublisherState!.numSubscribers === 0) {\n                    innerPublisherState!.dispose();\n                    innerPublisherState = undefined;\n                }\n                unsubscribe();\n            }\n            options?.signal.addEventListener('abort', handleUnsubscribe);\n            return handleUnsubscribe;\n        },\n    };\n}\n","import { SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\nimport { createAsyncIterableFromDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsApi, RpcSubscriptionsPlan } from './rpc-subscriptions-api';\nimport { PendingRpcSubscriptionsRequest, RpcSubscribeOptions } from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<TRpcMethods> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: RpcSubscriptionsTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcSubscriptionsMethods`.\n *\n * Calling each method returns a\n * {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} where\n * `TNotification` is that method's notification type.\n */\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link RpcSubscriptions} instance given a\n * {@link RpcSubscriptionsApi | RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>} and a\n * {@link RpcSubscriptionsTransport} capable of fulfilling them.\n */\nexport function createSubscriptionRpc<TRpcSubscriptionsApiMethods>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);\n                if (!createRpcSubscriptionPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {\n                        notificationName,\n                    });\n                }\n                const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);\n                return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction createPendingRpcSubscription<TNotification>(\n    transport: RpcSubscriptionsTransport,\n    subscriptionsPlan: RpcSubscriptionsPlan<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            const notificationsDataPublisher = await transport({\n                signal: abortSignal,\n                ...subscriptionsPlan,\n            });\n            return createAsyncIterableFromDataPublisher<TNotification>({\n                abortSignal,\n                dataChannelName: 'notification',\n                dataPublisher: notificationsDataPublisher,\n                errorChannelName: 'error',\n            });\n        },\n    };\n}\n","import { Callable, RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsTransportDataEvents } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsApiConfig<TApiMethods extends RpcSubscriptionsApiMethods> = Readonly<{\n    planExecutor: RpcSubscriptionsPlanExecutor<ReturnType<TApiMethods[keyof TApiMethods]>>;\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n}>;\n\n/**\n * A function that implements a protocol for subscribing and unsubscribing from notifications given\n * a {@link RpcSubscriptionsChannel}, a {@link RpcRequest}, and an `AbortSignal`.\n *\n * @returns A {@link DataPublisher} that emits {@link RpcSubscriptionsTransportDataEvents}\n */\ntype RpcSubscriptionsPlanExecutor<TNotification> = (\n    config: Readonly<{\n        channel: RpcSubscriptionsChannel<unknown, unknown>;\n        request: RpcRequest;\n        signal: AbortSignal;\n    }>,\n) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n\n/**\n * This type allows an {@link RpcSubscriptionsApi} to describe how a particular subscription should\n * be issued to the JSON RPC server.\n *\n * Given a function that was called on a {@link RpcSubscriptions}, this object exposes an `execute`\n * function that dictates which subscription request will be sent, how the underlying transport will\n * be used, and how the notifications will be transformed.\n *\n * This function accepts a {@link RpcSubscriptionsChannel} and an `AbortSignal` and asynchronously\n * returns a {@link DataPublisher}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   channel.\n * - call the underlying channel zero, one or multiple times depending on the use-case (e.g.\n *   caching or coalescing multiple subscriptions).\n * - transform the notification from the JSON RPC server, in case it does not match the\n *   `TNotification` specified by the\n *   {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} emitted\n *   from the publisher returned.\n */\nexport type RpcSubscriptionsPlan<TNotification> = Readonly<{\n    /**\n     * This method may be called with a newly-opened channel or a pre-established channel.\n     */\n    execute: (\n        config: Readonly<{\n            channel: RpcSubscriptionsChannel<unknown, unknown>;\n            signal: AbortSignal;\n        }>,\n    ) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n    /**\n     * This request is used to uniquely identify the subscription.\n     * It typically comes from the method name and parameters of the subscription call,\n     * after potentially being transformed by the RPC Subscriptions API.\n     */\n    request: RpcRequest;\n}>;\n\n/**\n * For each of `TRpcSubscriptionsMethods`, this object exposes a method with the same name that maps\n * between its input arguments and a\n * {@link RpcSubscriptionsPlan | RpcSubscriptionsPlan<TNotification>} that implements the execution\n * of a JSON RPC subscription for `TNotifications`.\n */\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a\n * {@link RpcSubscriptionsPlan} by creating an `execute` function that:\n *\n * - calls the supplied {@link RpcSubscriptionsApiConfig.planExecutor} with a JSON RPC v2 payload\n *   object with the requested `methodName` and `params` properties, optionally transformed by\n *   {@link RpcSubscriptionsApiConfig.requestTransformer}.\n *\n * @example\n * ```ts\n * // For example, given this `RpcSubscriptionsApi`:\n * const rpcSubscriptionsApi = createJsonRpcSubscriptionsApi({\n *     async planExecutor({ channel, request }) {\n *         await channel.send(request);\n *         return {\n *             ...channel,\n *             on(type, listener, options) {\n *                 if (type !== 'message') {\n *                     return channel.on(type, listener, options);\n *                 }\n *                 return channel.on(\n *                     'message',\n *                     function resultGettingListener(message) {\n *                         listener(message.result);\n *                     },\n *                     options,\n *                 );\n *             }\n *         }\n *     },\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n * });\n *\n * // ...the following function call:\n * rpcSubscriptionsApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcSubscriptionsPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Emits the \"result\" property of each RPC Subscriptions message.\n * ```\n */\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config: RpcSubscriptionsApiConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...params: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsPlan<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const rawRequest = { methodName, params };\n                const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;\n                return {\n                    execute(planConfig) {\n                        return config.planExecutor({ ...planConfig, request });\n                    },\n                    request,\n                };\n            };\n        },\n    });\n}\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype RpcSubscriptionsChannelSolanaErrorCode =\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;\n\nexport type RpcSubscriptionChannelEvents<TInboundMessage> = {\n    /**\n     * Fires when the channel closes unexpectedly.\n     * @eventProperty\n     */\n    error: SolanaError<RpcSubscriptionsChannelSolanaErrorCode>;\n    /**\n     * Fires on every message received from the remote end.\n     * @eventProperty\n     */\n    message: TInboundMessage;\n};\n\n/**\n * A {@link DataPublisher} on which you can subscribe to events of type\n * {@link RpcSubscriptionChannelEvents | RpcSubscriptionChannelEvents<TInboundMessage>}.\n * Additionally, you can use this object to send messages of type `TOutboundMessage` back to the\n * remote end by calling its {@link RpcSubscriptionsChannel.send | `send(message)`} method.\n */\nexport interface RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage> extends DataPublisher<\n    RpcSubscriptionChannelEvents<TInboundMessage>\n> {\n    send(message: TOutboundMessage): Promise<void>;\n}\n\n/**\n * A channel creator is a function that accepts an `AbortSignal`, returns a new\n * {@link RpcSubscriptionsChannel}, and tears down the channel when the abort signal fires.\n */\nexport type RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage> = (\n    config: Readonly<{\n        abortSignal: AbortSignal;\n    }>,\n) => Promise<RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>>;\n\n/**\n * Given a channel with inbound messages of type `T` and a function of type `T => U`, returns a new\n * channel with inbound messages of type `U`.\n *\n * Note that this only affects messages of type `\"message\"` and thus, does not affect incoming error\n * messages.\n *\n * @example Parsing incoming JSON messages\n * ```ts\n * const transformedChannel = transformChannelInboundMessages(channel, JSON.parse);\n * ```\n */\nexport function transformChannelInboundMessages<TOutboundMessage, TNewInboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TInboundMessage) => TNewInboundMessage,\n): RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage>>({\n        ...channel,\n        on(type, subscriber, options) {\n            if (type !== 'message') {\n                return channel.on(\n                    type,\n                    subscriber as (data: RpcSubscriptionChannelEvents<TInboundMessage>[typeof type]) => void,\n                    options,\n                );\n            }\n            return channel.on(\n                'message',\n                message => (subscriber as (data: TNewInboundMessage) => void)(transform(message)),\n                options,\n            );\n        },\n    });\n}\n\n/**\n * Given a channel with outbound messages of type `T` and a function of type `U => T`, returns a new\n * channel with outbound messages of type `U`.\n *\n * @example Stringifying JSON messages before sending them over the wire\n * ```ts\n * const transformedChannel = transformChannelOutboundMessages(channel, JSON.stringify);\n * ```\n */\nexport function transformChannelOutboundMessages<TNewOutboundMessage, TOutboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TNewOutboundMessage) => TOutboundMessage,\n): RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage>>({\n        ...channel,\n        send: message => channel.send(transform(message)),\n    });\n}\n","import {\n    getSolanaErrorFromJsonRpcError,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport { createRpcMessage, RpcRequest, RpcResponseData, RpcResponseTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\nimport { demultiplexDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionChannelEvents } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\n\ntype Config<TNotification> = Readonly<{\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification> | RpcResponseData<RpcSubscriptionId>>;\n    responseTransformer?: RpcResponseTransformer;\n    signal: AbortSignal;\n    subscribeRequest: RpcRequest;\n    unsubscribeMethodName: string;\n}>;\n\ntype RpcNotification<TNotification> = Readonly<{\n    method: string;\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\ntype RpcSubscriptionNotificationEvents<TNotification> = Omit<RpcSubscriptionChannelEvents<TNotification>, 'message'> & {\n    notification: TNotification;\n};\n\nconst subscriberCountBySubscriptionIdByChannel = new WeakMap<WeakKey, Record<number, number>>();\nfunction decrementSubscriberCountAndReturnNewCount(channel: WeakKey, subscriptionId?: number): number | undefined {\n    return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);\n}\nfunction incrementSubscriberCount(channel: WeakKey, subscriptionId?: number): void {\n    augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);\n}\nfunction getSubscriberCountBySubscriptionIdForChannel(channel: WeakKey): Record<number, number> {\n    let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);\n    if (!subscriberCountBySubscriptionId) {\n        subscriberCountBySubscriptionIdByChannel.set(channel, (subscriberCountBySubscriptionId = {}));\n    }\n    return subscriberCountBySubscriptionId;\n}\nfunction augmentSubscriberCountAndReturnNewCount(\n    amount: -1 | 1,\n    channel: WeakKey,\n    subscriptionId?: number,\n): number | undefined {\n    if (subscriptionId === undefined) {\n        return;\n    }\n    const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);\n    if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {\n        subscriberCountBySubscriptionId[subscriptionId] = 0;\n    }\n    const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];\n    if (newCount <= 0) {\n        delete subscriberCountBySubscriptionId[subscriptionId];\n    } else {\n        subscriberCountBySubscriptionId[subscriptionId] = newCount;\n    }\n    return newCount;\n}\n\nconst cache = new WeakMap();\nfunction getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer<TNotification>(\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification>>,\n    subscribeRequest: RpcRequest,\n    responseTransformer?: RpcResponseTransformer,\n): DataPublisher<{\n    [channelName: `notification:${number}`]: TNotification;\n}> {\n    let publisherByResponseTransformer = cache.get(channel);\n    if (!publisherByResponseTransformer) {\n        cache.set(channel, (publisherByResponseTransformer = new WeakMap()));\n    }\n    const responseTransformerKey = responseTransformer ?? channel;\n    let publisher = publisherByResponseTransformer.get(responseTransformerKey);\n    if (!publisher) {\n        publisherByResponseTransformer.set(\n            responseTransformerKey,\n            (publisher = demultiplexDataPublisher(channel, 'message', rawMessage => {\n                const message = rawMessage as RpcNotification<unknown> | RpcResponseData<unknown>;\n                if (!('method' in message)) {\n                    return;\n                }\n                const transformedNotification = responseTransformer\n                    ? responseTransformer(message.params.result, subscribeRequest)\n                    : message.params.result;\n                return [`notification:${message.params.subscription}`, transformedNotification];\n            })),\n        );\n    }\n    return publisher;\n}\n\n/**\n * Given a channel, this function executes the particular subscription plan required by the Solana\n * JSON RPC Subscriptions API.\n *\n * @param config\n *\n * 1. Calls the `subscribeRequest` on the remote RPC\n * 2. Waits for a response containing the subscription id\n * 3. Returns a {@link DataPublisher} that publishes notifications related to that subscriptions id,\n *    filtering out all others\n * 4. Calls the `unsubscribeMethodName` on the remote RPC when the abort signal is fired.\n */\nexport async function executeRpcPubSubSubscriptionPlan<TNotification>({\n    channel,\n    responseTransformer,\n    signal,\n    subscribeRequest,\n    unsubscribeMethodName,\n}: Config<TNotification>): Promise<DataPublisher<RpcSubscriptionNotificationEvents<TNotification>>> {\n    let subscriptionId: number | undefined;\n    channel.on(\n        'error',\n        () => {\n            // An error on the channel indicates that the subscriptions are dead.\n            // There is no longer any sense hanging on to subscription ids.\n            // Erasing it here will prevent the unsubscribe code from running.\n            subscriptionId = undefined;\n            subscriberCountBySubscriptionIdByChannel.delete(channel);\n        },\n        { signal },\n    );\n    /**\n     * STEP 1\n     * Create a promise that rejects if this subscription is aborted and sends\n     * the unsubscribe message if the subscription is active at that time.\n     */\n    const abortPromise = new Promise<never>((_, reject) => {\n        function handleAbort(this: AbortSignal) {\n            /**\n             * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n             * materially the same notification will be coalesced on the server. This means they\n             * will be assigned the same subscription id, and will occupy one subscription slot. We\n             * must be careful not to send the unsubscribe message until the last subscriber aborts.\n             */\n            if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {\n                const unsubscribePayload = createRpcMessage({\n                    methodName: unsubscribeMethodName,\n                    params: [subscriptionId],\n                });\n                subscriptionId = undefined;\n                channel.send(unsubscribePayload).catch(() => {});\n            }\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(this.reason);\n        }\n        if (signal.aborted) {\n            handleAbort.call(signal);\n        } else {\n            signal.addEventListener('abort', handleAbort);\n        }\n    });\n    /**\n     * STEP 2\n     * Send the subscription request.\n     */\n    const subscribePayload = createRpcMessage(subscribeRequest);\n    await channel.send(subscribePayload);\n    /**\n     * STEP 3\n     * Wait for the acknowledgement from the server with the subscription id.\n     */\n    const subscriptionIdPromise = new Promise<RpcSubscriptionId>((resolve, reject) => {\n        const abortController = new AbortController();\n        signal.addEventListener('abort', abortController.abort.bind(abortController));\n        const options = { signal: abortController.signal } as const;\n        channel.on(\n            'error',\n            err => {\n                abortController.abort();\n                reject(err);\n            },\n            options,\n        );\n        channel.on(\n            'message',\n            message => {\n                if (message && typeof message === 'object' && 'id' in message && message.id === subscribePayload.id) {\n                    abortController.abort();\n                    if ('error' in message) {\n                        reject(getSolanaErrorFromJsonRpcError(message.error));\n                    } else {\n                        resolve(message.result);\n                    }\n                }\n            },\n            options,\n        );\n    });\n    subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);\n    if (subscriptionId == null) {\n        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n    }\n    incrementSubscriberCount(channel, subscriptionId);\n    /**\n     * STEP 4\n     * Filter out notifications unrelated to this subscription.\n     */\n    const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(\n        channel,\n        subscribeRequest,\n        responseTransformer,\n    );\n    const notificationKey = `notification:${subscriptionId}` as const;\n    return {\n        on(type, listener, options) {\n            switch (type) {\n                case 'notification':\n                    return notificationPublisher.on(\n                        notificationKey,\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['notification']) => void,\n                        options,\n                    );\n                case 'error':\n                    return channel.on(\n                        'error',\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['error']) => void,\n                        options,\n                    );\n                default:\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {\n                        channelName: type,\n                        supportedChannelNames: ['notification', 'error'],\n                    });\n            }\n        },\n    };\n}\n","import {\n    createRpcSubscriptionsApi,\n    executeRpcPubSubSubscriptionPlan,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpcSubscriptions,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);\n    const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n        allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n    });\n    return createRpcSubscriptionsApi<TApi>({\n        planExecutor({ request, ...rest }) {\n            return executeRpcPubSubSubscriptionPlan({\n                ...rest,\n                responseTransformer,\n                subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, 'Subscribe') },\n                unsubscribeMethodName: request.methodName.replace(/Notifications$/, 'Unsubscribe'),\n            });\n        },\n        requestTransformer,\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n","export default globalThis.WebSocket;\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { EventTarget } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport { getDataPublisherFromEventEmitter } from '@solana/subscribable';\nimport WebSocket from '@solana/ws-impl';\n\nexport type Config = Readonly<{\n    /**\n     * The number of bytes to admit into the WebSocket's send buffer before queueing messages on the\n     * client.\n     *\n     * When you call {@link RpcSubscriptionsChannel.send | `send()`} on a `WebSocket` the runtime\n     * might add the message to a buffer rather than send it right away. In the event that\n     * `socket.bufferedAmount` exceeds the value configured here, messages will be added to a queue\n     * in your application code instead of being sent to the WebSocket, until such time as the\n     * `bufferedAmount` falls back below the high watermark.\n     */\n    sendBufferHighWatermark: number;\n    /**\n     * An `AbortSignal` to fire when you want to explicitly close the `WebSocket`.\n     *\n     * If the channel is open it will be closed with a normal closure code\n     * (https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1) If the channel has not been\n     * established yet, firing this signal will result in the `AbortError` being thrown to the\n     * caller who was trying to open the channel.\n     */\n    signal: AbortSignal;\n    /**\n     * A string representing the target endpoint.\n     *\n     * In Node, it must be an absolute URL using the `ws` or `wss` protocol.\n     */\n    url: string;\n}>;\n\ntype WebSocketMessage = ArrayBufferLike | ArrayBufferView | Blob | string;\n\nconst NORMAL_CLOSURE_CODE = 1000; // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\n/**\n * Creates an object that represents an open channel to a `WebSocket` server.\n *\n * You can use it to send messages by calling its\n * {@link RpcSubscriptionsChannel.send | `send()`} function and you can receive them by subscribing\n * to the {@link RpcSubscriptionChannelEvents} it emits.\n */\nexport function createWebSocketChannel({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcSubscriptionsChannel<WebSocketMessage, string>> {\n    if (signal.aborted) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(signal.reason);\n    }\n    let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n    let hasConnected = false;\n    const listenerRemovers = new Set<() => void>();\n    function cleanupListeners() {\n        listenerRemovers.forEach(r => {\n            r();\n        });\n        listenerRemovers.clear();\n    }\n    function handleAbort() {\n        cleanupListeners();\n        if (!hasConnected) {\n            rejectOpen(signal.reason);\n        }\n        if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n            webSocket.close(NORMAL_CLOSURE_CODE);\n        }\n    }\n    function handleClose(ev: CloseEvent) {\n        cleanupListeners();\n        bufferDrainWatcher?.onCancel();\n        signal.removeEventListener('abort', handleAbort);\n        webSocket.removeEventListener('close', handleClose);\n        webSocket.removeEventListener('error', handleError);\n        webSocket.removeEventListener('message', handleMessage);\n        webSocket.removeEventListener('open', handleOpen);\n        if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {\n                        cause: ev,\n                    }),\n                }),\n            );\n        }\n    }\n    function handleError(ev: Event) {\n        if (signal.aborted) {\n            return;\n        }\n        if (!hasConnected) {\n            const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {\n                errorEvent: ev,\n            });\n            rejectOpen(failedToConnectError);\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: failedToConnectError,\n                }),\n            );\n        }\n    }\n    function handleMessage(ev: MessageEvent) {\n        if (signal.aborted) {\n            return;\n        }\n        eventTarget.dispatchEvent(new CustomEvent('message', { detail: ev.data }));\n    }\n    const eventTarget = new EventTarget();\n    const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    function handleOpen() {\n        hasConnected = true;\n        resolveOpen({\n            ...dataPublisher,\n            async send(message) {\n                if (webSocket.readyState !== WebSocket.OPEN) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);\n                }\n                if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {\n                    let onCancel!: () => void;\n                    const promise = new Promise<void>((resolve, reject) => {\n                        const intervalId = setInterval(() => {\n                            if (\n                                webSocket.readyState !== WebSocket.OPEN ||\n                                !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                            ) {\n                                clearInterval(intervalId);\n                                bufferDrainWatcher = undefined;\n                                resolve();\n                            }\n                        }, 16);\n                        onCancel = () => {\n                            bufferDrainWatcher = undefined;\n                            clearInterval(intervalId);\n                            reject(\n                                new SolanaError(\n                                    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                ),\n                            );\n                        };\n                    });\n                    bufferDrainWatcher = {\n                        onCancel,\n                        promise,\n                    };\n                }\n                if (bufferDrainWatcher) {\n                    if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {\n                        const TypedArrayConstructor = message.constructor as {\n                            new (...args: [typeof message]): typeof message;\n                        };\n                        // Clone the message to prevent mutation while queued.\n                        message = new TypedArrayConstructor(message);\n                    }\n                    await bufferDrainWatcher.promise;\n                }\n                webSocket.send(message);\n            },\n        });\n    }\n    const webSocket = new WebSocket(url);\n    signal.addEventListener('abort', handleAbort);\n    webSocket.addEventListener('close', handleClose);\n    webSocket.addEventListener('error', handleError);\n    webSocket.addEventListener('message', handleMessage);\n    webSocket.addEventListener('open', handleOpen);\n    let rejectOpen!: (e: SolanaError) => void;\n    let resolveOpen!: (value: RpcSubscriptionsChannel<WebSocketMessage, string>) => void;\n    return new Promise<RpcSubscriptionsChannel<WebSocketMessage, string>>((resolve, reject) => {\n        rejectOpen = reject;\n        resolveOpen = resolve;\n    });\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that sends a ping message to\n * the inner channel if a message has not been sent or received in the last `intervalMs`. In web\n * browsers, this implementation sends no ping when the network is down, and sends a ping\n * immediately upon the network coming back up.\n */\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\n/**\n * Given a channel creator, will return a new channel creator with the following behavior.\n *\n * 1. When called, returns a {@link RpcSubscriptionsChannel}. Adds that channel to a pool.\n * 2. When called again, creates and returns new\n *    {@link RpcSubscriptionChannel | RpcSubscriptionChannels} up to the number specified by\n *    `minChannels`.\n * 3. When `minChannels` channels have been created, subsequent calls vend whichever existing\n *    channel from the pool has the fewest subscribers, or the next one in rotation in the event of\n *    a tie.\n * 4. Once all channels carry the number of subscribers specified by the number\n *    `maxSubscriptionsPerChannel`, new channels in excess of `minChannel` will be created,\n *    returned, and added to the pool.\n * 5. A channel will be destroyed once all of its subscribers' abort signals fire.\n */\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that parses data published to\n * the `'message'` channel as JSON, and JSON-stringifies messages sent via the\n * {@link RpcSubscriptionsChannel.send | send(message)} method.\n */\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Similarly, to {@link getRpcSubscriptionsChannelWithJSONSerialization}, this function will\n * stringify and parse JSON message to and from the given `string` channel. However, this function\n * parses any integer value as a `BigInt` in order to safely handle numbers that exceed the\n * JavaScript [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n * value.\n */\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigInts),\n    );\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * The number of milliseconds to wait since the last message sent or received over the channel\n     * before sending a ping message to keep the channel open.\n     */\n    intervalMs?: number;\n    /**\n     * The number of subscribers that may share a channel before a new channel must be created.\n     *\n     * It is important that you set this to the maximum number of subscriptions that your RPC\n     * provider recommends making over a single connection; the default is set deliberately low, so\n     * as to comply with the restrictive limits of the public mainnet RPC node.\n     *\n     * @defaultValue 100\n     */\n    maxSubscriptionsPerChannel?: number;\n    /** The number of channels to create before reusing a channel for a new subscription. */\n    minChannels?: number;\n    /**\n     * The number of bytes of data to admit into the\n     * [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) buffer before\n     * buffering data on the client.\n     */\n    sendBufferHighWatermark?: number;\n    /** The URL of the web socket server. Must use the `ws` or `wss` protocols. */\n    url: TClusterUrl;\n}>;\n\n/**\n * Similar to {@link createDefaultRpcSubscriptionsChannelCreator} with some Solana-specific\n * defaults.\n *\n * For instance, it safely handles `BigInt` values in JSON messages since Solana RPC servers accept\n * and return integers larger than [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\n */\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\n/**\n * Creates a function that returns new subscription channels when called.\n */\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                      `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\n/**\n * Given a {@link RpcSubscriptionsTransport}, will return a new transport that coalesces identical\n * subscriptions into a single subscription request to the server. The determination of whether a\n * subscription is the same as another is based on the `rpcRequest` returned by its\n * {@link RpcSubscriptionsPlan}. The subscription will only be aborted once all subscribers abort,\n * or there is an error.\n */\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\n/**\n * Creates a {@link RpcSubscriptionsTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - Logic that coalesces multiple subscriptions for the same notifications with the same arguments\n *   into a single subscription.\n *\n * @param config\n */\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API,\n * including its unstable methods, given a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * the supplied {@link RpcSubscriptionsTransport}.\n */\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary. The returned transaction must be within the transaction size limit,\n * and include a `lifetimeConstraint`.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<(Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature dictionary for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesnt matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","import { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { TransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: TransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends unknown ? Omit<TTransactionMessage, 'feePayer'> : never;\n\n/**\n * Sets the fee payer of a {@link TransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner> &\n        TransactionMessage,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n        TransactionMessageWithFeePayerSigner<TFeePayerAddress>;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesnt matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import { OffchainMessageWithRequiredSignatories } from '@solana/offchain-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isMessageSigner, MessageSigner } from './message-signer';\n\n/**\n * Represents a {@link Signer} that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatorySigner<TAddress extends string = string> = MessageSigner<TAddress>;\n\n/**\n * Extracts and deduplicates all {@link MessageSigner | MessageSigners} stored inside a given\n * {@link OffchainMessageWithSigners | offchain message}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link MessageSigner | MessageSigners}.\n * @typeParam TOffchainMessage - The inferred type of the offchain message provided.\n *\n * @example\n * ```ts\n * import { OffchainMessageWithSigners, getSignersFromOffchainMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signMessages: async () => {} };\n * const signerB = { address: address('2222..2222'), modifyAndSignMessages: async () => {} };\n * const OffchainMessage: OffchainMessageWithSigners = {\n *     /* ... *\\/\n *     requiredSignatories: [signerA, signerB],\n * };\n *\n * const messageSigners = getSignersFromOffchainMessage(offchainMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromOffchainMessage({\n    requiredSignatories,\n}: OffchainMessageWithRequiredSignatories): readonly MessageSigner[] {\n    const messageSigners = requiredSignatories.filter(isMessageSigner);\n    return deduplicateSigners(messageSigners);\n}\n","import {\n    assertIsFullySignedOffchainMessageEnvelope,\n    compileOffchainMessageEnvelope,\n    FullySignedOffchainMessageEnvelope,\n    OffchainMessage,\n    OffchainMessageEnvelope,\n    OffchainMessageSignatory,\n    OffchainMessageWithRequiredSignatories,\n} from '@solana/offchain-messages';\n\nimport {\n    isMessageModifyingSigner,\n    MessageModifyingSigner,\n    MessageModifyingSignerConfig,\n} from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner, MessagePartialSignerConfig } from './message-partial-signer';\nimport { MessageSigner } from './message-signer';\nimport { getSignersFromOffchainMessage, OffchainMessageSignatorySigner } from './offchain-message-signer';\nimport { SignableMessage } from './signable-message';\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope.\n *\n * It first uses all {@link MessageModifyingSigner | MessageModifyingSigners} sequentially before\n * using all {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link MessageModifyingSigner} if no other signer implements that interface. Otherwise, it will\n * be used as a {@link MessagePartialSigner}.\n *\n * @example\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @see {@link signOffchainMessageWithSigners}\n */\nexport async function partiallySignOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    const { partialSigners, modifyingSigners } = categorizeMessageSigners(\n        getSignersFromOffchainMessage(offchainMessage),\n    );\n    return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);\n}\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope before asserting that all signatures required\n * by the message are present.\n *\n * This function delegates to the {@link partiallySignOffchainMessageWithSigners} function\n * in order to extract signers from the offchain message and sign it.\n *\n * @example\n * ```ts\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage);\n *\n * // With additional config.\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the offchain message is fully signed.\n * mySignedOffchainMessageEnvelope satisfies FullySignedOffchainMessageEnvelope;\n * ```\n *\n * @see {@link partiallySignOffchainMessageWithSigners}\n */\nexport async function signOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<FullySignedOffchainMessageEnvelope & OffchainMessageEnvelope> {\n    const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);\n    assertIsFullySignedOffchainMessageEnvelope(signedOffchainMessageEnvelope);\n    return signedOffchainMessageEnvelope;\n}\n\n/**\n * Identifies each provided {@link MessageSigner} and categorizes them into their respective types.\n * When a signer implements multiple interfaces, it will try to used to most powerful interface but\n * fall back to the least powerful interface when necessary.\n *\n * For instance, if a signer implements {@link MessageSigner} and {@link MessageModifyingSigner},\n * it will be categorized as a `MessageModifyingSigner`.\n */\nfunction categorizeMessageSigners(signers: readonly MessageSigner[]): Readonly<{\n    modifyingSigners: readonly MessageModifyingSigner[];\n    partialSigners: readonly MessagePartialSigner[];\n}> {\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyMessageModifyingSigners(signers);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = signers\n        .filter(isMessagePartialSigner)\n        .filter(signer => !(modifyingSigners as typeof signers).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners });\n}\n\n/** Identifies the best signers to use as MessageModifyingSigners, if any */\nfunction identifyMessageModifyingSigners(\n    signers: readonly (MessageModifyingSigner | MessagePartialSigner)[],\n): readonly MessageModifyingSigner[] {\n    // Ensure there are any MessageModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isMessageModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isMessagePartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs an offchain message using the provided\n * {@link MessageModifyingSigner | MessageModifyingSigners} sequentially followed by the\n * {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n */\nasync function signModifyingAndPartialMessageSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    modifyingSigners: readonly MessageModifyingSigner[] = [],\n    partialSigners: readonly MessagePartialSigner[] = [],\n    config?: MessageModifyingSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    const offchainMessageEnvelope: SignableMessage = compileOffchainMessageEnvelope(offchainMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope, modifyingSigner) => {\n        config?.abortSignal?.throwIfAborted();\n        const [message] = await modifyingSigner.modifyAndSignMessages([await offchainMessageEnvelope], config);\n        return Object.freeze(message);\n    }, Promise.resolve(offchainMessageEnvelope));\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signMessages([modifiedOffchainMessage], config);\n            return signatures;\n        }),\n    );\n\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    return Object.freeze({\n        ...modifiedOffchainMessage,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedOffchainMessage.signatures ?? {}),\n        ),\n    } as OffchainMessageEnvelope);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithinSizeLimit,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<SendableTransaction & Transaction & TransactionWithLifetime> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners(\n    transaction: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionSendingSignerConfig,\n): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = (await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    )) as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime;\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    });\n}\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","import { SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SolanaError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { GetEpochInfoApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport type { Commitment } from '@solana/rpc-types';\n\ntype GetBlockHeightExceedencePromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * Fetch the block height as of the highest slot that has reached this level of commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /** The block height after which to reject the promise */\n    lastValidBlockHeight: bigint;\n}) => Promise<void>;\n\ntype CreateBlockHeightExceedencePromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetEpochInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Creates a promise that throws when the network progresses past the block height after which the\n * supplied blockhash is considered expired for use as a transaction lifetime specifier.\n *\n * When a transaction's lifetime is tied to a blockhash, that transaction can be landed on the\n * network until that blockhash expires. All blockhashes have a block height after which they are\n * considered to have expired.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, SolanaError } from '@solana/errors';\n * import { createBlockHeightExceedencePromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getBlockHeightExceedencePromise({ lastValidBlockHeight });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n *         console.error(\n *             `The block height of the network has exceeded ${e.context.lastValidBlockHeight}. ` +\n *                 `It is now ${e.context.currentBlockHeight}`,\n *         );\n *         // Re-sign and retry the transaction.\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'devnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'testnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'mainnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<TCluster>): GetBlockHeightExceedencePromiseFn {\n    return async function getBlockHeightExceedencePromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        lastValidBlockHeight,\n    }): Promise<never> {\n        callerAbortSignal.throwIfAborted();\n        const abortController = new AbortController();\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {\n            const { absoluteSlot, blockHeight } = await rpc\n                .getEpochInfo({ commitment })\n                .send({ abortSignal: abortController.signal });\n            return {\n                blockHeight,\n                differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight,\n            };\n        }\n        try {\n            const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] =\n                await Promise.all([\n                    rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),\n                    getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight(),\n                ]);\n            callerAbortSignal.throwIfAborted();\n            let currentBlockHeight = initialBlockHeight;\n            if (currentBlockHeight <= lastValidBlockHeight) {\n                let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;\n                for await (const slotNotification of slotNotifications) {\n                    const { slot } = slotNotification;\n                    if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {\n                        // Before making a final decision, recheck the actual block height.\n                        const {\n                            blockHeight: recheckedBlockHeight,\n                            differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight,\n                        } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();\n                        currentBlockHeight = recheckedBlockHeight;\n                        if (currentBlockHeight > lastValidBlockHeight) {\n                            // Verified; the block height has been exceeded.\n                            break;\n                        } else {\n                            // The block height has not been exceeded, which implies that the\n                            // difference between the slot height and the block height has grown\n                            // (ie. some blocks have been skipped since we started). Recalibrate the\n                            // difference and keep waiting.\n                            lastKnownDifferenceBetweenSlotHeightAndBlockHeight =\n                                currentDifferenceBetweenSlotHeightAndBlockHeight;\n                        }\n                    }\n                }\n            }\n            callerAbortSignal.throwIfAborted();\n            throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {\n                currentBlockHeight,\n                lastValidBlockHeight,\n            });\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Decoder, getBase64Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SolanaError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport type { GetAccountInfoApi, Rpc } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions } from '@solana/rpc-subscriptions';\nimport type { Base64EncodedDataResponse, Commitment } from '@solana/rpc-types';\nimport { Nonce } from '@solana/transaction-messages';\n\ntype GetNonceInvalidationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * Fetch the nonce account details as of the highest slot that has reached this level of\n     * commitment.\n     */\n    commitment: Commitment;\n    /**\n     * The value of the nonce that we would expect to see in the nonce account in order for any\n     * transaction with that nonce-based lifetime to be considered valid.\n     */\n    currentNonceValue: Nonce;\n    /** The address of the account in which the currently-valid nonce value is stored */\n    nonceAccountAddress: Address;\n}) => Promise<void>;\n\ntype CreateNonceInvalidationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetAccountInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nconst NONCE_VALUE_OFFSET =\n    4 + // version(u32)\n    4 + // state(u32)\n    32; // nonce authority(pubkey)\n// Then comes the nonce value.\n\n/**\n * Creates a promise that throws when the value stored in a nonce account is not the expected one.\n *\n * When a transaction's lifetime is tied to the value stored in a nonce account, that transaction\n * can be landed on the network until the nonce is advanced to a new value.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, SolanaError } from '@solana/errors';\n * import { createNonceInvalidationPromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getNonceInvalidationPromise({\n *         currentNonceValue,\n *         nonceAccountAddress,\n *     });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__NONCE_INVALID)) {\n *         console.error(`The nonce has advanced to ${e.context.actualNonceValue}`);\n *         // Re-sign and retry the transaction.\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n *         console.error(`No nonce account was found at ${nonceAccountAddress}`);\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'devnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'testnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'mainnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<TCluster>): GetNonceInvalidationPromiseFn {\n    return async function getNonceInvalidationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        currentNonceValue: expectedNonceValue,\n        nonceAccountAddress,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for nonce account changes.\n         */\n        const accountNotifications = await rpcSubscriptions\n            .accountNotifications(nonceAccountAddress, { commitment, encoding: 'base64' })\n            .subscribe({ abortSignal: abortController.signal });\n        const base58Decoder = getBase58Decoder();\n        const base64Encoder = getBase64Encoder();\n        function getNonceFromAccountData([base64EncodedBytes]: Base64EncodedDataResponse): Nonce {\n            const data = base64Encoder.encode(base64EncodedBytes);\n            const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);\n            return base58Decoder.decode(nonceValueBytes) as Nonce;\n        }\n        const nonceAccountDidAdvancePromise = (async () => {\n            for await (const accountNotification of accountNotifications) {\n                const nonceValue = getNonceFromAccountData(accountNotification.value.data);\n                if (nonceValue !== expectedNonceValue) {\n                    throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                        actualNonceValue: nonceValue,\n                        expectedNonceValue,\n                    });\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current nonce\n         *         value to check if it has already been advanced.\n         */\n        const nonceIsAlreadyInvalidPromise = (async () => {\n            const { value: nonceAccount } = await rpc\n                .getAccountInfo(nonceAccountAddress, {\n                    commitment,\n                    dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n                    encoding: 'base58',\n                })\n                .send({ abortSignal: abortController.signal });\n            if (!nonceAccount) {\n                throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {\n                    nonceAccountAddress,\n                });\n            }\n            const nonceValue =\n                // This works because we asked for the exact slice of data representing the nonce\n                // value, and furthermore asked for it in `base58` encoding.\n                nonceAccount.data[0] as unknown as Nonce;\n            if (nonceValue !== expectedNonceValue) {\n                throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                    actualNonceValue: nonceValue,\n                    expectedNonceValue,\n                });\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import { getSolanaErrorFromTransactionError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { GetSignatureStatusesApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { type Commitment, commitmentComparator } from '@solana/rpc-types';\n\ntype GetRecentSignatureConfirmationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * The level of commitment the transaction must have achieved in order for the promise to\n     * resolve.\n     */\n    commitment: Commitment;\n    /**\n     * A 64 byte Ed25519 signature, encoded as a base-58 string, that uniquely identifies a\n     * transaction by virtue of being the first or only signature in its list of signatures.\n     */\n    signature: Signature;\n}) => Promise<void>;\n\ntype CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetSignatureStatusesApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Creates a promise that resolves when a recently-landed transaction achieves the target\n * confirmation commitment, and throws when the transaction fails with an error.\n *\n * The status of recently-landed transactions is available in the network's status cache. This\n * confirmation strategy will only yield a result if the signature is still in the status cache. To\n * fetch the status of transactions older than those available in the status cache, use the\n * {@link GetSignatureStatusesApi.getSignatureStatuses} method setting the\n * `searchTransactionHistory` configuration param to `true`.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { createRecentSignatureConfirmationPromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getRecentSignatureConfirmationPromise({\n *         commitment,\n *         signature,\n *     });\n *     console.log(`The transaction with signature \\`${signature}\\` has achieved a commitment level of \\`${commitment}\\``);\n * } catch (e) {\n *     console.error(`The transaction with signature \\`${signature}\\` failed`, e.cause);\n *     throw e;\n * }\n * ```\n */\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'devnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'testnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'mainnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster>): GetRecentSignatureConfirmationPromiseFn {\n    return async function getRecentSignatureConfirmationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        signature,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for status changes to a signature.\n         */\n        const signatureStatusNotifications = await rpcSubscriptions\n            .signatureNotifications(signature, { commitment })\n            .subscribe({ abortSignal: abortController.signal });\n        const signatureDidCommitPromise = (async () => {\n            for await (const signatureStatusNotification of signatureStatusNotifications) {\n                if (signatureStatusNotification.value.err) {\n                    throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);\n                } else {\n                    return;\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current status.\n         *         This will only yield a result if the signature is still in the status cache.\n         */\n        const signatureStatusLookupPromise = (async () => {\n            const { value: signatureStatusResults } = await rpc\n                .getSignatureStatuses([signature])\n                .send({ abortSignal: abortController.signal });\n            const signatureStatus = signatureStatusResults[0];\n            if (signatureStatus?.err) {\n                throw getSolanaErrorFromTransactionError(signatureStatus.err);\n            } else if (\n                signatureStatus?.confirmationStatus &&\n                commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0\n            ) {\n                return;\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([signatureDidCommitPromise, signatureStatusLookupPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    /**\n     * The timeout promise will throw after 30 seconds when the commitment is `processed`, and 60\n     * seconds otherwise.\n     */\n    commitment: Commitment;\n}>;\n\n/**\n * When no other heuristic exists to infer that a transaction has expired, you can use this promise\n * factory with a commitment level. It throws after 30 seconds when the commitment is `processed`,\n * and 60 seconds otherwise. You would typically race this with another confirmation strategy.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { safeRace } from '@solana/promises';\n * import { getTimeoutPromise } from '@solana/transaction-confirmation';\n *\n * try {\n *     await safeRace([getCustomTransactionConfirmationPromise(/* ... *\\/), getTimeoutPromise({ commitment })]);\n * } catch (e) {\n *     if (e instanceof DOMException && e.name === 'TimeoutError') {\n *         console.log('Could not confirm transaction after a timeout');\n *     }\n *     throw e;\n * }\n * ```\n */\nexport async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }: Config) {\n    return await new Promise((_, reject) => {\n        const handleAbort = (e: AbortSignalEventMap['abort']) => {\n            clearTimeout(timeoutId);\n            const abortError = new DOMException((e.target as AbortSignal).reason, 'AbortError');\n            reject(abortError);\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort);\n        const timeoutMs = commitment === 'processed' ? 30_000 : 60_000;\n        const startMs = performance.now();\n        const timeoutId =\n            // We use `setTimeout` instead of `AbortSignal.timeout()` because we want to measure\n            // elapsed time instead of active time.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static\n            setTimeout(() => {\n                const elapsedMs = performance.now() - startMs;\n                reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, 'TimeoutError'));\n            }, timeoutMs);\n    });\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { createRecentSignatureConfirmationPromiseFactory } from './confirmation-strategy-recent-signature';\n\nexport interface BaseTransactionConfirmationStrategyConfig {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    getRecentSignatureConfirmationPromise: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n}\n\ntype WithNonNullableAbortSignal<T> = Omit<T, 'abortSignal'> & Readonly<{ abortSignal: AbortSignal }>;\n\nexport async function raceStrategies<TConfig extends BaseTransactionConfirmationStrategyConfig>(\n    signature: Signature,\n    config: TConfig,\n    getSpecificStrategiesForRace: (config: WithNonNullableAbortSignal<TConfig>) => readonly Promise<unknown>[],\n) {\n    const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;\n    callerAbortSignal?.throwIfAborted();\n    const abortController = new AbortController();\n    if (callerAbortSignal) {\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n    }\n    try {\n        const specificStrategies = getSpecificStrategiesForRace({\n            ...config,\n            abortSignal: abortController.signal,\n        });\n        return await safeRace([\n            getRecentSignatureConfirmationPromise({\n                abortSignal: abortController.signal,\n                commitment,\n                signature,\n            }),\n            ...specificStrategies,\n        ]);\n    } finally {\n        abortController.abort();\n    }\n}\n","import { Signature } from '@solana/keys';\nimport {\n    getSignatureFromTransaction,\n    Transaction,\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\nimport { createBlockHeightExceedencePromiseFactory } from './confirmation-strategy-blockheight';\nimport { createNonceInvalidationPromiseFactory } from './confirmation-strategy-nonce';\nimport { BaseTransactionConfirmationStrategyConfig, raceStrategies } from './confirmation-strategy-racer';\nimport { getTimeoutPromise } from './confirmation-strategy-timeout';\n\nexport type TransactionWithLastValidBlockHeight = Omit<TransactionWithBlockhashLifetime, 'lifetimeConstraint'> & {\n    lifetimeConstraint: Omit<TransactionWithBlockhashLifetime['lifetimeConstraint'], 'blockhash'>;\n};\n\ninterface WaitForDurableNonceTransactionConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getNonceInvalidationPromise: ReturnType<typeof createNonceInvalidationPromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithDurableNonceLifetime>;\n}\n\ninterface WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getBlockHeightExceedencePromise: ReturnType<typeof createBlockHeightExceedencePromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithLastValidBlockHeight>;\n}\n\ninterface WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getTimeoutPromise: typeof getTimeoutPromise;\n    /**\n     * A 64 byte Ed25519 signature, encoded as a base-58 string, that uniquely identifies a\n     * transaction by virtue of being the first or only signature in its list of signatures.\n     */\n    signature: Signature;\n}\n\n/**\n * Supply your own confirmation implementations to this function to create a custom nonce\n * transaction confirmation strategy.\n *\n * @example\n * ```ts\n * import { waitForDurableNonceTransactionConfirmation } from '@solana/transaction-confirmation';\n *\n * try {\n *     await waitForDurableNonceTransactionConfirmation({\n *         getNonceInvalidationPromise({ abortSignal, commitment, currentNonceValue, nonceAccountAddress }) {\n *             // Return a promise that rejects when a nonce becomes invalid.\n *         },\n *         getRecentSignatureConfirmationPromise({ abortSignal, commitment, signature }) {\n *             // Return a promise that resolves when a transaction achieves confirmation\n *         },\n *     });\n * } catch (e) {\n *     // Handle errors.\n * }\n * ```\n */\nexport async function waitForDurableNonceTransactionConfirmation(\n    config: WaitForDurableNonceTransactionConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {\n            return [\n                getNonceInvalidationPromise({\n                    abortSignal,\n                    commitment,\n                    currentNonceValue: transaction.lifetimeConstraint.nonce,\n                    nonceAccountAddress: transaction.lifetimeConstraint.nonceAccountAddress,\n                }),\n            ];\n        },\n    );\n}\n\n/**\n * Supply your own confirmation implementations to this function to create a custom confirmation\n * strategy for recently-landed transactions.\n *\n * @example\n * ```ts\n * import { waitForRecentTransactionConfirmation } from '@solana/transaction-confirmation';\n *\n * try {\n *     await waitForRecentTransactionConfirmation({\n *         getBlockHeightExceedencePromise({ abortSignal, commitment, lastValidBlockHeight }) {\n *             // Return a promise that rejects when the blockhash's block height has been exceeded\n *         },\n *         getRecentSignatureConfirmationPromise({ abortSignal, commitment, signature }) {\n *             // Return a promise that resolves when a transaction achieves confirmation\n *         },\n *     });\n * } catch (e) {\n *     // Handle errors.\n * }\n * ```\n */\nexport async function waitForRecentTransactionConfirmation(\n    config: WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({\n            abortSignal,\n            commitment,\n            getBlockHeightExceedencePromise,\n            transaction,\n        }) {\n            return [\n                getBlockHeightExceedencePromise({\n                    abortSignal,\n                    commitment,\n                    lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight,\n                }),\n            ];\n        },\n    );\n}\n\n/** @deprecated */\nexport async function waitForRecentTransactionConfirmationUntilTimeout(\n    config: WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        config.signature,\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise }) {\n            return [\n                getTimeoutPromise({\n                    abortSignal,\n                    commitment,\n                }),\n            ];\n        },\n    );\n}\n","import type { Address } from '@solana/addresses';\nimport type { Signature } from '@solana/keys';\nimport type { RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { Commitment, Lamports } from '@solana/rpc-types';\nimport { waitForRecentTransactionConfirmationUntilTimeout } from '@solana/transaction-confirmation';\n\ntype RequestAndConfirmAirdropConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    confirmSignatureOnlyTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) => Promise<void>;\n    lamports: Lamports;\n    recipientAddress: Address;\n    rpc: Rpc<RequestAirdropApi>;\n}>;\n\nexport async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmSignatureOnlyTransaction,\n    lamports,\n    recipientAddress,\n    rpc,\n}: RequestAndConfirmAirdropConfig): Promise<Signature> {\n    const airdropTransactionSignature = await rpc\n        .requestAirdrop(recipientAddress, lamports, { commitment })\n        .send({ abortSignal });\n    await confirmSignatureOnlyTransaction({\n        abortSignal,\n        commitment,\n        signature: airdropTransactionSignature,\n    });\n    return airdropTransactionSignature;\n}\n","import type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createRecentSignatureConfirmationPromiseFactory,\n    getTimeoutPromise,\n    waitForRecentTransactionConfirmationUntilTimeout,\n} from '@solana/transaction-confirmation';\n\nimport { requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT } from './airdrop-internal';\n\ntype AirdropFunction = (\n    config: Omit<\n        Parameters<typeof requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmSignatureOnlyTransaction' | 'rpc'\n    >,\n) => Promise<Signature>;\n\ntype AirdropFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link RequestAirdropApi} of the Solana RPC API */\n    rpc: Rpc<GetSignatureStatusesApi & RequestAirdropApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to airdrop a certain amount of {@link Lamports} to a Solana\n * address.\n *\n * > [!NOTE] This only works on test clusters.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { address, airdropFactory, createSolanaRpc, createSolanaRpcSubscriptions, devnet, lamports } from '@solana/kit';\n *\n * const rpc = createSolanaRpc(devnet('http://127.0.0.1:8899'));\n * const rpcSubscriptions = createSolanaRpcSubscriptions(devnet('ws://127.0.0.1:8900'));\n *\n * const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n *\n * await airdrop({\n *     commitment: 'confirmed',\n *     recipientAddress: address('FnHyam9w4NZoWR6mKN1CuGBritdsEWZQa4Z4oawLZGxa'),\n *     lamports: lamports(10_000_000n),\n * });\n * ```\n */\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'devnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'mainnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'testnet'>): AirdropFunction;\nexport function airdropFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: AirdropFactoryConfig<TCluster>): AirdropFunction {\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmSignatureOnlyTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmationUntilTimeout({\n            ...config,\n            getRecentSignatureConfirmationPromise,\n            getTimeoutPromise,\n        });\n    }\n    return async function airdrop(config) {\n        return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmSignatureOnlyTransaction,\n            rpc,\n        });\n    };\n}\n","import {\n    assertAccountsDecoded,\n    assertAccountsExist,\n    type FetchAccountsConfig,\n    fetchJsonParsedAccounts,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport { type AddressesByLookupTableAddress } from '@solana/transaction-messages';\n\ntype FetchedAddressLookup = {\n    addresses: Address[];\n};\n\n/**\n * Given a list of addresses belonging to address lookup tables, returns a map of lookup table\n * addresses to an ordered array of the addresses they contain.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function fetchAddressesForLookupTables(\n    lookupTableAddresses: Address[],\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: FetchAccountsConfig,\n): Promise<AddressesByLookupTableAddress> {\n    if (lookupTableAddresses.length === 0) {\n        return {};\n    }\n\n    const fetchedLookupTables = await fetchJsonParsedAccounts<FetchedAddressLookup[]>(\n        rpc,\n        lookupTableAddresses,\n        config,\n    );\n\n    assertAccountsDecoded(fetchedLookupTables);\n    assertAccountsExist(fetchedLookupTables);\n\n    return fetchedLookupTables.reduce<AddressesByLookupTableAddress>((acc, lookup) => {\n        return {\n            ...acc,\n            [lookup.address]: lookup.data.addresses,\n        };\n    }, {});\n}\n","import { type FetchAccountsConfig } from '@solana/accounts';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    decompileTransactionMessage,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithLifetime,\n} from '@solana/transaction-messages';\n\nimport { fetchAddressesForLookupTables } from './fetch-lookup-tables';\n\ntype DecompileTransactionMessageFetchingLookupTablesConfig = FetchAccountsConfig & {\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Returns a {@link TransactionMessage} from a {@link CompiledTransactionMessage}. If any of the\n * accounts in the compiled message require an address lookup table to find their address, this\n * function will use the supplied RPC instance to fetch the contents of the address lookup table\n * from the network.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: DecompileTransactionMessageFetchingLookupTablesConfig,\n): Promise<TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime> {\n    const lookupTables =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? compiledTransactionMessage.addressTableLookups\n            : [];\n    const lookupTableAddresses = lookupTables.map(l => l.lookupTableAddress);\n\n    const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};\n    const addressesByLookupTableAddress =\n        lookupTableAddresses.length > 0\n            ? await fetchAddressesForLookupTables(lookupTableAddresses, rpc, fetchAccountsConfig)\n            : {};\n\n    return decompileTransactionMessage(compiledTransactionMessage, {\n        addressesByLookupTableAddress,\n        lastValidBlockHeight,\n    });\n}\n","import type { Lamports } from '@solana/rpc-types';\n\n/**\n * Calculates the minimum {@link Lamports | lamports} required to make an account rent exempt for a\n * given data size, without performing an RPC call.\n *\n * Values are sourced from the on-chain rent parameters in the Solana runtime:\n * https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n *\n * Note that this logic may change, or be incorrect depending on the cluster you are connected to.\n * You can always use the RPC method `getMinimumBalanceForRentExemption` to get the current value.\n *\n * @param space The number of bytes of account data.\n */\nexport function getMinimumBalanceForRentExemption(space: bigint): Lamports {\n    const RENT = {\n        ACCOUNT_STORAGE_OVERHEAD: 128n,\n        DEFAULT_EXEMPTION_THRESHOLD: 2n,\n        DEFAULT_LAMPORTS_PER_BYTE_YEAR: 3_480n,\n    } as const;\n    const requiredLamports =\n        (RENT.ACCOUNT_STORAGE_OVERHEAD + space) *\n        RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n        RENT.DEFAULT_EXEMPTION_THRESHOLD;\n    return requiredLamports as Lamports;\n}\n","import type { Signature } from '@solana/keys';\nimport type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { Commitment, commitmentComparator } from '@solana/rpc-types';\nimport {\n    TransactionWithLastValidBlockHeight,\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    getBase64EncodedWireTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\ninterface SendAndConfirmDurableNonceTransactionConfig\n    extends SendTransactionBaseConfig, SendTransactionConfigWithoutEncoding {\n    confirmDurableNonceTransaction: (\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: SendableTransaction & Transaction & TransactionWithDurableNonceLifetime;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n    extends SendTransactionBaseConfig, SendTransactionConfigWithoutEncoding {\n    confirmRecentTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: SendableTransaction & Transaction & TransactionWithLastValidBlockHeight;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    rpc: Rpc<SendTransactionApi>;\n    transaction: SendableTransaction & Transaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n    NonNullable<Parameters<SendTransactionApi['sendTransaction']>[1]>,\n    'encoding'\n>;\n\nfunction getSendTransactionConfigWithAdjustedPreflightCommitment(\n    commitment: Commitment,\n    config?: SendTransactionConfigWithoutEncoding,\n): SendTransactionConfigWithoutEncoding | void {\n    if (\n        // The developer has supplied no value for `preflightCommitment`.\n        !config?.preflightCommitment &&\n        // The value of `commitment` is lower than the server default of `preflightCommitment`.\n        commitmentComparator(commitment, 'finalized' /* default value of `preflightCommitment` */) < 0\n    ) {\n        return {\n            ...config,\n            // In the common case, it is unlikely that you want to simulate a transaction at\n            // `finalized` commitment when your standard of commitment for confirming the\n            // transaction is lower. Cap the simulation commitment level to the level of the\n            // confirmation commitment.\n            preflightCommitment: commitment,\n        };\n    }\n    // The commitment at which the developer wishes to confirm the transaction is at least as\n    // high as the commitment at which they want to simulate it. Honour the config as-is.\n    return config;\n}\n\nexport async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendTransactionBaseConfig): Promise<Signature> {\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);\n    return await rpc\n        .sendTransaction(base64EncodedWireTransaction, {\n            ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),\n            encoding: 'base64',\n        })\n        .send({ abortSignal });\n}\n\nexport async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmDurableNonceTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmDurableNonceTransactionConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmDurableNonceTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n\nexport async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmRecentTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmTransactionWithBlockhashLifetimeConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmRecentTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n","import { getSolanaErrorFromTransactionError, isSolanaError, SOLANA_ERROR__INVALID_NONCE } from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport type { GetAccountInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { commitmentComparator } from '@solana/rpc-types';\nimport {\n    createNonceInvalidationPromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForDurableNonceTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    getSignatureFromTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\nimport { sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmDurableNonceTransactionFunction = (\n    transaction: SendableTransaction & Transaction & TransactionWithDurableNonceLifetime,\n    config: Omit<\n        Parameters<typeof sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmDurableNonceTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetAccountInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link AccountNotificationsApi} and the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi & SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a nonce-based transaction to the network and to wait\n * until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     isSolanaError,\n *     sendAndConfirmDurableNonceTransactionFactory,\n *     SOLANA_ERROR__INVALID_NONCE,\n *     SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n * } from '@solana/kit';\n *\n * const sendAndConfirmNonceTransaction = sendAndConfirmDurableNonceTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmNonceTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n *         console.error(\n *             'The lifetime specified by this transaction refers to a nonce account ' +\n *                 `\\`${e.context.nonceAccountAddress}\\` that does not exist`,\n *         );\n *     } else if (isSolanaError(e, SOLANA_ERROR__INVALID_NONCE)) {\n *         console.error('This transaction depends on a nonce that is no longer valid');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'devnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'testnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'mainnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster>): SendAndConfirmDurableNonceTransactionFunction {\n    const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc, rpcSubscriptions } as Parameters<\n        typeof createNonceInvalidationPromiseFactory\n    >[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n\n    /**\n     * Creates a wrapped version of getNonceInvalidationPromise that handles the race condition\n     * where the nonce account update notification arrives before the signature confirmation.\n     *\n     * When the nonce changes, we check if our transaction actually landed on-chain.\n     * If it did, we don't throw - letting the signature confirmation promise continue.\n     */\n    function createNonceInvalidationPromiseHandlingRaceCondition(\n        signature: Signature,\n    ): typeof getNonceInvalidationPromise {\n        return async function wrappedGetNonceInvalidationPromise(config) {\n            try {\n                return await getNonceInvalidationPromise(config);\n            } catch (e) {\n                // If nonce became invalid, check if our transaction actually landed\n                if (isSolanaError(e, SOLANA_ERROR__INVALID_NONCE)) {\n                    let status;\n                    try {\n                        const { value: statuses } = await rpc\n                            .getSignatureStatuses([signature])\n                            .send({ abortSignal: config.abortSignal });\n                        status = statuses[0];\n                    } catch {\n                        // RPC failed - propagate the original nonce error\n                        throw e;\n                    }\n\n                    if (status === null || status === undefined) {\n                        // Transaction doesn't exist - nonce was truly invalid\n                        throw e;\n                    }\n\n                    // Check if status meets required commitment\n                    if (\n                        status.confirmationStatus !== null &&\n                        commitmentComparator(status.confirmationStatus, config.commitment) >= 0\n                    ) {\n                        // Transaction failed on-chain, throw the error from the transaction\n                        if (status.err !== null) {\n                            throw getSolanaErrorFromTransactionError(status.err);\n                        }\n                        // Transaction succeeded, resolve the promise successfully\n                        return;\n                    }\n\n                    // Commitment not met yet - return a never-resolving promise\n                    // This lets the signature confirmation promise continue\n                    return await new Promise(() => {});\n                }\n                throw e;\n            }\n        };\n    }\n\n    async function confirmDurableNonceTransaction(\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        const wrappedGetNonceInvalidationPromise = createNonceInvalidationPromiseHandlingRaceCondition(\n            getSignatureFromTransaction(config.transaction),\n        );\n\n        await waitForDurableNonceTransactionConfirmation({\n            ...config,\n            getNonceInvalidationPromise: wrappedGetNonceInvalidationPromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmDurableNonceTransaction(transaction, config) {\n        await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmDurableNonceTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { GetEpochInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createBlockHeightExceedencePromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    TransactionWithLastValidBlockHeight,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { SendableTransaction, Transaction } from '@solana/transactions';\n\nimport { sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFunction = (\n    transaction: SendableTransaction & Transaction & TransactionWithLastValidBlockHeight,\n    config: Omit<\n        Parameters<typeof sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmRecentTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} and the {@link SlotNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a blockhash-based transaction to the network and to\n * wait until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, sendAndConfirmTransactionFactory, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED } from '@solana/kit';\n *\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n *         console.error('This transaction depends on a blockhash that has expired');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'devnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'testnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'mainnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster>): SendAndConfirmTransactionWithBlockhashLifetimeFunction {\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmRecentTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmation({\n            ...config,\n            getBlockHeightExceedencePromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmTransaction(transaction, config) {\n        await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmRecentTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { SendableTransaction, Transaction } from '@solana/transactions';\n\nimport { sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendTransactionWithoutConfirmingFunction = (\n    transaction: SendableTransaction & Transaction,\n    config: Omit<Parameters<typeof sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0], 'rpc' | 'transaction'>,\n) => Promise<void>;\n\ninterface SendTransactionWithoutConfirmingFactoryConfig {\n    /** An object that supports the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<SendTransactionApi>;\n}\n\n/**\n * Returns a function that you can call to send a transaction with any kind of lifetime to the\n * network without waiting for it to be confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     sendTransactionWithoutConfirmingFactory,\n *     SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n * } from '@solana/kit';\n *\n * const sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\n *\n * try {\n *     await sendTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE)) {\n *         console.error('The transaction failed in simulation', e.cause);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendTransactionWithoutConfirmingFactory({\n    rpc,\n}: SendTransactionWithoutConfirmingFactoryConfig): SendTransactionWithoutConfirmingFunction {\n    return async function sendTransactionWithoutConfirming(transaction, config) {\n        await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transaction,\n        });\n    };\n}\n"]}