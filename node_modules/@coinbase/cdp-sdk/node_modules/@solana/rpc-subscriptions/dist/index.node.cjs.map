{"version":3,"sources":["../src/rpc-integer-overflow-error.ts","../src/rpc-default-config.ts","../../event-target-impl/src/index.node.ts","../src/rpc-subscriptions-autopinger.ts","../src/rpc-subscriptions-channel-pool-internal.ts","../src/rpc-subscriptions-channel-pool.ts","../src/rpc-subscriptions-json.ts","../src/rpc-subscriptions-json-bigint.ts","../src/rpc-subscriptions-channel.ts","../src/rpc-subscriptions-coalescer.ts","../src/rpc-subscriptions-transport.ts","../src/rpc-subscriptions.ts"],"names":["SolanaError","SOLANA_ERROR__RPC__INTEGER_OVERFLOW","safeCaptureStackTrace","AbortController","args","setMaxListeners","e","isSolanaError","SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED","pipe","transformChannelInboundMessages","transformChannelOutboundMessages","parseJsonWithBigInts","stringifyJsonWithBigInts","createWebSocketChannel","fastStableStringify","createSubscriptionRpc","createSolanaRpcSubscriptionsApi"],"mappings":";;;;;;;;;;;;;;;;AAGO,SAAS,uCAAA,CACZ,UAAA,EACA,OAAA,EACA,KAAA,EACuD;AACvD,EAAA,IAAI,aAAA,GAAgB,EAAA;AACpB,EAAA,IAAI,OAAO,OAAA,CAAQ,CAAC,CAAA,KAAM,QAAA,EAAU;AAChC,IAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,CAAC,CAAA,GAAI,CAAA;AACjC,IAAA,MAAM,YAAY,WAAA,GAAc,EAAA;AAChC,IAAA,MAAM,gBAAgB,WAAA,GAAc,GAAA;AACpC,IAAA,IAAI,SAAA,IAAa,CAAA,IAAK,aAAA,IAAiB,EAAA,EAAI;AACvC,MAAA,aAAA,GAAgB,WAAA,GAAc,IAAA;AAAA,IAClC,CAAA,MAAA,IAAW,SAAA,IAAa,CAAA,IAAK,aAAA,IAAiB,EAAA,EAAI;AAC9C,MAAA,aAAA,GAAgB,WAAA,GAAc,IAAA;AAAA,IAClC,CAAA,MAAA,IAAW,SAAA,IAAa,CAAA,IAAK,aAAA,IAAiB,EAAA,EAAI;AAC9C,MAAA,aAAA,GAAgB,WAAA,GAAc,IAAA;AAAA,IAClC,CAAA,MAAO;AACH,MAAA,aAAA,GAAgB,WAAA,GAAc,IAAA;AAAA,IAClC;AAAA,EACJ,CAAA,MAAO;AACH,IAAA,aAAA,GAAgB,CAAA,EAAA,EAAK,OAAA,CAAQ,CAAC,CAAA,CAAE,UAAU,CAAA,EAAA,CAAA;AAAA,EAC9C;AACA,EAAA,MAAM,IAAA,GACF,QAAQ,MAAA,GAAS,CAAA,GACX,QACK,KAAA,CAAM,CAAC,EACP,GAAA,CAAI,CAAA,QAAA,KAAa,OAAO,QAAA,KAAa,QAAA,GAAW,IAAI,QAAQ,CAAA,CAAA,CAAA,GAAM,QAAS,CAAA,CAC3E,IAAA,CAAK,GAAG,CAAA,GACb,MAAA;AACV,EAAA,MAAM,KAAA,GAAQ,IAAIA,kBAAA,CAAYC,0CAAA,EAAqC;AAAA,IAC/D,aAAA;AAAA,IACA,OAAA;AAAA,IACA,UAAA;AAAA,IACA,iBAAA,EAAmB,IAAA,GAAO,CAAA,WAAA,EAAc,IAAI,CAAA,EAAA,CAAA,GAAO,EAAA;AAAA,IACnD,KAAA;AAAA,IACA,GAAI,IAAA,KAAS,MAAA,GAAY,EAAE,MAAK,GAAI;AAAA,GACvC,CAAA;AACD,EAAAC,4BAAA,CAAsB,OAAO,uCAAuC,CAAA;AACpE,EAAA,OAAO,KAAA;AACX;;;ACtCO,IAAM,gCAAA,GAET;AAAA,EACA,iBAAA,EAAmB,WAAA;AAAA,EACnB,iBAAA,CAAkB,OAAA,EAAS,OAAA,EAAS,KAAA,EAAO;AACvC,IAAA,MAAM,uCAAA,CAAwC,OAAA,CAAQ,UAAA,EAAY,OAAA,EAAS,KAAK,CAAA;AAAA,EACpF;AACJ;ICTaC,CAAAA,GAAkB,cAAc,WAAW,eAAA,CAAgB;AACpE,EAAA,WAAA,CAAA,GAAeC,CAAAA,EAAgE;AAC3E,IAAA,KAAA,CAAM,GAAGA,CAAI,CAAA,EACbC,uBAAgB,MAAA,CAAO,gBAAA,EAAkB,KAAK,MAAM,CAAA;AACxD,EAAA;AACJ,CAAA;;;ACGA,IAAM,YAAA,GAAe;AAAA,EACjB,OAAA,EAAS,KAAA;AAAA,EACT,MAAA,EAAQ;AACZ,CAAA;AAQO,SAAS,sCAAA,CAAkG;AAAA,EAC9G,WAAA,EAAa,iBAAA;AAAA,EACb,OAAA;AAAA,EACA;AACJ,CAAA,EAA+B;AAC3B,EAAA,IAAI,UAAA;AACJ,EAAA,SAAS,QAAA,GAAW;AAChB,IAAA,OAAA,CAAQ,IAAA,CAAK,YAAY,CAAA,CAAE,KAAA,CAAM,CAACC,EAAAA,KAAe;AAC7C,MAAA,IAAIC,oBAAA,CAAcD,EAAAA,EAAGE,iEAA0D,CAAA,EAAG;AAC9E,QAAA,qBAAA,CAAsB,KAAA,EAAM;AAAA,MAChC;AAAA,IACJ,CAAC,CAAA;AAAA,EACL;AACA,EAAA,SAAS,gBAAA,GAAmB;AACxB,IAAA,aAAA,CAAc,UAAU,CAAA;AACxB,IAAA,UAAA,GAAa,WAAA,CAAY,UAAU,UAAU,CAAA;AAAA,EACjD;AACA,EAAA,MAAM,qBAAA,GAAwB,IAAI,CAAA,EAAgB;AAClD,EAAA,qBAAA,CAAsB,MAAA,CAAO,gBAAA,CAAiB,OAAA,EAAS,MAAM;AACzD,IAAA,aAAA,CAAc,UAAU,CAAA;AAAA,EAC5B,CAAC,CAAA;AACD,EAAA,iBAAA,CAAkB,gBAAA,CAAiB,SAAS,MAAM;AAC9C,IAAA,qBAAA,CAAsB,KAAA,EAAM;AAAA,EAChC,CAAC,CAAA;AACD,EAAA,OAAA,CAAQ,EAAA;AAAA,IACJ,OAAA;AAAA,IACA,MAAM;AACF,MAAA,qBAAA,CAAsB,KAAA,EAAM;AAAA,IAChC,CAAA;AAAA,IACA,EAAE,MAAA,EAAQ,qBAAA,CAAsB,MAAA;AAAO,GAC3C;AACA,EAAA,OAAA,CAAQ,GAAG,SAAA,EAAW,gBAAA,EAAkB,EAAE,MAAA,EAAQ,qBAAA,CAAsB,QAAQ,CAAA;AAChF,EAAiD;AAC7C,IAAA,gBAAA,EAAiB;AAAA,EACrB;AAkBA,EAAA,OAAO;AAAA,IACH,GAAG,OAAA;AAAA,IACH,QAAQ,IAAA,EAAM;AACV,MAAA,IAAI,CAAC,qBAAA,CAAsB,MAAA,CAAO,OAAA,EAAS;AACvC,QAAA,gBAAA,EAAiB;AAAA,MACrB;AACA,MAAA,OAAO,OAAA,CAAQ,IAAA,CAAK,GAAG,IAAI,CAAA;AAAA,IAC/B;AAAA,GACJ;AACJ;;;ACxEO,SAAS,iBAAA,GAAiC;AAC7C,EAAA,OAAO;AAAA,IACH,SAAS,EAAC;AAAA,IACV,gBAAA,EAAkB;AAAA,GACtB;AACJ;;;ACUO,SAAS,+BAAA,CAEd,aAAA,EAAgC,EAAE,0BAAA,EAA4B,aAAY,EAA4B;AACpG,EAAA,MAAM,OAAO,iBAAA,EAAkB;AAK/B,EAAA,SAAS,yBAAA,GAA4B;AACjC,IAAA,IAAI,IAAA,CAAK,OAAA,CAAQ,MAAA,GAAS,WAAA,EAAa;AAGnC,MAAA,IAAA,CAAK,gBAAA,GAAmB,EAAA;AACxB,MAAA;AAAA,IACJ;AACA,IAAA,IAAI,eAAA;AACJ,IAAA,KAAA,IAAS,KAAK,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,OAAA,CAAQ,QAAQ,EAAA,EAAA,EAAM;AAC7C,MAAA,MAAM,iBAAiB,IAAA,CAAK,gBAAA,GAAmB,EAAA,GAAK,CAAA,IAAK,KAAK,OAAA,CAAQ,MAAA;AACtE,MAAA,MAAM,aAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAKF,IAAA,CAAK,QAAQ,aAAa;AAAA,OAAA;AAC9B,MAAA,IACI,aAAA,CAAc,oBAAoB,0BAAA,KACjC,CAAC,mBAAmB,eAAA,CAAgB,iBAAA,IAAqB,cAAc,iBAAA,CAAA,EAC1E;AACE,QAAA,eAAA,GAAkB;AAAA,UACd,SAAA,EAAW,aAAA;AAAA,UACX,mBAAmB,aAAA,CAAc;AAAA,SACrC;AAAA,MACJ;AAAA,IACJ;AACA,IAAA,IAAA,CAAK,gBAAA,GAAmB,iBAAiB,SAAA,IAAa,EAAA;AAAA,EAC1D;AACA,EAAA,OAAO,SAAS,iDAAA,CAAkD,EAAE,WAAA,EAAY,EAAG;AAC/E,IAAA,IAAI,SAAA;AACJ,IAAA,SAAS,gBAAA,GAAmB;AACxB,MAAA,MAAM,QAAQ,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,CAAA,KAAA,KAAS,UAAU,SAAS,CAAA;AACjE,MAAA,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,KAAA,EAAO,CAAC,CAAA;AAC5B,MAAA,SAAA,CAAU,OAAA,EAAQ;AAClB,MAAA,yBAAA,EAA0B;AAAA,IAC9B;AACA,IAAA,IAAI,IAAA,CAAK,qBAAqB,EAAA,EAAI;AAC9B,MAAA,MAAM,eAAA,GAAkB,IAAI,CAAA,EAAgB;AAC5C,MAAA,MAAM,oBAAoB,aAAA,CAAc,EAAE,WAAA,EAAa,eAAA,CAAgB,QAAQ,CAAA;AAC/E,MAAA,iBAAA,CACK,KAAK,CAAA,UAAA,KAAc;AAChB,QAAA,UAAA,CAAW,GAAG,OAAA,EAAS,gBAAA,EAAkB,EAAE,MAAA,EAAQ,eAAA,CAAgB,QAAQ,CAAA;AAAA,MAC/E,CAAC,CAAA,CACA,KAAA,CAAM,gBAAgB,CAAA;AAC3B,MAAA,SAAA,GAAY;AAAA,QACR,OAAA,EAAS,iBAAA;AAAA,QACT,OAAA,GAAU;AACN,UAAA,eAAA,CAAgB,KAAA,EAAM;AAAA,QAC1B,CAAA;AAAA,QACA,iBAAA,EAAmB;AAAA,OACvB;AACA,MAAA,IAAA,CAAK,OAAA,CAAQ,KAAK,SAAS,CAAA;AAAA,IAC/B,CAAA,MAAO;AACH,MAAA,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,gBAAgB,CAAA;AAAA,IAClD;AAWA,IAAA,SAAA,CAAU,iBAAA,EAAA;AACV,IAAA,WAAA,CAAY,gBAAA,CAAiB,OAAA,EAAS,SAAS,eAAA,GAAkB;AAC7D,MAAA,SAAA,CAAU,iBAAA,EAAA;AACV,MAAA,IAAI,SAAA,CAAU,sBAAsB,CAAA,EAAG;AACnC,QAAA,gBAAA,EAAiB;AAAA,MACrB,CAAA,MAAA,IAAW,IAAA,CAAK,gBAAA,KAAqB,EAAA,EAAI;AAErC,QAAA,IAAA,CAAK,gBAAA,EAAA;AACL,QAAA,yBAAA,EAA0B;AAAA,MAC9B;AAAA,IACJ,CAAC,CAAA;AACD,IAAA,yBAAA,EAA0B;AAC1B,IAAA,OAAO,SAAA,CAAU,OAAA;AAAA,EACrB,CAAA;AACJ;ACpGO,SAAS,gDACZ,OAAA,EACyC;AACzC,EAAA,OAAOC,eAAA;AAAA,IACH,OAAA;AAAA,IACA,CAAA,CAAA,KAAKC,oDAAA,CAAgC,CAAA,EAAG,IAAA,CAAK,KAAK,CAAA;AAAA,IAClD,CAAA,CAAA,KAAKC,qDAAA,CAAiC,CAAA,EAAG,IAAA,CAAK,SAAS;AAAA,GAC3D;AACJ;ACLO,SAAS,sDACZ,OAAA,EACyC;AACzC,EAAA,OAAOF,eAAAA;AAAA,IACH,OAAA;AAAA,IACA,CAAA,CAAA,KAAKC,oDAAAA,CAAgC,CAAA,EAAGE,iCAAoB,CAAA;AAAA,IAC5D,CAAA,CAAA,KAAKD,qDAAAA,CAAiC,CAAA,EAAGE,qCAAwB;AAAA,GACrE;AACJ;;;ACsBO,SAAS,kDACZ,MAAA,EAC2E;AAC3E,EAAA,OAAO,+CAAA,CAAgD;AAAA,IACnD,GAAG,MAAA;AAAA,IACH,cAAA,EAAgB;AAAA,GACnB,CAAA;AACL;AAKO,SAAS,4CACZ,MAAA,EAC2E;AAC3E,EAAA,OAAO,+CAAA,CAAgD;AAAA,IACnD,GAAG,MAAA;AAAA,IACH,cAAA,EAAgB;AAAA,GACnB,CAAA;AACL;AAEA,SAAS,gDACL,MAAA,EAG2E;AAC3E,EAAA,IAAI,SAAA,CAAU,IAAA,CAAK,MAAA,CAAO,GAAG,MAAM,KAAA,EAAO;AACtC,IAAA,MAAM,aAAA,GAAgB,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,WAAW,CAAA;AAClD,IAAA,MAAM,IAAI,YAAA;AAAA,MACN,aAAA,GACM,oFACe,aAAA,CAAc,CAAC,CAAC,CAAA,kBAAA,CAAA,GAC/B,CAAA,0CAAA,EAA6C,OAAO,GAAG,CAAA,aAAA;AAAA,KACjE;AAAA,EACJ;AACA,EAAA,MAAM,EAAE,UAAA,EAAY,GAAG,IAAA,EAAK,GAAI,MAAA;AAChC,EAAA,MAAM,oCAAA,IAAwC,CAAC,EAAE,WAAA,EAAY,KAAM;AAC/D,IAAA,OAAOC,uDAAA,CAAuB;AAAA,MAC1B,GAAG,IAAA;AAAA,MACH,yBACI,MAAA,CAAO,uBAAA;AAAA,MAEP,MAAA;AAAA,MACJ,MAAA,EAAQ;AAAA,KACX,CAAA,CACI,IAAA,CAAK,MAAA,CAAO,cAAc,CAAA,CAC1B,IAAA;AAAA,MAAK,aACF,sCAAA,CAAuC;AAAA,QACnC,WAAA;AAAA,QACA,OAAA;AAAA,QACA,YAAY,UAAA,IAAc;AAAA,OAC7B;AAAA,KACL;AAAA,EACR,CAAA,CAAA;AACA,EAAA,OAAO,gCAAgC,oCAAA,EAAsC;AAAA,IACzE,4BACI,MAAA,CAAO,0BAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASP,GAAA;AAAA,IACJ,WAAA,EAAa,OAAO,WAAA,IAAe;AAAA,GACtC,CAAA;AACL;AC/FO,SAAS,uDACZ,SAAA,EACU;AACV,EAAA,MAAM,KAAA,uBAAY,GAAA,EAAwB;AAC1C,EAAA,OAAO,SAAS,oDAAoD,MAAA,EAAQ;AACxE,IAAA,MAAM,EAAE,OAAA,EAAS,MAAA,EAAO,GAAI,MAAA;AAC5B,IAAA,MAAM,gCAAgCC,oCAAA,CAAoB,CAAC,QAAQ,UAAA,EAAY,OAAA,CAAQ,MAAM,CAAC,CAAA;AAE9F,IAAA,IAAI,0BAAA,GAA6B,KAAA,CAAM,GAAA,CAAI,6BAA6B,CAAA;AACxE,IAAA,IAAI,CAAC,0BAAA,EAA4B;AAC7B,MAAA,MAAM,eAAA,GAAkB,IAAI,CAAA,EAAgB;AAC5C,MAAA,MAAM,uBAAuB,SAAA,CAAU;AAAA,QACnC,GAAG,MAAA;AAAA,QACH,QAAQ,eAAA,CAAgB;AAAA,OAC3B,CAAA;AACD,MAAA,oBAAA,CACK,KAAK,CAAA,aAAA,KAAiB;AACnB,QAAA,aAAA,CAAc,EAAA;AAAA,UACV,OAAA;AAAA,UACA,MAAM;AACF,YAAA,KAAA,CAAM,OAAO,6BAA6B,CAAA;AAC1C,YAAA,eAAA,CAAgB,KAAA,EAAM;AAAA,UAC1B,CAAA;AAAA,UACA,EAAE,MAAA,EAAQ,eAAA,CAAgB,MAAA;AAAO,SACrC;AAAA,MACJ,CAAC,CAAA,CACA,KAAA,CAAM,MAAM;AAAA,MAAC,CAAC,CAAA;AACnB,MAAA,KAAA,CAAM,GAAA;AAAA,QACF,6BAAA;AAAA,QACC,0BAAA,GAA6B;AAAA,UAC1B,eAAA;AAAA,UACA,oBAAA;AAAA,UACA,cAAA,EAAgB;AAAA;AACpB,OACJ;AAAA,IACJ;AACA,IAAA,0BAAA,CAA2B,cAAA,EAAA;AAC3B,IAAA,MAAA,CAAO,gBAAA;AAAA,MACH,OAAA;AAAA,MACA,MAAM;AACF,QAAA,0BAAA,CAA2B,cAAA,EAAA;AAC3B,QAAA,IAAI,0BAAA,CAA2B,mBAAmB,CAAA,EAAG;AACjD,UAAA,cAAA,CAAe,MAAM;AACjB,YAAA,IAAI,0BAAA,CAA2B,mBAAmB,CAAA,EAAG;AACjD,cAAA,KAAA,CAAM,OAAO,6BAA6B,CAAA;AAC1C,cAAA,0BAAA,CAA2B,gBAAgB,KAAA,EAAM;AAAA,YACrD;AAAA,UACJ,CAAC,CAAA;AAAA,QACL;AAAA,MACJ,CAAA;AAAA,MACA,EAAE,MAAA,EAAQ,0BAAA,CAA2B,eAAA,CAAgB,MAAA;AAAO,KAChE;AACA,IAAA,OAAO,0BAAA,CAA2B,oBAAA;AAAA,EACtC,CAAA;AACJ;AC3CO,SAAS,sCAAA,CAAuE;AAAA,EACnF;AACJ,CAAA,EAAwD;AACpD,EAAA,OAAON,eAAAA;AAAA,IACH,iDAAA;AAAA,MACI;AAAA,KACJ;AAAA,IACA,CAAA,SAAA,KAAa,uDAAuD,SAAS;AAAA,GACjF;AACJ;AAEO,SAAS,kDAId,aAAA,EAAgC;AAC9B,EAAA,QAAQ,OAAO,EAAE,OAAA,EAAS,MAAA,EAAO,KAAM;AACnC,IAAA,MAAM,UAAU,MAAM,aAAA,CAAc,EAAE,WAAA,EAAa,QAAQ,CAAA;AAC3D,IAAA,OAAO,MAAM,OAAA,CAAQ,EAAE,OAAA,EAAS,QAAQ,CAAA;AAAA,EAC5C,CAAA;AAOJ;ACpCA,SAAS,gCAAA,CACL,YACA,MAAA,EACF;AACE,EAAA,MAAM,YAAY,sCAAA,CAAuC;AAAA,IACrD,eAAe,iDAAA,CAAkD,EAAE,GAAG,MAAA,EAAQ,GAAA,EAAK,YAAY;AAAA,GAClG,CAAA;AACD,EAAA,OAAO,0CAAkE,SAAS,CAAA;AACtF;AAOO,SAAS,4BAAA,CACZ,YACA,MAAA,EACF;AACE,EAAA,OAAO,gCAAA,CAAyE,YAAY,MAAM,CAAA;AACtG;AAOO,SAAS,qCAAA,CACZ,YACA,MAAA,EACF;AACE,EAAA,OAAO,gCAAA;AAAA,IACH,UAAA;AAAA,IACA;AAAA,GACJ;AACJ;AAMO,SAAS,0CAGd,SAAA,EAAuB;AACrB,EAAA,OAAOO,0CAAA,CAAsB;AAAA,IACzB,GAAA,EAAKC,oDAAsC,gCAAgC,CAAA;AAAA,IAC3E;AAAA,GACH,CAAA;AACL","file":"index.node.cjs","sourcesContent":["import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import { setMaxListeners } from 'node:events';\n\nexport const AbortController = class extends globalThis.AbortController {\n    constructor(...args: ConstructorParameters<typeof globalThis.AbortController>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this.signal);\n    }\n};\n\nexport const EventTarget = class extends globalThis.EventTarget {\n    constructor(...args: ConstructorParameters<typeof globalThis.EventTarget>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this);\n    }\n};\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that sends a ping message to\n * the inner channel if a message has not been sent or received in the last `intervalMs`. In web\n * browsers, this implementation sends no ping when the network is down, and sends a ping\n * immediately upon the network coming back up.\n */\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\n/**\n * Given a channel creator, will return a new channel creator with the following behavior.\n *\n * 1. When called, returns a {@link RpcSubscriptionsChannel}. Adds that channel to a pool.\n * 2. When called again, creates and returns new\n *    {@link RpcSubscriptionChannel | RpcSubscriptionChannels} up to the number specified by\n *    `minChannels`.\n * 3. When `minChannels` channels have been created, subsequent calls vend whichever existing\n *    channel from the pool has the fewest subscribers, or the next one in rotation in the event of\n *    a tie.\n * 4. Once all channels carry the number of subscribers specified by the number\n *    `maxSubscriptionsPerChannel`, new channels in excess of `minChannel` will be created,\n *    returned, and added to the pool.\n * 5. A channel will be destroyed once all of its subscribers' abort signals fire.\n */\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that parses data published to\n * the `'message'` channel as JSON, and JSON-stringifies messages sent via the\n * {@link RpcSubscriptionsChannel.send | send(message)} method.\n */\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Similarly, to {@link getRpcSubscriptionsChannelWithJSONSerialization}, this function will\n * stringify and parse JSON message to and from the given `string` channel. However, this function\n * parses any integer value as a `BigInt` in order to safely handle numbers that exceed the\n * JavaScript [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n * value.\n */\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigInts),\n    );\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * The number of milliseconds to wait since the last message sent or received over the channel\n     * before sending a ping message to keep the channel open.\n     */\n    intervalMs?: number;\n    /**\n     * The number of subscribers that may share a channel before a new channel must be created.\n     *\n     * It is important that you set this to the maximum number of subscriptions that your RPC\n     * provider recommends making over a single connection; the default is set deliberately low, so\n     * as to comply with the restrictive limits of the public mainnet RPC node.\n     *\n     * @defaultValue 100\n     */\n    maxSubscriptionsPerChannel?: number;\n    /** The number of channels to create before reusing a channel for a new subscription. */\n    minChannels?: number;\n    /**\n     * The number of bytes of data to admit into the\n     * [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) buffer before\n     * buffering data on the client.\n     */\n    sendBufferHighWatermark?: number;\n    /** The URL of the web socket server. Must use the `ws` or `wss` protocols. */\n    url: TClusterUrl;\n}>;\n\n/**\n * Similar to {@link createDefaultRpcSubscriptionsChannelCreator} with some Solana-specific\n * defaults.\n *\n * For instance, it safely handles `BigInt` values in JSON messages since Solana RPC servers accept\n * and return integers larger than [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\n */\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\n/**\n * Creates a function that returns new subscription channels when called.\n */\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                      `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\n/**\n * Given a {@link RpcSubscriptionsTransport}, will return a new transport that coalesces identical\n * subscriptions into a single subscription request to the server. The determination of whether a\n * subscription is the same as another is based on the `rpcRequest` returned by its\n * {@link RpcSubscriptionsPlan}. The subscription will only be aborted once all subscribers abort,\n * or there is an error.\n */\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\n/**\n * Creates a {@link RpcSubscriptionsTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - Logic that coalesces multiple subscriptions for the same notifications with the same arguments\n *   into a single subscription.\n *\n * @param config\n */\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API,\n * including its unstable methods, given a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * the supplied {@link RpcSubscriptionsTransport}.\n */\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n"]}