{"version":3,"sources":["../../../src/http/index.ts","../../../src/utils/index.ts","../../../src/types/facilitator.ts","../../../src/index.ts","../../../src/http/x402HTTPResourceServer.ts","../../../src/http/httpFacilitatorClient.ts","../../../src/http/x402HTTPClient.ts"],"sourcesContent":["import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(paymentResponse: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n  ProtectedRequestHook,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient, PaymentRequiredContext, PaymentRequiredHook } from \"./x402HTTPClient\";\n","import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    const bytes = new TextEncoder().encode(data);\n    const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join(\"\");\n    return globalThis.btoa(binaryString);\n  }\n  return Buffer.from(data, \"utf8\").toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    const binaryString = globalThis.atob(data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    const decoder = new TextDecoder(\"utf-8\");\n    return decoder.decode(bytes);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"./payments\";\nimport { Network } from \"./\";\n\nexport type VerifyRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type VerifyResponse = {\n  isValid: boolean;\n  invalidReason?: string;\n  invalidMessage?: string;\n  payer?: string;\n  extensions?: Record<string, unknown>;\n};\n\nexport type SettleRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type SettleResponse = {\n  success: boolean;\n  errorReason?: string;\n  errorMessage?: string;\n  payer?: string;\n  transaction: string;\n  network: Network;\n  extensions?: Record<string, unknown>;\n};\n\nexport type SupportedKind = {\n  x402Version: number;\n  scheme: string;\n  network: Network;\n  extra?: Record<string, unknown>;\n};\n\nexport type SupportedResponse = {\n  kinds: SupportedKind[];\n  extensions: string[];\n  signers: Record<string, string[]>; // CAIP family pattern â†’ Signer addresses\n};\n\n/**\n * Error thrown when payment verification fails.\n */\nexport class VerifyError extends Error {\n  readonly invalidReason?: string;\n  readonly invalidMessage?: string;\n  readonly payer?: string;\n  readonly statusCode: number;\n\n  /**\n   * Creates a VerifyError from a failed verification response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The verify response containing error details\n   */\n  constructor(statusCode: number, response: VerifyResponse) {\n    const reason = response.invalidReason || \"unknown reason\";\n    const message = response.invalidMessage;\n    super(message ? `${reason}: ${message}` : reason);\n    this.name = \"VerifyError\";\n    this.statusCode = statusCode;\n    this.invalidReason = response.invalidReason;\n    this.invalidMessage = response.invalidMessage;\n    this.payer = response.payer;\n  }\n}\n\n/**\n * Error thrown when payment settlement fails.\n */\nexport class SettleError extends Error {\n  readonly errorReason?: string;\n  readonly errorMessage?: string;\n  readonly payer?: string;\n  readonly transaction: string;\n  readonly network: Network;\n  readonly statusCode: number;\n\n  /**\n   * Creates a SettleError from a failed settlement response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The settle response containing error details\n   */\n  constructor(statusCode: number, response: SettleResponse) {\n    const reason = response.errorReason || \"unknown reason\";\n    const message = response.errorMessage;\n    super(message ? `${reason}: ${message}` : reason);\n    this.name = \"SettleError\";\n    this.statusCode = statusCode;\n    this.errorReason = response.errorReason;\n    this.errorMessage = response.errorMessage;\n    this.payer = response.payer;\n    this.transaction = response.transaction;\n    this.network = response.network;\n  }\n}\n","export const x402Version = 2;\n","import { x402ResourceServer } from \"../server\";\nimport {\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n} from \".\";\nimport {\n  PaymentPayload,\n  PaymentRequired,\n  SettleResponse,\n  SettleError,\n  Price,\n  Network,\n  PaymentRequirements,\n} from \"../types\";\nimport { x402Version } from \"..\";\n\n/**\n * Framework-agnostic HTTP adapter interface\n * Implementations provide framework-specific HTTP operations\n */\nexport interface HTTPAdapter {\n  getHeader(name: string): string | undefined;\n  getMethod(): string;\n  getPath(): string;\n  getUrl(): string;\n  getAcceptHeader(): string;\n  getUserAgent(): string;\n\n  /**\n   * Get query parameters from the request URL\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams?(): Record<string, string | string[]>;\n\n  /**\n   * Get a specific query parameter by name\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam?(name: string): string | string[] | undefined;\n\n  /**\n   * Get the parsed request body\n   * Framework adapters should parse JSON/form data appropriately\n   *\n   * @returns The parsed request body\n   */\n  getBody?(): unknown;\n}\n\n/**\n * Paywall configuration for HTML responses\n */\nexport interface PaywallConfig {\n  appName?: string;\n  appLogo?: string;\n  sessionTokenEndpoint?: string;\n  currentUrl?: string;\n  testnet?: boolean;\n}\n\n/**\n * Paywall provider interface for generating HTML\n */\nexport interface PaywallProvider {\n  generateHtml(paymentRequired: PaymentRequired, config?: PaywallConfig): string;\n}\n\n/**\n * Dynamic payTo function that receives HTTP request context\n */\nexport type DynamicPayTo = (context: HTTPRequestContext) => string | Promise<string>;\n\n/**\n * Dynamic price function that receives HTTP request context\n */\nexport type DynamicPrice = (context: HTTPRequestContext) => Price | Promise<Price>;\n\n/**\n * Result of the unpaid response callback containing content type and body.\n */\nexport interface UnpaidResponseResult {\n  /**\n   * The content type for the response (e.g., 'application/json', 'text/plain').\n   */\n  contentType: string;\n\n  /**\n   * The response body to include in the 402 response.\n   */\n  body: unknown;\n}\n\n/**\n * Dynamic function to generate a custom response for unpaid requests.\n * Receives the HTTP request context and returns the content type and body to include in the 402 response.\n */\nexport type UnpaidResponseBody = (\n  context: HTTPRequestContext,\n) => UnpaidResponseResult | Promise<UnpaidResponseResult>;\n\n/**\n * A single payment option for a route\n * Represents one way a client can pay for access to the resource\n */\nexport interface PaymentOption {\n  scheme: string;\n  payTo: string | DynamicPayTo;\n  price: Price | DynamicPrice;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>;\n}\n\n/**\n * Route configuration for HTTP endpoints\n *\n * The 'accepts' field defines payment options for the route.\n * Can be a single PaymentOption or an array of PaymentOptions for multiple payment methods.\n */\nexport interface RouteConfig {\n  // Payment option(s): single or array\n  accepts: PaymentOption | PaymentOption[];\n\n  // HTTP-specific metadata\n  resource?: string;\n  description?: string;\n  mimeType?: string;\n  customPaywallHtml?: string;\n\n  /**\n   * Optional callback to generate a custom response for unpaid API requests.\n   * This allows servers to return preview data, error messages, or other content\n   * when a request lacks payment.\n   *\n   * For browser requests (Accept: text/html), the paywall HTML takes precedence.\n   * This callback is only used for API clients.\n   *\n   * If not provided, defaults to { contentType: 'application/json', body: {} }.\n   *\n   * @param context - The HTTP request context\n   * @returns An object containing both contentType and body for the 402 response\n   */\n  unpaidResponseBody?: UnpaidResponseBody;\n\n  // Extensions\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Routes configuration - maps path patterns to route configs\n */\nexport type RoutesConfig = Record<string, RouteConfig> | RouteConfig;\n\n/**\n * Hook that runs on every request to a protected route, before payment processing.\n * Can grant access without payment, deny the request, or continue to payment flow.\n *\n * @returns\n * - `void` - Continue to payment processing (default behavior)\n * - `{ grantAccess: true }` - Grant access without requiring payment\n * - `{ abort: true; reason: string }` - Deny the request (returns 403)\n */\nexport type ProtectedRequestHook = (\n  context: HTTPRequestContext,\n  routeConfig: RouteConfig,\n) => Promise<void | { grantAccess: true } | { abort: true; reason: string }>;\n\n/**\n * Compiled route for efficient matching\n */\nexport interface CompiledRoute {\n  verb: string;\n  regex: RegExp;\n  config: RouteConfig;\n}\n\n/**\n * HTTP request context that encapsulates all request data\n */\nexport interface HTTPRequestContext {\n  adapter: HTTPAdapter;\n  path: string;\n  method: string;\n  paymentHeader?: string;\n}\n\n/**\n * HTTP response instructions for the framework middleware\n */\nexport interface HTTPResponseInstructions {\n  status: number;\n  headers: Record<string, string>;\n  body?: unknown; // e.g. Paywall for web browser requests, but could be any other type\n  isHtml?: boolean; // e.g. if body is a paywall, then isHtml is true\n}\n\n/**\n * Result of processing an HTTP request for payment\n */\nexport type HTTPProcessResult =\n  | { type: \"no-payment-required\" }\n  | {\n      type: \"payment-verified\";\n      paymentPayload: PaymentPayload;\n      paymentRequirements: PaymentRequirements;\n      declaredExtensions?: Record<string, unknown>;\n    }\n  | { type: \"payment-error\"; response: HTTPResponseInstructions };\n\n/**\n * Result of processSettlement\n */\nexport type ProcessSettleSuccessResponse = SettleResponse & {\n  success: true;\n  headers: Record<string, string>;\n  requirements: PaymentRequirements;\n};\n\nexport type ProcessSettleFailureResponse = SettleResponse & {\n  success: false;\n  errorReason: string;\n  errorMessage?: string;\n};\n\nexport type ProcessSettleResultResponse =\n  | ProcessSettleSuccessResponse\n  | ProcessSettleFailureResponse;\n\n/**\n * Represents a validation error for a specific route's payment configuration.\n */\nexport interface RouteValidationError {\n  /** The route pattern (e.g., \"GET /api/weather\") */\n  routePattern: string;\n  /** The payment scheme that failed validation */\n  scheme: string;\n  /** The network that failed validation */\n  network: Network;\n  /** The type of validation failure */\n  reason: \"missing_scheme\" | \"missing_facilitator\";\n  /** Human-readable error message */\n  message: string;\n}\n\n/**\n * Error thrown when route configuration validation fails.\n */\nexport class RouteConfigurationError extends Error {\n  /** The validation errors that caused this exception */\n  public readonly errors: RouteValidationError[];\n\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors: RouteValidationError[]) {\n    const message = `x402 Route Configuration Errors:\\n${errors.map(e => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n}\n\n/**\n * HTTP-enhanced x402 resource server\n * Provides framework-agnostic HTTP protocol handling\n */\nexport class x402HTTPResourceServer {\n  private ResourceServer: x402ResourceServer;\n  private compiledRoutes: CompiledRoute[] = [];\n  private routesConfig: RoutesConfig;\n  private paywallProvider?: PaywallProvider;\n  private protectedRequestHooks: ProtectedRequestHook[] = [];\n\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer: x402ResourceServer, routes: RoutesConfig) {\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n\n    // Handle both single route and multiple routes\n    const normalizedRoutes =\n      typeof routes === \"object\" && !(\"accepts\" in routes)\n        ? (routes as Record<string, RouteConfig>)\n        : { \"*\": routes as RouteConfig };\n\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config,\n      });\n    }\n  }\n\n  /**\n   * Get the underlying x402ResourceServer instance.\n   *\n   * @returns The underlying x402ResourceServer instance\n   */\n  get server(): x402ResourceServer {\n    return this.ResourceServer;\n  }\n\n  /**\n   * Get the routes configuration.\n   *\n   * @returns The routes configuration\n   */\n  get routes(): RoutesConfig {\n    return this.routesConfig;\n  }\n\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize(): Promise<void> {\n    // First, initialize the underlying resource server (fetches facilitator support)\n    await this.ResourceServer.initialize();\n\n    // Then validate route configuration\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider: PaywallProvider): this {\n    this.paywallProvider = provider;\n    return this;\n  }\n\n  /**\n   * Register a hook that runs on every request to a protected route, before payment processing.\n   * Hooks are executed in order of registration. The first hook to return a non-void result wins.\n   *\n   * @param hook - The request hook function\n   * @returns The x402HTTPResourceServer instance for chaining\n   */\n  onProtectedRequest(hook: ProtectedRequestHook): this {\n    this.protectedRequestHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(\n    context: HTTPRequestContext,\n    paywallConfig?: PaywallConfig,\n  ): Promise<HTTPProcessResult> {\n    const { adapter, path, method } = context;\n\n    // Find matching route\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" }; // No payment required for this route\n    }\n\n    // Execute request hooks before any payment processing\n    for (const hook of this.protectedRequestHooks) {\n      const result = await hook(context, routeConfig);\n      if (result && \"grantAccess\" in result) {\n        return { type: \"no-payment-required\" };\n      }\n      if (result && \"abort\" in result) {\n        return {\n          type: \"payment-error\",\n          response: {\n            status: 403,\n            headers: { \"Content-Type\": \"application/json\" },\n            body: { error: result.reason },\n          },\n        };\n      }\n    }\n\n    // Normalize accepts field to array of payment options\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n\n    // Check for payment header (v1 or v2)\n    const paymentPayload = this.extractPayment(adapter);\n\n    // Create resource info, using config override if provided\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\",\n    };\n\n    // Build requirements from all payment options\n    // (this method handles resolving dynamic functions internally)\n    let requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context,\n    );\n\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n\n    // createPaymentRequiredResponse already handles extension enrichment in the core layer\n    const paymentRequired = await this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : undefined,\n      extensions,\n    );\n\n    // If no payment provided\n    if (!paymentPayload) {\n      // Resolve custom unpaid response body if provided\n      const unpaidBody = routeConfig.unpaidResponseBody\n        ? await routeConfig.unpaidResponseBody(context)\n        : undefined;\n\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody,\n        ),\n      };\n    }\n\n    // Verify payment\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload,\n      );\n\n      if (!matchingRequirements) {\n        const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements,\n      );\n\n      if (!verifyResult.isValid) {\n        const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      // Payment is valid, return data needed for settlement\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements,\n        declaredExtensions: routeConfig.extensions,\n      };\n    } catch (error) {\n      const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions,\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n      };\n    }\n  }\n\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @param declaredExtensions - Optional declared extensions (for per-key enrichment)\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n    declaredExtensions?: Record<string, unknown>,\n  ): Promise<ProcessSettleResultResponse> {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(\n        paymentPayload,\n        requirements,\n        declaredExtensions,\n      );\n\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\",\n          errorMessage:\n            settleResponse.errorMessage || settleResponse.errorReason || \"Settlement failed\",\n        };\n      }\n\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse),\n        requirements,\n      };\n    } catch (error) {\n      if (error instanceof SettleError) {\n        return {\n          success: false,\n          errorReason: error.errorReason || error.message,\n          errorMessage: error.errorMessage || error.errorReason || error.message,\n          payer: error.payer,\n          network: error.network,\n          transaction: error.transaction,\n        };\n      }\n      return {\n        success: false,\n        errorReason: error instanceof Error ? error.message : \"Settlement failed\",\n        errorMessage: error instanceof Error ? error.message : \"Settlement failed\",\n        network: requirements.network as Network,\n        transaction: \"\",\n      };\n    }\n  }\n\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context: HTTPRequestContext): boolean {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== undefined;\n  }\n\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  private normalizePaymentOptions(routeConfig: RouteConfig): PaymentOption[] {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  private validateRouteConfiguration(): RouteValidationError[] {\n    const errors: RouteValidationError[] = [];\n\n    // Normalize routes to array of [pattern, config] pairs\n    const normalizedRoutes =\n      typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig)\n        ? Object.entries(this.routesConfig as Record<string, RouteConfig>)\n        : [[\"*\", this.routesConfig as RouteConfig] as [string, RouteConfig]];\n\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n\n      for (const option of paymentOptions) {\n        // Check 1: Is scheme registered?\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n          // Skip facilitator check if scheme isn't registered\n          continue;\n        }\n\n        // Check 2: Does facilitator support this scheme/network combination?\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme,\n        );\n\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  private getRouteConfig(path: string, method: string): RouteConfig | undefined {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n\n    const matchingRoute = this.compiledRoutes.find(\n      route =>\n        route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod),\n    );\n\n    return matchingRoute?.config;\n  }\n\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  private extractPayment(adapter: HTTPAdapter): PaymentPayload | null {\n    // Check v2 header first (PAYMENT-SIGNATURE)\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  private isWebBrowser(adapter: HTTPAdapter): boolean {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  private createHTTPResponse(\n    paymentRequired: PaymentRequired,\n    isWebBrowser: boolean,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n    unpaidResponse?: UnpaidResponseResult,\n  ): HTTPResponseInstructions {\n    // Use 412 Precondition Failed for permit2_allowance_required error\n    // This signals client needs to approve Permit2 before retrying\n    const status = paymentRequired.error === \"permit2_allowance_required\" ? 412 : 402;\n\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true,\n      };\n    }\n\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n\n    // Use callback result if provided, otherwise default to JSON with empty object\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n\n    return {\n      status,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers,\n      },\n      body,\n    };\n  }\n\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  private createHTTPPaymentRequiredResponse(paymentRequired: PaymentRequired): {\n    headers: Record<string, string>;\n  } {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired),\n      },\n    };\n  }\n\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @returns Headers to add to response\n   */\n  private createSettlementHeaders(settleResponse: SettleResponse): Record<string, string> {\n    const encoded = encodePaymentResponseHeader(settleResponse);\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  private parseRoutePattern(pattern: string): { verb: string; regex: RegExp } {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n\n    const regex = new RegExp(\n      `^${\n        path\n          .replace(/[$()+.?^{|}]/g, \"\\\\$&\") // Escape regex special chars\n          .replace(/\\*/g, \".*?\") // Wildcards\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Parameters\n          .replace(/\\//g, \"\\\\/\") // Escape slashes\n      }$`,\n      \"i\",\n    );\n\n    return { verb: verb.toUpperCase(), regex };\n  }\n\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  private normalizePath(path: string): string {\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    let decodedOrRawPath: string;\n    try {\n      decodedOrRawPath = decodeURIComponent(pathWithoutQuery);\n    } catch {\n      decodedOrRawPath = pathWithoutQuery;\n    }\n\n    return decodedOrRawPath\n      .replace(/\\\\/g, \"/\")\n      .replace(/\\/+/g, \"/\")\n      .replace(/(.+?)\\/+$/, \"$1\");\n  }\n\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  private generatePaywallHTML(\n    paymentRequired: PaymentRequired,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n  ): string {\n    if (customHtml) {\n      return customHtml;\n    }\n\n    // Use custom paywall provider if set\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n\n    // Try to use @x402/paywall if available (optional dependency)\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const paywall = require(\"@x402/paywall\");\n      const displayAmount = this.getDisplayAmount(paymentRequired);\n      const resource = paymentRequired.resource;\n\n      return paywall.getPaywallHtml({\n        amount: displayAmount,\n        paymentRequired,\n        currentUrl: resource?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint,\n      });\n    } catch {\n      // @x402/paywall not installed, fall back to basic HTML\n    }\n\n    // Fallback: Basic HTML paywall\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  private getDisplayAmount(paymentRequired: PaymentRequired): number {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        // V2 format\n        return parseFloat(firstReq.amount) / 1000000; // Assuming USDC with 6 decimals\n      }\n    }\n    return 0;\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport {\n  VerifyResponse,\n  SettleResponse,\n  SupportedResponse,\n  VerifyError,\n  SettleError,\n} from \"../types/facilitator\";\n\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\n\nexport interface FacilitatorConfig {\n  url?: string;\n  createAuthHeaders?: () => Promise<{\n    verify: Record<string, string>;\n    settle: Record<string, string>;\n    supported: Record<string, string>;\n  }>;\n}\n\n/**\n * Interface for facilitator clients\n * Can be implemented for HTTP-based or local facilitators\n */\nexport interface FacilitatorClient {\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse>;\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse>;\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  getSupported(): Promise<SupportedResponse>;\n}\n\n/**\n * HTTP-based client for interacting with x402 facilitator services\n * Handles HTTP communication with facilitator endpoints\n */\nexport class HTTPFacilitatorClient implements FacilitatorClient {\n  readonly url: string;\n  private readonly _createAuthHeaders?: FacilitatorConfig[\"createAuthHeaders\"];\n\n  /**\n   * Creates a new HTTPFacilitatorClient instance.\n   *\n   * @param config - Configuration options for the facilitator client\n   */\n  constructor(config?: FacilitatorConfig) {\n    this.url = config?.url || DEFAULT_FACILITATOR_URL;\n    this._createAuthHeaders = config?.createAuthHeaders;\n  }\n\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  async verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"verify\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"isValid\" in data) {\n      const verifyResponse = data as VerifyResponse;\n      if (!response.ok) {\n        throw new VerifyError(response.status, verifyResponse);\n      }\n      return verifyResponse;\n    }\n\n    throw new Error(`Facilitator verify failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  async settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"settle\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"success\" in data) {\n      const settleResponse = data as SettleResponse;\n      if (!response.ok) {\n        throw new SettleError(response.status, settleResponse);\n      }\n      return settleResponse;\n    }\n\n    throw new Error(`Facilitator settle failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  async getSupported(): Promise<SupportedResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"supported\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/supported`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator getSupported failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as SupportedResponse;\n  }\n\n  /**\n   * Creates authentication headers for a specific path.\n   *\n   * @param path - The path to create authentication headers for (e.g., \"verify\", \"settle\", \"supported\")\n   * @returns An object containing the authentication headers for the specified path\n   */\n  async createAuthHeaders(path: string): Promise<{\n    headers: Record<string, string>;\n  }> {\n    if (this._createAuthHeaders) {\n      const authHeaders = (await this._createAuthHeaders()) as Record<\n        string,\n        Record<string, string>\n      >;\n      return {\n        headers: authHeaders[path] ?? {},\n      };\n    }\n    return {\n      headers: {},\n    };\n  }\n\n  /**\n   * Helper to convert objects to JSON-safe format.\n   * Handles BigInt and other non-JSON types.\n   *\n   * @param obj - The object to convert\n   * @returns The JSON-safe representation of the object\n   */\n  private toJsonSafe(obj: unknown): unknown {\n    return JSON.parse(\n      JSON.stringify(obj, (_, value) => (typeof value === \"bigint\" ? value.toString() : value)),\n    );\n  }\n}\n","import {\n  decodePaymentRequiredHeader,\n  decodePaymentResponseHeader,\n  encodePaymentSignatureHeader,\n} from \".\";\nimport { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { x402Client } from \"../client/x402Client\";\n\n/**\n * Context provided to onPaymentRequired hooks.\n */\nexport interface PaymentRequiredContext {\n  paymentRequired: PaymentRequired;\n}\n\n/**\n * Hook called when a 402 response is received, before payment processing.\n * Return headers to try before payment, or void to proceed directly to payment.\n */\nexport type PaymentRequiredHook = (\n  context: PaymentRequiredContext,\n) => Promise<{ headers: Record<string, string> } | void>;\n\n/**\n * HTTP-specific client for handling x402 payment protocol over HTTP.\n *\n * Wraps a x402Client to provide HTTP-specific encoding/decoding functionality\n * for payment headers and responses while maintaining the builder pattern.\n */\nexport class x402HTTPClient {\n  private paymentRequiredHooks: PaymentRequiredHook[] = [];\n\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(private readonly client: x402Client) {}\n\n  /**\n   * Register a hook to handle 402 responses before payment.\n   * Hooks run in order; first to return headers wins.\n   *\n   * @param hook - The hook function to register\n   * @returns This instance for chaining\n   */\n  onPaymentRequired(hook: PaymentRequiredHook): this {\n    this.paymentRequiredHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Run hooks and return headers if any hook provides them.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Headers to use for retry, or null to proceed to payment\n   */\n  async handlePaymentRequired(\n    paymentRequired: PaymentRequired,\n  ): Promise<Record<string, string> | null> {\n    for (const hook of this.paymentRequiredHooks) {\n      const result = await hook({ paymentRequired });\n      if (result?.headers) {\n        return result.headers;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload: PaymentPayload): Record<string, string> {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(\n    getHeader: (name: string) => string | null | undefined,\n    body?: unknown,\n  ): PaymentRequired {\n    // v2\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n\n    // v1\n    if (\n      body &&\n      body instanceof Object &&\n      \"x402Version\" in body &&\n      (body as PaymentRequired).x402Version === 1\n    ) {\n      return body as PaymentRequired;\n    }\n\n    throw new Error(\"Invalid payment required response\");\n  }\n\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader: (name: string) => string | null | undefined): SettleResponse {\n    // v2\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n\n    // v1\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n\n    throw new Error(\"Payment response header not found\");\n  }\n\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired: PaymentRequired): Promise<PaymentPayload> {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n}\n"],"mappings":"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","names":["displayAmount","resource"]}