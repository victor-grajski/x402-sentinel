{"version":3,"sources":["../../../src/server/index.ts","../../../src/types/facilitator.ts","../../../src/utils/index.ts","../../../src/http/httpFacilitatorClient.ts","../../../src/index.ts","../../../src/server/x402ResourceServer.ts","../../../src/http/index.ts","../../../src/http/x402HTTPResourceServer.ts"],"sourcesContent":["export { x402ResourceServer } from \"./x402ResourceServer\";\nexport type { ResourceConfig, ResourceInfo, SettleResultContext } from \"./x402ResourceServer\";\n\nexport { HTTPFacilitatorClient } from \"../http/httpFacilitatorClient\";\nexport type { FacilitatorClient, FacilitatorConfig } from \"../http/httpFacilitatorClient\";\n\nexport { x402HTTPResourceServer, RouteConfigurationError } from \"../http/x402HTTPResourceServer\";\nexport type {\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  RouteConfig,\n  CompiledRoute,\n  HTTPAdapter,\n  RoutesConfig,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n} from \"../http/x402HTTPResourceServer\";\n","import { PaymentPayload, PaymentRequirements } from \"./payments\";\nimport { Network } from \"./\";\n\nexport type VerifyRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type VerifyResponse = {\n  isValid: boolean;\n  invalidReason?: string;\n  invalidMessage?: string;\n  payer?: string;\n  extensions?: Record<string, unknown>;\n};\n\nexport type SettleRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type SettleResponse = {\n  success: boolean;\n  errorReason?: string;\n  errorMessage?: string;\n  payer?: string;\n  transaction: string;\n  network: Network;\n  extensions?: Record<string, unknown>;\n};\n\nexport type SupportedKind = {\n  x402Version: number;\n  scheme: string;\n  network: Network;\n  extra?: Record<string, unknown>;\n};\n\nexport type SupportedResponse = {\n  kinds: SupportedKind[];\n  extensions: string[];\n  signers: Record<string, string[]>; // CAIP family pattern â†’ Signer addresses\n};\n\n/**\n * Error thrown when payment verification fails.\n */\nexport class VerifyError extends Error {\n  readonly invalidReason?: string;\n  readonly invalidMessage?: string;\n  readonly payer?: string;\n  readonly statusCode: number;\n\n  /**\n   * Creates a VerifyError from a failed verification response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The verify response containing error details\n   */\n  constructor(statusCode: number, response: VerifyResponse) {\n    const reason = response.invalidReason || \"unknown reason\";\n    const message = response.invalidMessage;\n    super(message ? `${reason}: ${message}` : reason);\n    this.name = \"VerifyError\";\n    this.statusCode = statusCode;\n    this.invalidReason = response.invalidReason;\n    this.invalidMessage = response.invalidMessage;\n    this.payer = response.payer;\n  }\n}\n\n/**\n * Error thrown when payment settlement fails.\n */\nexport class SettleError extends Error {\n  readonly errorReason?: string;\n  readonly errorMessage?: string;\n  readonly payer?: string;\n  readonly transaction: string;\n  readonly network: Network;\n  readonly statusCode: number;\n\n  /**\n   * Creates a SettleError from a failed settlement response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The settle response containing error details\n   */\n  constructor(statusCode: number, response: SettleResponse) {\n    const reason = response.errorReason || \"unknown reason\";\n    const message = response.errorMessage;\n    super(message ? `${reason}: ${message}` : reason);\n    this.name = \"SettleError\";\n    this.statusCode = statusCode;\n    this.errorReason = response.errorReason;\n    this.errorMessage = response.errorMessage;\n    this.payer = response.payer;\n    this.transaction = response.transaction;\n    this.network = response.network;\n  }\n}\n","import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    const bytes = new TextEncoder().encode(data);\n    const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join(\"\");\n    return globalThis.btoa(binaryString);\n  }\n  return Buffer.from(data, \"utf8\").toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    const binaryString = globalThis.atob(data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    const decoder = new TextDecoder(\"utf-8\");\n    return decoder.decode(bytes);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport {\n  VerifyResponse,\n  SettleResponse,\n  SupportedResponse,\n  VerifyError,\n  SettleError,\n} from \"../types/facilitator\";\n\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\n\nexport interface FacilitatorConfig {\n  url?: string;\n  createAuthHeaders?: () => Promise<{\n    verify: Record<string, string>;\n    settle: Record<string, string>;\n    supported: Record<string, string>;\n  }>;\n}\n\n/**\n * Interface for facilitator clients\n * Can be implemented for HTTP-based or local facilitators\n */\nexport interface FacilitatorClient {\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse>;\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse>;\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  getSupported(): Promise<SupportedResponse>;\n}\n\n/**\n * HTTP-based client for interacting with x402 facilitator services\n * Handles HTTP communication with facilitator endpoints\n */\nexport class HTTPFacilitatorClient implements FacilitatorClient {\n  readonly url: string;\n  private readonly _createAuthHeaders?: FacilitatorConfig[\"createAuthHeaders\"];\n\n  /**\n   * Creates a new HTTPFacilitatorClient instance.\n   *\n   * @param config - Configuration options for the facilitator client\n   */\n  constructor(config?: FacilitatorConfig) {\n    this.url = config?.url || DEFAULT_FACILITATOR_URL;\n    this._createAuthHeaders = config?.createAuthHeaders;\n  }\n\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  async verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"verify\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"isValid\" in data) {\n      const verifyResponse = data as VerifyResponse;\n      if (!response.ok) {\n        throw new VerifyError(response.status, verifyResponse);\n      }\n      return verifyResponse;\n    }\n\n    throw new Error(`Facilitator verify failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  async settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"settle\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"success\" in data) {\n      const settleResponse = data as SettleResponse;\n      if (!response.ok) {\n        throw new SettleError(response.status, settleResponse);\n      }\n      return settleResponse;\n    }\n\n    throw new Error(`Facilitator settle failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  async getSupported(): Promise<SupportedResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"supported\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/supported`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator getSupported failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as SupportedResponse;\n  }\n\n  /**\n   * Creates authentication headers for a specific path.\n   *\n   * @param path - The path to create authentication headers for (e.g., \"verify\", \"settle\", \"supported\")\n   * @returns An object containing the authentication headers for the specified path\n   */\n  async createAuthHeaders(path: string): Promise<{\n    headers: Record<string, string>;\n  }> {\n    if (this._createAuthHeaders) {\n      const authHeaders = (await this._createAuthHeaders()) as Record<\n        string,\n        Record<string, string>\n      >;\n      return {\n        headers: authHeaders[path] ?? {},\n      };\n    }\n    return {\n      headers: {},\n    };\n  }\n\n  /**\n   * Helper to convert objects to JSON-safe format.\n   * Handles BigInt and other non-JSON types.\n   *\n   * @param obj - The object to convert\n   * @returns The JSON-safe representation of the object\n   */\n  private toJsonSafe(obj: unknown): unknown {\n    return JSON.parse(\n      JSON.stringify(obj, (_, value) => (typeof value === \"bigint\" ? value.toString() : value)),\n    );\n  }\n}\n","export const x402Version = 2;\n","import {\n  SettleError,\n  SettleResponse,\n  VerifyResponse,\n  SupportedResponse,\n  SupportedKind,\n} from \"../types/facilitator\";\nimport { PaymentPayload, PaymentRequirements, PaymentRequired } from \"../types/payments\";\nimport { SchemeNetworkServer } from \"../types/mechanisms\";\nimport { Price, Network, ResourceServerExtension, VerifyError } from \"../types\";\nimport { deepEqual, findByNetworkAndScheme } from \"../utils\";\nimport { FacilitatorClient, HTTPFacilitatorClient } from \"../http/httpFacilitatorClient\";\nimport { x402Version } from \"..\";\n\n/**\n * Configuration for a protected resource\n * Only contains payment-specific configuration, not resource metadata\n */\nexport interface ResourceConfig {\n  scheme: string;\n  payTo: string; // Payment recipient address\n  price: Price;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>; // Scheme-specific additional data\n}\n\n/**\n * Resource information for PaymentRequired response\n */\nexport interface ResourceInfo {\n  url: string;\n  description: string;\n  mimeType: string;\n}\n\n/**\n * Lifecycle Hook Context Interfaces\n */\n\nexport interface PaymentRequiredContext {\n  requirements: PaymentRequirements[];\n  resourceInfo: ResourceInfo;\n  error?: string;\n  paymentRequiredResponse: PaymentRequired;\n}\n\nexport interface VerifyContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface VerifyResultContext extends VerifyContext {\n  result: VerifyResponse;\n}\n\nexport interface VerifyFailureContext extends VerifyContext {\n  error: Error;\n}\n\nexport interface SettleContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface SettleResultContext extends SettleContext {\n  result: SettleResponse;\n}\n\nexport interface SettleFailureContext extends SettleContext {\n  error: Error;\n}\n\n/**\n * Lifecycle Hook Type Definitions\n */\n\nexport type BeforeVerifyHook = (\n  context: VerifyContext,\n) => Promise<void | { abort: true; reason: string; message?: string }>;\n\nexport type AfterVerifyHook = (context: VerifyResultContext) => Promise<void>;\n\nexport type OnVerifyFailureHook = (\n  context: VerifyFailureContext,\n) => Promise<void | { recovered: true; result: VerifyResponse }>;\n\nexport type BeforeSettleHook = (\n  context: SettleContext,\n) => Promise<void | { abort: true; reason: string; message?: string }>;\n\nexport type AfterSettleHook = (context: SettleResultContext) => Promise<void>;\n\nexport type OnSettleFailureHook = (\n  context: SettleFailureContext,\n) => Promise<void | { recovered: true; result: SettleResponse }>;\n\n/**\n * Core x402 protocol server for resource protection\n * Transport-agnostic implementation of the x402 payment protocol\n */\nexport class x402ResourceServer {\n  private facilitatorClients: FacilitatorClient[];\n  private registeredServerSchemes: Map<string, Map<string, SchemeNetworkServer>> = new Map();\n  private supportedResponsesMap: Map<number, Map<string, Map<string, SupportedResponse>>> =\n    new Map();\n  private facilitatorClientsMap: Map<number, Map<string, Map<string, FacilitatorClient>>> =\n    new Map();\n  private registeredExtensions: Map<string, ResourceServerExtension> = new Map();\n\n  private beforeVerifyHooks: BeforeVerifyHook[] = [];\n  private afterVerifyHooks: AfterVerifyHook[] = [];\n  private onVerifyFailureHooks: OnVerifyFailureHook[] = [];\n  private beforeSettleHooks: BeforeSettleHook[] = [];\n  private afterSettleHooks: AfterSettleHook[] = [];\n  private onSettleFailureHooks: OnSettleFailureHook[] = [];\n\n  /**\n   * Creates a new x402ResourceServer instance.\n   *\n   * @param facilitatorClients - Optional facilitator client(s) for payment processing\n   */\n  constructor(facilitatorClients?: FacilitatorClient | FacilitatorClient[]) {\n    // Normalize facilitator clients to array\n    if (!facilitatorClients) {\n      // No clients provided, create a default HTTP client\n      this.facilitatorClients = [new HTTPFacilitatorClient()];\n    } else if (Array.isArray(facilitatorClients)) {\n      // Array of clients provided\n      this.facilitatorClients =\n        facilitatorClients.length > 0 ? facilitatorClients : [new HTTPFacilitatorClient()];\n    } else {\n      // Single client provided\n      this.facilitatorClients = [facilitatorClients];\n    }\n  }\n\n  /**\n   * Register a scheme/network server implementation.\n   *\n   * @param network - The network identifier\n   * @param server - The scheme/network server implementation\n   * @returns The x402ResourceServer instance for chaining\n   */\n  register(network: Network, server: SchemeNetworkServer): x402ResourceServer {\n    if (!this.registeredServerSchemes.has(network)) {\n      this.registeredServerSchemes.set(network, new Map());\n    }\n\n    const serverByScheme = this.registeredServerSchemes.get(network)!;\n    if (!serverByScheme.has(server.scheme)) {\n      serverByScheme.set(server.scheme, server);\n    }\n\n    return this;\n  }\n\n  /**\n   * Check if a scheme is registered for a given network.\n   *\n   * @param network - The network identifier\n   * @param scheme - The payment scheme name\n   * @returns True if the scheme is registered for the network, false otherwise\n   */\n  hasRegisteredScheme(network: Network, scheme: string): boolean {\n    return !!findByNetworkAndScheme(this.registeredServerSchemes, scheme, network);\n  }\n\n  /**\n   * Registers a resource service extension that can enrich extension declarations.\n   *\n   * @param extension - The extension to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  registerExtension(extension: ResourceServerExtension): this {\n    this.registeredExtensions.set(extension.key, extension);\n    return this;\n  }\n\n  /**\n   * Check if an extension is registered.\n   *\n   * @param key - The extension key\n   * @returns True if the extension is registered\n   */\n  hasExtension(key: string): boolean {\n    return this.registeredExtensions.has(key);\n  }\n\n  /**\n   * Get all registered extensions.\n   *\n   * @returns Array of registered extensions\n   */\n  getExtensions(): ResourceServerExtension[] {\n    return Array.from(this.registeredExtensions.values());\n  }\n\n  /**\n   * Enriches declared extensions using registered extension hooks.\n   *\n   * @param declaredExtensions - Extensions declared on the route\n   * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)\n   * @returns Enriched extensions map\n   */\n  enrichExtensions(\n    declaredExtensions: Record<string, unknown>,\n    transportContext: unknown,\n  ): Record<string, unknown> {\n    const enriched: Record<string, unknown> = {};\n\n    for (const [key, declaration] of Object.entries(declaredExtensions)) {\n      const extension = this.registeredExtensions.get(key);\n\n      if (extension?.enrichDeclaration) {\n        enriched[key] = extension.enrichDeclaration(declaration, transportContext);\n      } else {\n        enriched[key] = declaration;\n      }\n    }\n\n    return enriched;\n  }\n\n  /**\n   * Register a hook to execute before payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeVerify(hook: BeforeVerifyHook): x402ResourceServer {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment verification.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterVerify(hook: AfterVerifyHook): x402ResourceServer {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment verification fails.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onVerifyFailure(hook: OnVerifyFailureHook): x402ResourceServer {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeSettle(hook: BeforeSettleHook): x402ResourceServer {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterSettle(hook: AfterSettleHook): x402ResourceServer {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onSettleFailure(hook: OnSettleFailureHook): x402ResourceServer {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Initialize by fetching supported kinds from all facilitators\n   * Creates mappings for supported responses and facilitator clients\n   * Earlier facilitators in the array get precedence\n   */\n  async initialize(): Promise<void> {\n    // Clear existing mappings\n    this.supportedResponsesMap.clear();\n    this.facilitatorClientsMap.clear();\n\n    // Fetch supported kinds from all facilitator clients\n    // Process in order to give precedence to earlier facilitators\n    for (const facilitatorClient of this.facilitatorClients) {\n      try {\n        const supported = await facilitatorClient.getSupported();\n\n        // Process each supported kind (now flat array with version in each element)\n        for (const kind of supported.kinds) {\n          const x402Version = kind.x402Version;\n\n          // Get or create version map for supported responses\n          if (!this.supportedResponsesMap.has(x402Version)) {\n            this.supportedResponsesMap.set(x402Version, new Map());\n          }\n          const responseVersionMap = this.supportedResponsesMap.get(x402Version)!;\n\n          // Get or create version map for facilitator clients\n          if (!this.facilitatorClientsMap.has(x402Version)) {\n            this.facilitatorClientsMap.set(x402Version, new Map());\n          }\n          const clientVersionMap = this.facilitatorClientsMap.get(x402Version)!;\n\n          // Get or create network map for responses\n          if (!responseVersionMap.has(kind.network)) {\n            responseVersionMap.set(kind.network, new Map());\n          }\n          const responseNetworkMap = responseVersionMap.get(kind.network)!;\n\n          // Get or create network map for clients\n          if (!clientVersionMap.has(kind.network)) {\n            clientVersionMap.set(kind.network, new Map());\n          }\n          const clientNetworkMap = clientVersionMap.get(kind.network)!;\n\n          // Only store if not already present (gives precedence to earlier facilitators)\n          if (!responseNetworkMap.has(kind.scheme)) {\n            responseNetworkMap.set(kind.scheme, supported);\n            clientNetworkMap.set(kind.scheme, facilitatorClient);\n          }\n        }\n      } catch (error) {\n        // Log error but continue with other facilitators\n        console.warn(`Failed to fetch supported kinds from facilitator: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Get supported kind for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The supported kind or undefined if not found\n   */\n  getSupportedKind(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): SupportedKind | undefined {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    if (!supportedResponse) return undefined;\n\n    // Find the specific kind from the response (kinds are flat array with version in each element)\n    return supportedResponse.kinds.find(\n      kind =>\n        kind.x402Version === x402Version && kind.network === network && kind.scheme === scheme,\n    );\n  }\n\n  /**\n   * Get facilitator extensions for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator extensions or empty array if not found\n   */\n  getFacilitatorExtensions(x402Version: number, network: Network, scheme: string): string[] {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return [];\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    return supportedResponse?.extensions || [];\n  }\n\n  /**\n   * Build payment requirements for a protected resource\n   *\n   * @param resourceConfig - Configuration for the protected resource\n   * @returns Array of payment requirements\n   */\n  async buildPaymentRequirements(resourceConfig: ResourceConfig): Promise<PaymentRequirements[]> {\n    const requirements: PaymentRequirements[] = [];\n\n    // Find the matching server implementation\n    const scheme = resourceConfig.scheme;\n    const SchemeNetworkServer = findByNetworkAndScheme(\n      this.registeredServerSchemes,\n      scheme,\n      resourceConfig.network,\n    );\n\n    if (!SchemeNetworkServer) {\n      // Fallback to placeholder implementation if no server registered\n      // TODO: Remove this fallback once implementations are registered\n      console.warn(\n        `No server implementation registered for scheme: ${scheme}, network: ${resourceConfig.network}`,\n      );\n      return requirements;\n    }\n\n    // Find the matching supported kind from facilitator\n    const supportedKind = this.getSupportedKind(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    if (!supportedKind) {\n      throw new Error(\n        `Facilitator does not support ${SchemeNetworkServer.scheme} on ${resourceConfig.network}. ` +\n          `Make sure to call initialize() to fetch supported kinds from facilitators.`,\n      );\n    }\n\n    // Get facilitator extensions for this combination\n    const facilitatorExtensions = this.getFacilitatorExtensions(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    // Parse the price using the scheme's price parser\n    const parsedPrice = await SchemeNetworkServer.parsePrice(\n      resourceConfig.price,\n      resourceConfig.network,\n    );\n\n    // Build base payment requirements from resource config\n    const baseRequirements: PaymentRequirements = {\n      scheme: SchemeNetworkServer.scheme,\n      network: resourceConfig.network,\n      amount: parsedPrice.amount,\n      asset: parsedPrice.asset,\n      payTo: resourceConfig.payTo,\n      maxTimeoutSeconds: resourceConfig.maxTimeoutSeconds || 300, // Default 5 minutes\n      extra: {\n        ...parsedPrice.extra,\n        ...resourceConfig.extra, // Merge user-provided extra\n      },\n    };\n\n    // Delegate to the implementation for scheme-specific enhancements\n    // Note: enhancePaymentRequirements expects x402Version in the kind, so we add it back\n    const requirement = await SchemeNetworkServer.enhancePaymentRequirements(\n      baseRequirements,\n      {\n        ...supportedKind,\n        x402Version,\n      },\n      facilitatorExtensions,\n    );\n\n    requirements.push(requirement);\n    return requirements;\n  }\n\n  /**\n   * Build payment requirements from multiple payment options\n   * This method handles resolving dynamic payTo/price functions and builds requirements for each option\n   *\n   * @param paymentOptions - Array of payment options to convert\n   * @param context - HTTP request context for resolving dynamic functions\n   * @returns Array of payment requirements (one per option)\n   */\n  async buildPaymentRequirementsFromOptions<TContext = unknown>(\n    paymentOptions: Array<{\n      scheme: string;\n      payTo: string | ((context: TContext) => string | Promise<string>);\n      price: Price | ((context: TContext) => Price | Promise<Price>);\n      network: Network;\n      maxTimeoutSeconds?: number;\n    }>,\n    context: TContext,\n  ): Promise<PaymentRequirements[]> {\n    const allRequirements: PaymentRequirements[] = [];\n\n    for (const option of paymentOptions) {\n      // Resolve dynamic payTo and price if they are functions\n      const resolvedPayTo =\n        typeof option.payTo === \"function\" ? await option.payTo(context) : option.payTo;\n      const resolvedPrice =\n        typeof option.price === \"function\" ? await option.price(context) : option.price;\n\n      const resourceConfig: ResourceConfig = {\n        scheme: option.scheme,\n        payTo: resolvedPayTo,\n        price: resolvedPrice,\n        network: option.network,\n        maxTimeoutSeconds: option.maxTimeoutSeconds,\n      };\n\n      // Use existing buildPaymentRequirements for each option\n      const requirements = await this.buildPaymentRequirements(resourceConfig);\n      allRequirements.push(...requirements);\n    }\n\n    return allRequirements;\n  }\n\n  /**\n   * Create a payment required response\n   *\n   * @param requirements - Payment requirements\n   * @param resourceInfo - Resource information\n   * @param error - Error message\n   * @param extensions - Optional declared extensions (for per-key enrichment)\n   * @returns Payment required response object\n   */\n  async createPaymentRequiredResponse(\n    requirements: PaymentRequirements[],\n    resourceInfo: ResourceInfo,\n    error?: string,\n    extensions?: Record<string, unknown>,\n  ): Promise<PaymentRequired> {\n    // V2 response with resource at top level\n    let response: PaymentRequired = {\n      x402Version: 2,\n      error,\n      resource: resourceInfo,\n      accepts: requirements as PaymentRequirements[],\n    };\n\n    // Add extensions if provided\n    if (extensions && Object.keys(extensions).length > 0) {\n      response.extensions = extensions;\n    }\n\n    // Let declared extensions add data to PaymentRequired response\n    if (extensions) {\n      for (const [key, declaration] of Object.entries(extensions)) {\n        const extension = this.registeredExtensions.get(key);\n        if (extension?.enrichPaymentRequiredResponse) {\n          try {\n            const context: PaymentRequiredContext = {\n              requirements,\n              resourceInfo,\n              error,\n              paymentRequiredResponse: response,\n            };\n            const extensionData = await extension.enrichPaymentRequiredResponse(\n              declaration,\n              context,\n            );\n            if (extensionData !== undefined) {\n              if (!response.extensions) {\n                response.extensions = {};\n              }\n              response.extensions[key] = extensionData;\n            }\n          } catch (error) {\n            console.error(\n              `Error in enrichPaymentRequiredResponse hook for extension ${key}:`,\n              error,\n            );\n          }\n        }\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Verify a payment against requirements\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Verification response\n   */\n  async verifyPayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const context: VerifyContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeVerify hooks\n    for (const hook of this.beforeVerifyHooks) {\n      try {\n        const result = await hook(context);\n        if (result && \"abort\" in result && result.abort) {\n          return {\n            isValid: false,\n            invalidReason: result.reason,\n            invalidMessage: result.message,\n          };\n        }\n      } catch (error) {\n        throw new VerifyError(400, {\n          isValid: false,\n          invalidReason: \"before_verify_hook_error\",\n          invalidMessage: error instanceof Error ? error.message : \"\",\n        });\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let verifyResult: VerifyResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            verifyResult = await client.verify(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!verifyResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        verifyResult = await facilitatorClient.verify(paymentPayload, requirements);\n      }\n\n      // Execute afterVerify hooks\n      const resultContext: VerifyResultContext = {\n        ...context,\n        result: verifyResult,\n      };\n\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n\n      return verifyResult;\n    } catch (error) {\n      const failureContext: VerifyFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onVerifyFailure hooks\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Settle a verified payment\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @param declaredExtensions - Optional declared extensions (for per-key enrichment)\n   * @returns Settlement response\n   */\n  async settlePayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n    declaredExtensions?: Record<string, unknown>,\n  ): Promise<SettleResponse> {\n    const context: SettleContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeSettle hooks\n    for (const hook of this.beforeSettleHooks) {\n      try {\n        const result = await hook(context);\n        if (result && \"abort\" in result && result.abort) {\n          throw new SettleError(400, {\n            success: false,\n            errorReason: result.reason,\n            errorMessage: result.message,\n            transaction: \"\",\n            network: requirements.network,\n          });\n        }\n      } catch (error) {\n        throw new SettleError(400, {\n          success: false,\n          errorReason: \"before_settle_hook_error\",\n          errorMessage: error instanceof Error ? error.message : \"\",\n          transaction: \"\",\n          network: requirements.network,\n        });\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let settleResult: SettleResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            settleResult = await client.settle(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!settleResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        settleResult = await facilitatorClient.settle(paymentPayload, requirements);\n      }\n\n      // Execute afterSettle hooks\n      const resultContext: SettleResultContext = {\n        ...context,\n        result: settleResult,\n      };\n\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n\n      // Let declared extensions add data to settlement response\n      if (declaredExtensions) {\n        for (const [key, declaration] of Object.entries(declaredExtensions)) {\n          const extension = this.registeredExtensions.get(key);\n          if (extension?.enrichSettlementResponse) {\n            try {\n              const extensionData = await extension.enrichSettlementResponse(\n                declaration,\n                resultContext,\n              );\n              if (extensionData !== undefined) {\n                if (!settleResult.extensions) {\n                  settleResult.extensions = {};\n                }\n                settleResult.extensions[key] = extensionData;\n              }\n            } catch (error) {\n              console.error(`Error in enrichSettlementResponse hook for extension ${key}:`, error);\n            }\n          }\n        }\n      }\n\n      return settleResult;\n    } catch (error) {\n      const failureContext: SettleFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onSettleFailure hooks\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Find matching payment requirements for a payment\n   *\n   * @param availableRequirements - Array of available payment requirements\n   * @param paymentPayload - The payment payload\n   * @returns Matching payment requirements or undefined\n   */\n  findMatchingRequirements(\n    availableRequirements: PaymentRequirements[],\n    paymentPayload: PaymentPayload,\n  ): PaymentRequirements | undefined {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        // For v2, match by accepted requirements\n        return availableRequirements.find(paymentRequirements =>\n          deepEqual(paymentRequirements, paymentPayload.accepted),\n        );\n      case 1:\n        // For v1, match by scheme and network\n        return availableRequirements.find(\n          req =>\n            req.scheme === paymentPayload.accepted.scheme &&\n            req.network === paymentPayload.accepted.network,\n        );\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Process a payment request\n   *\n   * @param paymentPayload - Optional payment payload if provided\n   * @param resourceConfig - Configuration for the protected resource\n   * @param resourceInfo - Information about the resource being accessed\n   * @param extensions - Optional extensions to include in the response\n   * @returns Processing result\n   */\n  async processPaymentRequest(\n    paymentPayload: PaymentPayload | null,\n    resourceConfig: ResourceConfig,\n    resourceInfo: ResourceInfo,\n    extensions?: Record<string, unknown>,\n  ): Promise<{\n    success: boolean;\n    requiresPayment?: PaymentRequired;\n    verificationResult?: VerifyResponse;\n    settlementResult?: SettleResponse;\n    error?: string;\n  }> {\n    const requirements = await this.buildPaymentRequirements(resourceConfig);\n\n    if (!paymentPayload) {\n      return {\n        success: false,\n        requiresPayment: await this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"Payment required\",\n          extensions,\n        ),\n      };\n    }\n\n    // Find matching requirements\n    const matchingRequirements = this.findMatchingRequirements(requirements, paymentPayload);\n    if (!matchingRequirements) {\n      return {\n        success: false,\n        requiresPayment: await this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements found\",\n          extensions,\n        ),\n      };\n    }\n\n    // Verify payment\n    const verificationResult = await this.verifyPayment(paymentPayload, matchingRequirements);\n    if (!verificationResult.isValid) {\n      return {\n        success: false,\n        error: verificationResult.invalidReason,\n        verificationResult,\n      };\n    }\n\n    // Payment verified, ready for settlement\n    return {\n      success: true,\n      verificationResult,\n    };\n  }\n\n  /**\n   * Get facilitator client for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator client or undefined if not found\n   */\n  private getFacilitatorClient(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): FacilitatorClient | undefined {\n    const versionMap = this.facilitatorClientsMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    // Use findByNetworkAndScheme for pattern matching\n    return findByNetworkAndScheme(versionMap, scheme, network);\n  }\n}\n\nexport default x402ResourceServer;\n","import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(paymentResponse: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n  ProtectedRequestHook,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient, PaymentRequiredContext, PaymentRequiredHook } from \"./x402HTTPClient\";\n","import { x402ResourceServer } from \"../server\";\nimport {\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n} from \".\";\nimport {\n  PaymentPayload,\n  PaymentRequired,\n  SettleResponse,\n  SettleError,\n  Price,\n  Network,\n  PaymentRequirements,\n} from \"../types\";\nimport { x402Version } from \"..\";\n\n/**\n * Framework-agnostic HTTP adapter interface\n * Implementations provide framework-specific HTTP operations\n */\nexport interface HTTPAdapter {\n  getHeader(name: string): string | undefined;\n  getMethod(): string;\n  getPath(): string;\n  getUrl(): string;\n  getAcceptHeader(): string;\n  getUserAgent(): string;\n\n  /**\n   * Get query parameters from the request URL\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams?(): Record<string, string | string[]>;\n\n  /**\n   * Get a specific query parameter by name\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam?(name: string): string | string[] | undefined;\n\n  /**\n   * Get the parsed request body\n   * Framework adapters should parse JSON/form data appropriately\n   *\n   * @returns The parsed request body\n   */\n  getBody?(): unknown;\n}\n\n/**\n * Paywall configuration for HTML responses\n */\nexport interface PaywallConfig {\n  appName?: string;\n  appLogo?: string;\n  sessionTokenEndpoint?: string;\n  currentUrl?: string;\n  testnet?: boolean;\n}\n\n/**\n * Paywall provider interface for generating HTML\n */\nexport interface PaywallProvider {\n  generateHtml(paymentRequired: PaymentRequired, config?: PaywallConfig): string;\n}\n\n/**\n * Dynamic payTo function that receives HTTP request context\n */\nexport type DynamicPayTo = (context: HTTPRequestContext) => string | Promise<string>;\n\n/**\n * Dynamic price function that receives HTTP request context\n */\nexport type DynamicPrice = (context: HTTPRequestContext) => Price | Promise<Price>;\n\n/**\n * Result of the unpaid response callback containing content type and body.\n */\nexport interface UnpaidResponseResult {\n  /**\n   * The content type for the response (e.g., 'application/json', 'text/plain').\n   */\n  contentType: string;\n\n  /**\n   * The response body to include in the 402 response.\n   */\n  body: unknown;\n}\n\n/**\n * Dynamic function to generate a custom response for unpaid requests.\n * Receives the HTTP request context and returns the content type and body to include in the 402 response.\n */\nexport type UnpaidResponseBody = (\n  context: HTTPRequestContext,\n) => UnpaidResponseResult | Promise<UnpaidResponseResult>;\n\n/**\n * A single payment option for a route\n * Represents one way a client can pay for access to the resource\n */\nexport interface PaymentOption {\n  scheme: string;\n  payTo: string | DynamicPayTo;\n  price: Price | DynamicPrice;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>;\n}\n\n/**\n * Route configuration for HTTP endpoints\n *\n * The 'accepts' field defines payment options for the route.\n * Can be a single PaymentOption or an array of PaymentOptions for multiple payment methods.\n */\nexport interface RouteConfig {\n  // Payment option(s): single or array\n  accepts: PaymentOption | PaymentOption[];\n\n  // HTTP-specific metadata\n  resource?: string;\n  description?: string;\n  mimeType?: string;\n  customPaywallHtml?: string;\n\n  /**\n   * Optional callback to generate a custom response for unpaid API requests.\n   * This allows servers to return preview data, error messages, or other content\n   * when a request lacks payment.\n   *\n   * For browser requests (Accept: text/html), the paywall HTML takes precedence.\n   * This callback is only used for API clients.\n   *\n   * If not provided, defaults to { contentType: 'application/json', body: {} }.\n   *\n   * @param context - The HTTP request context\n   * @returns An object containing both contentType and body for the 402 response\n   */\n  unpaidResponseBody?: UnpaidResponseBody;\n\n  // Extensions\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Routes configuration - maps path patterns to route configs\n */\nexport type RoutesConfig = Record<string, RouteConfig> | RouteConfig;\n\n/**\n * Hook that runs on every request to a protected route, before payment processing.\n * Can grant access without payment, deny the request, or continue to payment flow.\n *\n * @returns\n * - `void` - Continue to payment processing (default behavior)\n * - `{ grantAccess: true }` - Grant access without requiring payment\n * - `{ abort: true; reason: string }` - Deny the request (returns 403)\n */\nexport type ProtectedRequestHook = (\n  context: HTTPRequestContext,\n  routeConfig: RouteConfig,\n) => Promise<void | { grantAccess: true } | { abort: true; reason: string }>;\n\n/**\n * Compiled route for efficient matching\n */\nexport interface CompiledRoute {\n  verb: string;\n  regex: RegExp;\n  config: RouteConfig;\n}\n\n/**\n * HTTP request context that encapsulates all request data\n */\nexport interface HTTPRequestContext {\n  adapter: HTTPAdapter;\n  path: string;\n  method: string;\n  paymentHeader?: string;\n}\n\n/**\n * HTTP response instructions for the framework middleware\n */\nexport interface HTTPResponseInstructions {\n  status: number;\n  headers: Record<string, string>;\n  body?: unknown; // e.g. Paywall for web browser requests, but could be any other type\n  isHtml?: boolean; // e.g. if body is a paywall, then isHtml is true\n}\n\n/**\n * Result of processing an HTTP request for payment\n */\nexport type HTTPProcessResult =\n  | { type: \"no-payment-required\" }\n  | {\n      type: \"payment-verified\";\n      paymentPayload: PaymentPayload;\n      paymentRequirements: PaymentRequirements;\n      declaredExtensions?: Record<string, unknown>;\n    }\n  | { type: \"payment-error\"; response: HTTPResponseInstructions };\n\n/**\n * Result of processSettlement\n */\nexport type ProcessSettleSuccessResponse = SettleResponse & {\n  success: true;\n  headers: Record<string, string>;\n  requirements: PaymentRequirements;\n};\n\nexport type ProcessSettleFailureResponse = SettleResponse & {\n  success: false;\n  errorReason: string;\n  errorMessage?: string;\n};\n\nexport type ProcessSettleResultResponse =\n  | ProcessSettleSuccessResponse\n  | ProcessSettleFailureResponse;\n\n/**\n * Represents a validation error for a specific route's payment configuration.\n */\nexport interface RouteValidationError {\n  /** The route pattern (e.g., \"GET /api/weather\") */\n  routePattern: string;\n  /** The payment scheme that failed validation */\n  scheme: string;\n  /** The network that failed validation */\n  network: Network;\n  /** The type of validation failure */\n  reason: \"missing_scheme\" | \"missing_facilitator\";\n  /** Human-readable error message */\n  message: string;\n}\n\n/**\n * Error thrown when route configuration validation fails.\n */\nexport class RouteConfigurationError extends Error {\n  /** The validation errors that caused this exception */\n  public readonly errors: RouteValidationError[];\n\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors: RouteValidationError[]) {\n    const message = `x402 Route Configuration Errors:\\n${errors.map(e => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n}\n\n/**\n * HTTP-enhanced x402 resource server\n * Provides framework-agnostic HTTP protocol handling\n */\nexport class x402HTTPResourceServer {\n  private ResourceServer: x402ResourceServer;\n  private compiledRoutes: CompiledRoute[] = [];\n  private routesConfig: RoutesConfig;\n  private paywallProvider?: PaywallProvider;\n  private protectedRequestHooks: ProtectedRequestHook[] = [];\n\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer: x402ResourceServer, routes: RoutesConfig) {\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n\n    // Handle both single route and multiple routes\n    const normalizedRoutes =\n      typeof routes === \"object\" && !(\"accepts\" in routes)\n        ? (routes as Record<string, RouteConfig>)\n        : { \"*\": routes as RouteConfig };\n\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config,\n      });\n    }\n  }\n\n  /**\n   * Get the underlying x402ResourceServer instance.\n   *\n   * @returns The underlying x402ResourceServer instance\n   */\n  get server(): x402ResourceServer {\n    return this.ResourceServer;\n  }\n\n  /**\n   * Get the routes configuration.\n   *\n   * @returns The routes configuration\n   */\n  get routes(): RoutesConfig {\n    return this.routesConfig;\n  }\n\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize(): Promise<void> {\n    // First, initialize the underlying resource server (fetches facilitator support)\n    await this.ResourceServer.initialize();\n\n    // Then validate route configuration\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider: PaywallProvider): this {\n    this.paywallProvider = provider;\n    return this;\n  }\n\n  /**\n   * Register a hook that runs on every request to a protected route, before payment processing.\n   * Hooks are executed in order of registration. The first hook to return a non-void result wins.\n   *\n   * @param hook - The request hook function\n   * @returns The x402HTTPResourceServer instance for chaining\n   */\n  onProtectedRequest(hook: ProtectedRequestHook): this {\n    this.protectedRequestHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(\n    context: HTTPRequestContext,\n    paywallConfig?: PaywallConfig,\n  ): Promise<HTTPProcessResult> {\n    const { adapter, path, method } = context;\n\n    // Find matching route\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" }; // No payment required for this route\n    }\n\n    // Execute request hooks before any payment processing\n    for (const hook of this.protectedRequestHooks) {\n      const result = await hook(context, routeConfig);\n      if (result && \"grantAccess\" in result) {\n        return { type: \"no-payment-required\" };\n      }\n      if (result && \"abort\" in result) {\n        return {\n          type: \"payment-error\",\n          response: {\n            status: 403,\n            headers: { \"Content-Type\": \"application/json\" },\n            body: { error: result.reason },\n          },\n        };\n      }\n    }\n\n    // Normalize accepts field to array of payment options\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n\n    // Check for payment header (v1 or v2)\n    const paymentPayload = this.extractPayment(adapter);\n\n    // Create resource info, using config override if provided\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\",\n    };\n\n    // Build requirements from all payment options\n    // (this method handles resolving dynamic functions internally)\n    let requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context,\n    );\n\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n\n    // createPaymentRequiredResponse already handles extension enrichment in the core layer\n    const paymentRequired = await this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : undefined,\n      extensions,\n    );\n\n    // If no payment provided\n    if (!paymentPayload) {\n      // Resolve custom unpaid response body if provided\n      const unpaidBody = routeConfig.unpaidResponseBody\n        ? await routeConfig.unpaidResponseBody(context)\n        : undefined;\n\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody,\n        ),\n      };\n    }\n\n    // Verify payment\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload,\n      );\n\n      if (!matchingRequirements) {\n        const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements,\n      );\n\n      if (!verifyResult.isValid) {\n        const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      // Payment is valid, return data needed for settlement\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements,\n        declaredExtensions: routeConfig.extensions,\n      };\n    } catch (error) {\n      const errorResponse = await this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions,\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n      };\n    }\n  }\n\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @param declaredExtensions - Optional declared extensions (for per-key enrichment)\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n    declaredExtensions?: Record<string, unknown>,\n  ): Promise<ProcessSettleResultResponse> {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(\n        paymentPayload,\n        requirements,\n        declaredExtensions,\n      );\n\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\",\n          errorMessage:\n            settleResponse.errorMessage || settleResponse.errorReason || \"Settlement failed\",\n        };\n      }\n\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse),\n        requirements,\n      };\n    } catch (error) {\n      if (error instanceof SettleError) {\n        return {\n          success: false,\n          errorReason: error.errorReason || error.message,\n          errorMessage: error.errorMessage || error.errorReason || error.message,\n          payer: error.payer,\n          network: error.network,\n          transaction: error.transaction,\n        };\n      }\n      return {\n        success: false,\n        errorReason: error instanceof Error ? error.message : \"Settlement failed\",\n        errorMessage: error instanceof Error ? error.message : \"Settlement failed\",\n        network: requirements.network as Network,\n        transaction: \"\",\n      };\n    }\n  }\n\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context: HTTPRequestContext): boolean {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== undefined;\n  }\n\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  private normalizePaymentOptions(routeConfig: RouteConfig): PaymentOption[] {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  private validateRouteConfiguration(): RouteValidationError[] {\n    const errors: RouteValidationError[] = [];\n\n    // Normalize routes to array of [pattern, config] pairs\n    const normalizedRoutes =\n      typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig)\n        ? Object.entries(this.routesConfig as Record<string, RouteConfig>)\n        : [[\"*\", this.routesConfig as RouteConfig] as [string, RouteConfig]];\n\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n\n      for (const option of paymentOptions) {\n        // Check 1: Is scheme registered?\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n          // Skip facilitator check if scheme isn't registered\n          continue;\n        }\n\n        // Check 2: Does facilitator support this scheme/network combination?\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme,\n        );\n\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  private getRouteConfig(path: string, method: string): RouteConfig | undefined {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n\n    const matchingRoute = this.compiledRoutes.find(\n      route =>\n        route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod),\n    );\n\n    return matchingRoute?.config;\n  }\n\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  private extractPayment(adapter: HTTPAdapter): PaymentPayload | null {\n    // Check v2 header first (PAYMENT-SIGNATURE)\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  private isWebBrowser(adapter: HTTPAdapter): boolean {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  private createHTTPResponse(\n    paymentRequired: PaymentRequired,\n    isWebBrowser: boolean,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n    unpaidResponse?: UnpaidResponseResult,\n  ): HTTPResponseInstructions {\n    // Use 412 Precondition Failed for permit2_allowance_required error\n    // This signals client needs to approve Permit2 before retrying\n    const status = paymentRequired.error === \"permit2_allowance_required\" ? 412 : 402;\n\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true,\n      };\n    }\n\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n\n    // Use callback result if provided, otherwise default to JSON with empty object\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n\n    return {\n      status,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers,\n      },\n      body,\n    };\n  }\n\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  private createHTTPPaymentRequiredResponse(paymentRequired: PaymentRequired): {\n    headers: Record<string, string>;\n  } {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired),\n      },\n    };\n  }\n\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @returns Headers to add to response\n   */\n  private createSettlementHeaders(settleResponse: SettleResponse): Record<string, string> {\n    const encoded = encodePaymentResponseHeader(settleResponse);\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  private parseRoutePattern(pattern: string): { verb: string; regex: RegExp } {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n\n    const regex = new RegExp(\n      `^${\n        path\n          .replace(/[$()+.?^{|}]/g, \"\\\\$&\") // Escape regex special chars\n          .replace(/\\*/g, \".*?\") // Wildcards\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Parameters\n          .replace(/\\//g, \"\\\\/\") // Escape slashes\n      }$`,\n      \"i\",\n    );\n\n    return { verb: verb.toUpperCase(), regex };\n  }\n\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  private normalizePath(path: string): string {\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    let decodedOrRawPath: string;\n    try {\n      decodedOrRawPath = decodeURIComponent(pathWithoutQuery);\n    } catch {\n      decodedOrRawPath = pathWithoutQuery;\n    }\n\n    return decodedOrRawPath\n      .replace(/\\\\/g, \"/\")\n      .replace(/\\/+/g, \"/\")\n      .replace(/(.+?)\\/+$/, \"$1\");\n  }\n\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  private generatePaywallHTML(\n    paymentRequired: PaymentRequired,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n  ): string {\n    if (customHtml) {\n      return customHtml;\n    }\n\n    // Use custom paywall provider if set\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n\n    // Try to use @x402/paywall if available (optional dependency)\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const paywall = require(\"@x402/paywall\");\n      const displayAmount = this.getDisplayAmount(paymentRequired);\n      const resource = paymentRequired.resource;\n\n      return paywall.getPaywallHtml({\n        amount: displayAmount,\n        paymentRequired,\n        currentUrl: resource?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint,\n      });\n    } catch {\n      // @x402/paywall not installed, fall back to basic HTML\n    }\n\n    // Fallback: Basic HTML paywall\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  private getDisplayAmount(paymentRequired: PaymentRequired): number {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        // V2 format\n        return parseFloat(firstReq.amount) / 1000000; // Assuming USDC with 6 decimals\n      }\n    }\n    return 0;\n  }\n}\n"],"mappings":"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","names":["x402Version","error","displayAmount","resource"]}