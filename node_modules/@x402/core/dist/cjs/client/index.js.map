{"version":3,"sources":["../../../src/client/index.ts","../../../src/index.ts","../../../src/utils/index.ts","../../../src/client/x402Client.ts","../../../src/http/index.ts","../../../src/http/x402HTTPClient.ts"],"sourcesContent":["export * from \"./x402Client\";\nexport * from \"../http/x402HTTPClient\";","export const x402Version = 2;\n","import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    const bytes = new TextEncoder().encode(data);\n    const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join(\"\");\n    return globalThis.btoa(binaryString);\n  }\n  return Buffer.from(data, \"utf8\").toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    const binaryString = globalThis.atob(data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    const decoder = new TextDecoder(\"utf-8\");\n    return decoder.decode(bytes);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n","import { x402Version } from \"..\";\nimport { SchemeNetworkClient } from \"../types/mechanisms\";\nimport { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport { Network, PaymentRequired } from \"../types\";\nimport { findByNetworkAndScheme, findSchemesByNetwork } from \"../utils\";\n\n/**\n * Client Hook Context Interfaces\n */\n\nexport interface PaymentCreationContext {\n  paymentRequired: PaymentRequired;\n  selectedRequirements: PaymentRequirements;\n}\n\nexport interface PaymentCreatedContext extends PaymentCreationContext {\n  paymentPayload: PaymentPayload;\n}\n\nexport interface PaymentCreationFailureContext extends PaymentCreationContext {\n  error: Error;\n}\n\n/**\n * Client Hook Type Definitions\n */\n\nexport type BeforePaymentCreationHook = (\n  context: PaymentCreationContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterPaymentCreationHook = (context: PaymentCreatedContext) => Promise<void>;\n\nexport type OnPaymentCreationFailureHook = (\n  context: PaymentCreationFailureContext,\n) => Promise<void | { recovered: true; payload: PaymentPayload }>;\n\nexport type SelectPaymentRequirements = (x402Version: number, paymentRequirements: PaymentRequirements[]) => PaymentRequirements;\n\n/**\n * A policy function that filters or transforms payment requirements.\n * Policies are applied in order before the selector chooses the final option.\n *\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - Array of payment requirements to filter/transform\n * @returns Filtered array of payment requirements\n */\nexport type PaymentPolicy = (x402Version: number, paymentRequirements: PaymentRequirements[]) => PaymentRequirements[];\n\n\n/**\n * Configuration for registering a payment scheme with a specific network\n */\nexport interface SchemeRegistration {\n  /**\n   * The network identifier (e.g., 'eip155:8453', 'solana:mainnet')\n   */\n  network: Network;\n\n  /**\n   * The scheme client implementation for this network\n   */\n  client: SchemeNetworkClient;\n\n  /**\n   * The x402 protocol version to use for this scheme\n   *\n   * @default 2\n   */\n  x402Version?: number;\n}\n\n/**\n * Configuration options for the fetch wrapper\n */\nexport interface x402ClientConfig {\n  /**\n   * Array of scheme registrations defining which payment methods are supported\n   */\n  schemes: SchemeRegistration[];\n\n  /**\n   * Policies to apply to the client\n   */\n  policies?: PaymentPolicy[];\n\n  /**\n   * Custom payment requirements selector function\n   * If not provided, uses the default selector (first available option)\n   */\n  paymentRequirementsSelector?: SelectPaymentRequirements;\n}\n\n/**\n * Core client for managing x402 payment schemes and creating payment payloads.\n *\n * Handles registration of payment schemes, policy-based filtering of payment requirements,\n * and creation of payment payloads based on server requirements.\n */\nexport class x402Client {\n  private readonly paymentRequirementsSelector: SelectPaymentRequirements;\n  private readonly registeredClientSchemes: Map<number, Map<string, Map<string, SchemeNetworkClient>>> = new Map();\n  private readonly policies: PaymentPolicy[] = [];\n\n  private beforePaymentCreationHooks: BeforePaymentCreationHook[] = [];\n  private afterPaymentCreationHooks: AfterPaymentCreationHook[] = [];\n  private onPaymentCreationFailureHooks: OnPaymentCreationFailureHook[] = [];\n\n  /**\n   * Creates a new x402Client instance.\n   *\n   * @param paymentRequirementsSelector - Function to select payment requirements from available options\n   */\n  constructor(paymentRequirementsSelector?: SelectPaymentRequirements) {\n    this.paymentRequirementsSelector = paymentRequirementsSelector || ((x402Version, accepts) => accepts[0]);\n  }\n\n  /**\n   * Creates a new x402Client instance from a configuration object.\n   *\n   * @param config - The client configuration including schemes, policies, and payment requirements selector\n   * @returns A configured x402Client instance\n   */\n  static fromConfig(config: x402ClientConfig): x402Client {\n    const client = new x402Client(config.paymentRequirementsSelector);\n    config.schemes.forEach(scheme => {\n      if (scheme.x402Version === 1) {\n        client.registerV1(scheme.network, scheme.client);\n      } else {\n        client.register(scheme.network, scheme.client);\n      }\n    });\n    config.policies?.forEach(policy => {\n      client.registerPolicy(policy);\n    });\n    return client;\n  }\n\n  /**\n   * Registers a scheme client for the current x402 version.\n   *\n   * @param network - The network to register the client for\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  register(network: Network, client: SchemeNetworkClient): x402Client {\n    return this._registerScheme(x402Version, network, client);\n  }\n\n  /**\n   * Registers a scheme client for x402 version 1.\n   *\n   * @param network - The v1 network identifier (e.g., 'base-sepolia', 'solana-devnet')\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  registerV1(network: string, client: SchemeNetworkClient): x402Client {\n    return this._registerScheme(1, network as Network, client);\n  }\n\n  /**\n   * Registers a policy to filter or transform payment requirements.\n   *\n   * Policies are applied in order after filtering by registered schemes\n   * and before the selector chooses the final payment requirement.\n   *\n   * @param policy - Function to filter/transform payment requirements\n   * @returns The x402Client instance for chaining\n   *\n   * @example\n   * ```typescript\n   * // Prefer cheaper options\n   * client.registerPolicy((version, reqs) =>\n   *   reqs.filter(r => BigInt(r.value) < BigInt('1000000'))\n   * );\n   *\n   * // Prefer specific networks\n   * client.registerPolicy((version, reqs) =>\n   *   reqs.filter(r => r.network.startsWith('eip155:'))\n   * );\n   * ```\n   */\n  registerPolicy(policy: PaymentPolicy): x402Client {\n    this.policies.push(policy);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment payload creation.\n   * Can abort creation by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onBeforePaymentCreation(hook: BeforePaymentCreationHook): x402Client {\n    this.beforePaymentCreationHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment payload creation.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onAfterPaymentCreation(hook: AfterPaymentCreationHook): x402Client {\n    this.afterPaymentCreationHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment payload creation fails.\n   * Can recover from failure by returning { recovered: true, payload: PaymentPayload }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onPaymentCreationFailure(hook: OnPaymentCreationFailureHook): x402Client {\n    this.onPaymentCreationFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Creates a payment payload based on a PaymentRequired response.\n   *\n   * Automatically extracts x402Version, resource, and extensions from the PaymentRequired\n   * response and constructs a complete PaymentPayload with the accepted requirements.\n   *\n   * @param paymentRequired - The PaymentRequired response from the server\n   * @returns Promise resolving to the complete payment payload\n   */\n  async createPaymentPayload(\n    paymentRequired: PaymentRequired,\n  ): Promise<PaymentPayload> {\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(paymentRequired.x402Version);\n    if (!clientSchemesByNetwork) {\n      throw new Error(`No client registered for x402 version: ${paymentRequired.x402Version}`);\n    }\n\n    const requirements = this.selectPaymentRequirements(paymentRequired.x402Version, paymentRequired.accepts);\n\n    const context: PaymentCreationContext = {\n      paymentRequired,\n      selectedRequirements: requirements,\n    };\n\n    // Execute beforePaymentCreation hooks\n    for (const hook of this.beforePaymentCreationHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Payment creation aborted: ${result.reason}`);\n      }\n    }\n\n    try {\n      const schemeNetworkClient = findByNetworkAndScheme(clientSchemesByNetwork, requirements.scheme, requirements.network);\n      if (!schemeNetworkClient) {\n        throw new Error(`No client registered for scheme: ${requirements.scheme} and network: ${requirements.network}`);\n      }\n\n      const partialPayload = await schemeNetworkClient.createPaymentPayload(paymentRequired.x402Version, requirements);\n\n      let paymentPayload: PaymentPayload;\n      if (partialPayload.x402Version == 1) {\n        paymentPayload = partialPayload as PaymentPayload;\n      } else {\n        paymentPayload = {\n          ...partialPayload,\n          extensions: paymentRequired.extensions,\n          resource: paymentRequired.resource,\n          accepted: requirements,\n        };\n      }\n\n      // Execute afterPaymentCreation hooks\n      const createdContext: PaymentCreatedContext = {\n        ...context,\n        paymentPayload,\n      };\n\n      for (const hook of this.afterPaymentCreationHooks) {\n        await hook(createdContext);\n      }\n\n      return paymentPayload;\n    } catch (error) {\n      const failureContext: PaymentCreationFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onPaymentCreationFailure hooks\n      for (const hook of this.onPaymentCreationFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.payload;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n\n\n  /**\n   * Selects appropriate payment requirements based on registered clients and policies.\n   *\n   * Selection process:\n   * 1. Filter by registered schemes (network + scheme support)\n   * 2. Apply all registered policies in order\n   * 3. Use selector to choose final requirement\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - Array of available payment requirements\n   * @returns The selected payment requirements\n   */\n  private selectPaymentRequirements(x402Version: number, paymentRequirements: PaymentRequirements[]): PaymentRequirements {\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(x402Version);\n    if (!clientSchemesByNetwork) {\n      throw new Error(`No client registered for x402 version: ${x402Version}`);\n    }\n\n    // Step 1: Filter by registered schemes\n    const supportedPaymentRequirements = paymentRequirements.filter(requirement => {\n      let clientSchemes = findSchemesByNetwork(clientSchemesByNetwork, requirement.network);\n      if (!clientSchemes) {\n        return false;\n      }\n\n      return clientSchemes.has(requirement.scheme);\n    })\n\n    if (supportedPaymentRequirements.length === 0) {\n      throw new Error(`No network/scheme registered for x402 version: ${x402Version} which comply with the payment requirements. ${JSON.stringify({\n        x402Version,\n        paymentRequirements,\n        x402Versions: Array.from(this.registeredClientSchemes.keys()),\n        networks: Array.from(clientSchemesByNetwork.keys()),\n        schemes: Array.from(clientSchemesByNetwork.values()).map(schemes => Array.from(schemes.keys())).flat(),\n      })}`);\n    }\n\n    // Step 2: Apply all policies in order\n    let filteredRequirements = supportedPaymentRequirements;\n    for (const policy of this.policies) {\n      filteredRequirements = policy(x402Version, filteredRequirements);\n\n      if (filteredRequirements.length === 0) {\n        throw new Error(`All payment requirements were filtered out by policies for x402 version: ${x402Version}`);\n      }\n    }\n\n    // Step 3: Use selector to choose final requirement\n    return this.paymentRequirementsSelector(x402Version, filteredRequirements);\n  }\n\n  /**\n   * Internal method to register a scheme client.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param network - The network to register the client for\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  private _registerScheme(x402Version: number, network: Network, client: SchemeNetworkClient): x402Client {\n    if (!this.registeredClientSchemes.has(x402Version)) {\n      this.registeredClientSchemes.set(x402Version, new Map());\n    }\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(x402Version)!;\n    if (!clientSchemesByNetwork.has(network)) {\n      clientSchemesByNetwork.set(network, new Map());\n    }\n\n    const clientByScheme = clientSchemesByNetwork.get(network)!;\n    if (!clientByScheme.has(client.scheme)) {\n      clientByScheme.set(client.scheme, client);\n    }\n\n    return this;\n  }\n}\n","import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(paymentResponse: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n  ProtectedRequestHook,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient, PaymentRequiredContext, PaymentRequiredHook } from \"./x402HTTPClient\";\n","import {\n  decodePaymentRequiredHeader,\n  decodePaymentResponseHeader,\n  encodePaymentSignatureHeader,\n} from \".\";\nimport { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { x402Client } from \"../client/x402Client\";\n\n/**\n * Context provided to onPaymentRequired hooks.\n */\nexport interface PaymentRequiredContext {\n  paymentRequired: PaymentRequired;\n}\n\n/**\n * Hook called when a 402 response is received, before payment processing.\n * Return headers to try before payment, or void to proceed directly to payment.\n */\nexport type PaymentRequiredHook = (\n  context: PaymentRequiredContext,\n) => Promise<{ headers: Record<string, string> } | void>;\n\n/**\n * HTTP-specific client for handling x402 payment protocol over HTTP.\n *\n * Wraps a x402Client to provide HTTP-specific encoding/decoding functionality\n * for payment headers and responses while maintaining the builder pattern.\n */\nexport class x402HTTPClient {\n  private paymentRequiredHooks: PaymentRequiredHook[] = [];\n\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(private readonly client: x402Client) {}\n\n  /**\n   * Register a hook to handle 402 responses before payment.\n   * Hooks run in order; first to return headers wins.\n   *\n   * @param hook - The hook function to register\n   * @returns This instance for chaining\n   */\n  onPaymentRequired(hook: PaymentRequiredHook): this {\n    this.paymentRequiredHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Run hooks and return headers if any hook provides them.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Headers to use for retry, or null to proceed to payment\n   */\n  async handlePaymentRequired(\n    paymentRequired: PaymentRequired,\n  ): Promise<Record<string, string> | null> {\n    for (const hook of this.paymentRequiredHooks) {\n      const result = await hook({ paymentRequired });\n      if (result?.headers) {\n        return result.headers;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload: PaymentPayload): Record<string, string> {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(\n    getHeader: (name: string) => string | null | undefined,\n    body?: unknown,\n  ): PaymentRequired {\n    // v2\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n\n    // v1\n    if (\n      body &&\n      body instanceof Object &&\n      \"x402Version\" in body &&\n      (body as PaymentRequired).x402Version === 1\n    ) {\n      return body as PaymentRequired;\n    }\n\n    throw new Error(\"Invalid payment required response\");\n  }\n\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader: (name: string) => string | null | undefined): SettleResponse {\n    // v2\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n\n    // v1\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n\n    throw new Error(\"Payment response header not found\");\n  }\n\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired: PaymentRequired): Promise<PaymentPayload> {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n}\n"],"mappings":"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","names":["x402Version"]}