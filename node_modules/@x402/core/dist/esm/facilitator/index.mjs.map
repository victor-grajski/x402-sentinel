{"version":3,"sources":["../../../src/facilitator/x402Facilitator.ts"],"sourcesContent":["import { x402Version } from \"..\";\nimport { SettleResponse, VerifyResponse } from \"../types/facilitator\";\nimport { SchemeNetworkFacilitator } from \"../types/mechanisms\";\nimport { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport { Network } from \"../types\";\nimport { type SchemeData } from \"../utils\";\n\n/**\n * Facilitator Hook Context Interfaces\n */\n\nexport interface FacilitatorVerifyContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface FacilitatorVerifyResultContext extends FacilitatorVerifyContext {\n  result: VerifyResponse;\n}\n\nexport interface FacilitatorVerifyFailureContext extends FacilitatorVerifyContext {\n  error: Error;\n}\n\nexport interface FacilitatorSettleContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface FacilitatorSettleResultContext extends FacilitatorSettleContext {\n  result: SettleResponse;\n}\n\nexport interface FacilitatorSettleFailureContext extends FacilitatorSettleContext {\n  error: Error;\n}\n\n/**\n * Facilitator Hook Type Definitions\n */\n\nexport type FacilitatorBeforeVerifyHook = (\n  context: FacilitatorVerifyContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type FacilitatorAfterVerifyHook = (context: FacilitatorVerifyResultContext) => Promise<void>;\n\nexport type FacilitatorOnVerifyFailureHook = (\n  context: FacilitatorVerifyFailureContext,\n) => Promise<void | { recovered: true; result: VerifyResponse }>;\n\nexport type FacilitatorBeforeSettleHook = (\n  context: FacilitatorSettleContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type FacilitatorAfterSettleHook = (context: FacilitatorSettleResultContext) => Promise<void>;\n\nexport type FacilitatorOnSettleFailureHook = (\n  context: FacilitatorSettleFailureContext,\n) => Promise<void | { recovered: true; result: SettleResponse }>;\n\n/**\n * Facilitator client for the x402 payment protocol.\n * Manages payment scheme registration, verification, and settlement.\n */\nexport class x402Facilitator {\n  private readonly registeredFacilitatorSchemes: Map<\n    number,\n    SchemeData<SchemeNetworkFacilitator>[] // Array to support multiple facilitators per version\n  > = new Map();\n  private readonly extensions: string[] = [];\n\n  private beforeVerifyHooks: FacilitatorBeforeVerifyHook[] = [];\n  private afterVerifyHooks: FacilitatorAfterVerifyHook[] = [];\n  private onVerifyFailureHooks: FacilitatorOnVerifyFailureHook[] = [];\n  private beforeSettleHooks: FacilitatorBeforeSettleHook[] = [];\n  private afterSettleHooks: FacilitatorAfterSettleHook[] = [];\n  private onSettleFailureHooks: FacilitatorOnSettleFailureHook[] = [];\n\n  /**\n   * Registers a scheme facilitator for the current x402 version.\n   * Networks are stored and used for getSupported() - no need to specify them later.\n   *\n   * @param networks - Single network or array of networks this facilitator supports\n   * @param facilitator - The scheme network facilitator to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  register(networks: Network | Network[], facilitator: SchemeNetworkFacilitator): x402Facilitator {\n    const networksArray = Array.isArray(networks) ? networks : [networks];\n    return this._registerScheme(x402Version, networksArray, facilitator);\n  }\n\n  /**\n   * Registers a scheme facilitator for x402 version 1.\n   * Networks are stored and used for getSupported() - no need to specify them later.\n   *\n   * @param networks - Single network or array of networks this facilitator supports\n   * @param facilitator - The scheme network facilitator to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  registerV1(\n    networks: Network | Network[],\n    facilitator: SchemeNetworkFacilitator,\n  ): x402Facilitator {\n    const networksArray = Array.isArray(networks) ? networks : [networks];\n    return this._registerScheme(1, networksArray, facilitator);\n  }\n\n  /**\n   * Registers a protocol extension.\n   *\n   * @param extension - The extension name to register (e.g., \"bazaar\", \"sign_in_with_x\")\n   * @returns The x402Facilitator instance for chaining\n   */\n  registerExtension(extension: string): x402Facilitator {\n    // Check if already registered\n    if (!this.extensions.includes(extension)) {\n      this.extensions.push(extension);\n    }\n    return this;\n  }\n\n  /**\n   * Gets the list of registered extensions.\n   *\n   * @returns Array of extension names\n   */\n  getExtensions(): string[] {\n    return [...this.extensions];\n  }\n\n  /**\n   * Register a hook to execute before facilitator payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onBeforeVerify(hook: FacilitatorBeforeVerifyHook): x402Facilitator {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful facilitator payment verification (isValid: true).\n   * This hook is NOT called when verification fails (isValid: false) - use onVerifyFailure for that.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onAfterVerify(hook: FacilitatorAfterVerifyHook): x402Facilitator {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when facilitator payment verification fails.\n   * Called when: verification returns isValid: false, or an exception is thrown during verification.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onVerifyFailure(hook: FacilitatorOnVerifyFailureHook): x402Facilitator {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before facilitator payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onBeforeSettle(hook: FacilitatorBeforeSettleHook): x402Facilitator {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful facilitator payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onAfterSettle(hook: FacilitatorAfterSettleHook): x402Facilitator {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when facilitator payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  onSettleFailure(hook: FacilitatorOnSettleFailureHook): x402Facilitator {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Gets supported payment kinds, extensions, and signers.\n   * Uses networks registered during register() calls - no parameters needed.\n   * Returns flat array format for backward compatibility with V1 clients.\n   *\n   * @returns Supported response with kinds as array (with version in each element), extensions, and signers\n   */\n  getSupported(): {\n    kinds: Array<{\n      x402Version: number;\n      scheme: string;\n      network: string;\n      extra?: Record<string, unknown>;\n    }>;\n    extensions: string[];\n    signers: Record<string, string[]>;\n  } {\n    const kinds: Array<{\n      x402Version: number;\n      scheme: string;\n      network: string;\n      extra?: Record<string, unknown>;\n    }> = [];\n    const signersByFamily: Record<string, Set<string>> = {};\n\n    // Iterate over registered scheme data (array supports multiple facilitators per version)\n    for (const [version, schemeDataArray] of this.registeredFacilitatorSchemes) {\n      for (const schemeData of schemeDataArray) {\n        const { facilitator, networks } = schemeData;\n        const scheme = facilitator.scheme;\n\n        // Iterate over stored concrete networks\n        for (const network of networks) {\n          const extra = facilitator.getExtra(network);\n          kinds.push({\n            x402Version: version,\n            scheme,\n            network,\n            ...(extra && { extra }),\n          });\n\n          // Collect signers by CAIP family for this network\n          const family = facilitator.caipFamily;\n          if (!signersByFamily[family]) {\n            signersByFamily[family] = new Set();\n          }\n          facilitator.getSigners(network).forEach(signer => signersByFamily[family].add(signer));\n        }\n      }\n    }\n\n    // Convert signer sets to arrays\n    const signers: Record<string, string[]> = {};\n    for (const [family, signerSet] of Object.entries(signersByFamily)) {\n      signers[family] = Array.from(signerSet);\n    }\n\n    return {\n      kinds,\n      extensions: this.extensions,\n      signers,\n    };\n  }\n\n  /**\n   * Verifies a payment payload against requirements.\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param paymentRequirements - The payment requirements to verify against\n   * @returns Promise resolving to the verification response\n   */\n  async verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const context: FacilitatorVerifyContext = {\n      paymentPayload,\n      requirements: paymentRequirements,\n    };\n\n    // Execute beforeVerify hooks\n    for (const hook of this.beforeVerifyHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        return {\n          isValid: false,\n          invalidReason: result.reason,\n        };\n      }\n    }\n\n    try {\n      const schemeDataArray = this.registeredFacilitatorSchemes.get(paymentPayload.x402Version);\n      if (!schemeDataArray) {\n        throw new Error(\n          `No facilitator registered for x402 version: ${paymentPayload.x402Version}`,\n        );\n      }\n\n      // Find matching facilitator from array\n      let schemeNetworkFacilitator: SchemeNetworkFacilitator | undefined;\n      for (const schemeData of schemeDataArray) {\n        if (schemeData.facilitator.scheme === paymentRequirements.scheme) {\n          // Check if network matches\n          if (schemeData.networks.has(paymentRequirements.network)) {\n            schemeNetworkFacilitator = schemeData.facilitator;\n            break;\n          }\n          // Try pattern matching\n          const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n          if (patternRegex.test(paymentRequirements.network)) {\n            schemeNetworkFacilitator = schemeData.facilitator;\n            break;\n          }\n        }\n      }\n\n      if (!schemeNetworkFacilitator) {\n        throw new Error(\n          `No facilitator registered for scheme: ${paymentRequirements.scheme} and network: ${paymentRequirements.network}`,\n        );\n      }\n\n      const verifyResult = await schemeNetworkFacilitator.verify(\n        paymentPayload,\n        paymentRequirements,\n      );\n\n      // Check if verification failed (isValid: false)\n      if (!verifyResult.isValid) {\n        const failureContext: FacilitatorVerifyFailureContext = {\n          ...context,\n          error: new Error(verifyResult.invalidReason || \"Verification failed\"),\n        };\n\n        // Execute onVerifyFailure hooks\n        for (const hook of this.onVerifyFailureHooks) {\n          const result = await hook(failureContext);\n          if (result && \"recovered\" in result && result.recovered) {\n            // If recovered, execute afterVerify hooks with recovered result\n            const recoveredContext: FacilitatorVerifyResultContext = {\n              ...context,\n              result: result.result,\n            };\n            for (const hook of this.afterVerifyHooks) {\n              await hook(recoveredContext);\n            }\n            return result.result;\n          }\n        }\n\n        return verifyResult;\n      }\n\n      // Execute afterVerify hooks only for successful verification\n      const resultContext: FacilitatorVerifyResultContext = {\n        ...context,\n        result: verifyResult,\n      };\n\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n\n      return verifyResult;\n    } catch (error) {\n      const failureContext: FacilitatorVerifyFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onVerifyFailure hooks\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Settles a payment based on the payload and requirements.\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param paymentRequirements - The payment requirements for settlement\n   * @returns Promise resolving to the settlement response\n   */\n  async settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const context: FacilitatorSettleContext = {\n      paymentPayload,\n      requirements: paymentRequirements,\n    };\n\n    // Execute beforeSettle hooks\n    for (const hook of this.beforeSettleHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Settlement aborted: ${result.reason}`);\n      }\n    }\n\n    try {\n      const schemeDataArray = this.registeredFacilitatorSchemes.get(paymentPayload.x402Version);\n      if (!schemeDataArray) {\n        throw new Error(\n          `No facilitator registered for x402 version: ${paymentPayload.x402Version}`,\n        );\n      }\n\n      // Find matching facilitator from array\n      let schemeNetworkFacilitator: SchemeNetworkFacilitator | undefined;\n      for (const schemeData of schemeDataArray) {\n        if (schemeData.facilitator.scheme === paymentRequirements.scheme) {\n          // Check if network matches\n          if (schemeData.networks.has(paymentRequirements.network)) {\n            schemeNetworkFacilitator = schemeData.facilitator;\n            break;\n          }\n          // Try pattern matching\n          const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n          if (patternRegex.test(paymentRequirements.network)) {\n            schemeNetworkFacilitator = schemeData.facilitator;\n            break;\n          }\n        }\n      }\n\n      if (!schemeNetworkFacilitator) {\n        throw new Error(\n          `No facilitator registered for scheme: ${paymentRequirements.scheme} and network: ${paymentRequirements.network}`,\n        );\n      }\n\n      const settleResult = await schemeNetworkFacilitator.settle(\n        paymentPayload,\n        paymentRequirements,\n      );\n\n      // Execute afterSettle hooks\n      const resultContext: FacilitatorSettleResultContext = {\n        ...context,\n        result: settleResult,\n      };\n\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n\n      return settleResult;\n    } catch (error) {\n      const failureContext: FacilitatorSettleFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onSettleFailure hooks\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Internal method to register a scheme facilitator.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param networks - Array of concrete networks this facilitator supports\n   * @param facilitator - The scheme network facilitator to register\n   * @returns The x402Facilitator instance for chaining\n   */\n  private _registerScheme(\n    x402Version: number,\n    networks: Network[],\n    facilitator: SchemeNetworkFacilitator,\n  ): x402Facilitator {\n    if (!this.registeredFacilitatorSchemes.has(x402Version)) {\n      this.registeredFacilitatorSchemes.set(x402Version, []);\n    }\n    const schemeDataArray = this.registeredFacilitatorSchemes.get(x402Version)!;\n\n    // Add new scheme data (supports multiple facilitators with same scheme name)\n    schemeDataArray.push({\n      facilitator,\n      networks: new Set(networks),\n      pattern: this.derivePattern(networks),\n    });\n\n    return this;\n  }\n\n  /**\n   * Derives a wildcard pattern from an array of networks.\n   * If all networks share the same namespace, returns wildcard pattern.\n   * Otherwise returns the first network for exact matching.\n   *\n   * @param networks - Array of networks\n   * @returns Derived pattern for matching\n   */\n  private derivePattern(networks: Network[]): Network {\n    if (networks.length === 0) return \"\" as Network;\n    if (networks.length === 1) return networks[0];\n\n    // Extract namespaces (e.g., \"eip155\" from \"eip155:84532\")\n    const namespaces = networks.map(n => n.split(\":\")[0]);\n    const uniqueNamespaces = new Set(namespaces);\n\n    // If all same namespace, use wildcard\n    if (uniqueNamespaces.size === 1) {\n      return `${namespaces[0]}:*` as Network;\n    }\n\n    // Mixed namespaces - use first network for exact matching\n    return networks[0];\n  }\n}\n"],"mappings":"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","names":["hook","x402Version"]}