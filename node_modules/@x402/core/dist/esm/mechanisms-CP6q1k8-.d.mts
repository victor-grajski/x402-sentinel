type PaymentRequirementsV1 = {
    scheme: string;
    network: Network;
    maxAmountRequired: string;
    resource: string;
    description: string;
    mimeType: string;
    outputSchema: Record<string, unknown>;
    payTo: string;
    maxTimeoutSeconds: number;
    asset: string;
    extra: Record<string, unknown>;
};
type PaymentRequiredV1 = {
    x402Version: 1;
    error?: string;
    accepts: PaymentRequirementsV1[];
};
type PaymentPayloadV1 = {
    x402Version: 1;
    scheme: string;
    network: Network;
    payload: Record<string, unknown>;
};
type VerifyRequestV1 = {
    paymentPayload: PaymentPayloadV1;
    paymentRequirements: PaymentRequirementsV1;
};
type SettleRequestV1 = {
    paymentPayload: PaymentPayloadV1;
    paymentRequirements: PaymentRequirementsV1;
};
type SettleResponseV1 = {
    success: boolean;
    errorReason?: string;
    errorMessage?: string;
    payer?: string;
    transaction: string;
    network: Network;
};
type SupportedResponseV1 = {
    kinds: {
        x402Version: number;
        scheme: string;
        network: Network;
        extra?: Record<string, unknown>;
    }[];
};

interface FacilitatorConfig {
    url?: string;
    createAuthHeaders?: () => Promise<{
        verify: Record<string, string>;
        settle: Record<string, string>;
        supported: Record<string, string>;
    }>;
}
/**
 * Interface for facilitator clients
 * Can be implemented for HTTP-based or local facilitators
 */
interface FacilitatorClient {
    /**
     * Verify a payment with the facilitator
     *
     * @param paymentPayload - The payment to verify
     * @param paymentRequirements - The requirements to verify against
     * @returns Verification response
     */
    verify(paymentPayload: PaymentPayload, paymentRequirements: PaymentRequirements): Promise<VerifyResponse>;
    /**
     * Settle a payment with the facilitator
     *
     * @param paymentPayload - The payment to settle
     * @param paymentRequirements - The requirements for settlement
     * @returns Settlement response
     */
    settle(paymentPayload: PaymentPayload, paymentRequirements: PaymentRequirements): Promise<SettleResponse>;
    /**
     * Get supported payment kinds and extensions from the facilitator
     *
     * @returns Supported payment kinds and extensions
     */
    getSupported(): Promise<SupportedResponse>;
}
/**
 * HTTP-based client for interacting with x402 facilitator services
 * Handles HTTP communication with facilitator endpoints
 */
declare class HTTPFacilitatorClient implements FacilitatorClient {
    readonly url: string;
    private readonly _createAuthHeaders?;
    /**
     * Creates a new HTTPFacilitatorClient instance.
     *
     * @param config - Configuration options for the facilitator client
     */
    constructor(config?: FacilitatorConfig);
    /**
     * Verify a payment with the facilitator
     *
     * @param paymentPayload - The payment to verify
     * @param paymentRequirements - The requirements to verify against
     * @returns Verification response
     */
    verify(paymentPayload: PaymentPayload, paymentRequirements: PaymentRequirements): Promise<VerifyResponse>;
    /**
     * Settle a payment with the facilitator
     *
     * @param paymentPayload - The payment to settle
     * @param paymentRequirements - The requirements for settlement
     * @returns Settlement response
     */
    settle(paymentPayload: PaymentPayload, paymentRequirements: PaymentRequirements): Promise<SettleResponse>;
    /**
     * Get supported payment kinds and extensions from the facilitator
     *
     * @returns Supported payment kinds and extensions
     */
    getSupported(): Promise<SupportedResponse>;
    /**
     * Creates authentication headers for a specific path.
     *
     * @param path - The path to create authentication headers for (e.g., "verify", "settle", "supported")
     * @returns An object containing the authentication headers for the specified path
     */
    createAuthHeaders(path: string): Promise<{
        headers: Record<string, string>;
    }>;
    /**
     * Helper to convert objects to JSON-safe format.
     * Handles BigInt and other non-JSON types.
     *
     * @param obj - The object to convert
     * @returns The JSON-safe representation of the object
     */
    private toJsonSafe;
}

/**
 * Configuration for a protected resource
 * Only contains payment-specific configuration, not resource metadata
 */
interface ResourceConfig {
    scheme: string;
    payTo: string;
    price: Price;
    network: Network;
    maxTimeoutSeconds?: number;
    extra?: Record<string, unknown>;
}
/**
 * Resource information for PaymentRequired response
 */
interface ResourceInfo$1 {
    url: string;
    description: string;
    mimeType: string;
}
/**
 * Lifecycle Hook Context Interfaces
 */
interface PaymentRequiredContext {
    requirements: PaymentRequirements[];
    resourceInfo: ResourceInfo$1;
    error?: string;
    paymentRequiredResponse: PaymentRequired;
}
interface VerifyContext {
    paymentPayload: PaymentPayload;
    requirements: PaymentRequirements;
}
interface VerifyResultContext extends VerifyContext {
    result: VerifyResponse;
}
interface VerifyFailureContext extends VerifyContext {
    error: Error;
}
interface SettleContext {
    paymentPayload: PaymentPayload;
    requirements: PaymentRequirements;
}
interface SettleResultContext extends SettleContext {
    result: SettleResponse;
}
interface SettleFailureContext extends SettleContext {
    error: Error;
}
/**
 * Lifecycle Hook Type Definitions
 */
type BeforeVerifyHook = (context: VerifyContext) => Promise<void | {
    abort: true;
    reason: string;
    message?: string;
}>;
type AfterVerifyHook = (context: VerifyResultContext) => Promise<void>;
type OnVerifyFailureHook = (context: VerifyFailureContext) => Promise<void | {
    recovered: true;
    result: VerifyResponse;
}>;
type BeforeSettleHook = (context: SettleContext) => Promise<void | {
    abort: true;
    reason: string;
    message?: string;
}>;
type AfterSettleHook = (context: SettleResultContext) => Promise<void>;
type OnSettleFailureHook = (context: SettleFailureContext) => Promise<void | {
    recovered: true;
    result: SettleResponse;
}>;
/**
 * Core x402 protocol server for resource protection
 * Transport-agnostic implementation of the x402 payment protocol
 */
declare class x402ResourceServer {
    private facilitatorClients;
    private registeredServerSchemes;
    private supportedResponsesMap;
    private facilitatorClientsMap;
    private registeredExtensions;
    private beforeVerifyHooks;
    private afterVerifyHooks;
    private onVerifyFailureHooks;
    private beforeSettleHooks;
    private afterSettleHooks;
    private onSettleFailureHooks;
    /**
     * Creates a new x402ResourceServer instance.
     *
     * @param facilitatorClients - Optional facilitator client(s) for payment processing
     */
    constructor(facilitatorClients?: FacilitatorClient | FacilitatorClient[]);
    /**
     * Register a scheme/network server implementation.
     *
     * @param network - The network identifier
     * @param server - The scheme/network server implementation
     * @returns The x402ResourceServer instance for chaining
     */
    register(network: Network, server: SchemeNetworkServer): x402ResourceServer;
    /**
     * Check if a scheme is registered for a given network.
     *
     * @param network - The network identifier
     * @param scheme - The payment scheme name
     * @returns True if the scheme is registered for the network, false otherwise
     */
    hasRegisteredScheme(network: Network, scheme: string): boolean;
    /**
     * Registers a resource service extension that can enrich extension declarations.
     *
     * @param extension - The extension to register
     * @returns The x402ResourceServer instance for chaining
     */
    registerExtension(extension: ResourceServerExtension): this;
    /**
     * Check if an extension is registered.
     *
     * @param key - The extension key
     * @returns True if the extension is registered
     */
    hasExtension(key: string): boolean;
    /**
     * Get all registered extensions.
     *
     * @returns Array of registered extensions
     */
    getExtensions(): ResourceServerExtension[];
    /**
     * Enriches declared extensions using registered extension hooks.
     *
     * @param declaredExtensions - Extensions declared on the route
     * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)
     * @returns Enriched extensions map
     */
    enrichExtensions(declaredExtensions: Record<string, unknown>, transportContext: unknown): Record<string, unknown>;
    /**
     * Register a hook to execute before payment verification.
     * Can abort verification by returning { abort: true, reason: string }
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onBeforeVerify(hook: BeforeVerifyHook): x402ResourceServer;
    /**
     * Register a hook to execute after successful payment verification.
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onAfterVerify(hook: AfterVerifyHook): x402ResourceServer;
    /**
     * Register a hook to execute when payment verification fails.
     * Can recover from failure by returning { recovered: true, result: VerifyResponse }
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onVerifyFailure(hook: OnVerifyFailureHook): x402ResourceServer;
    /**
     * Register a hook to execute before payment settlement.
     * Can abort settlement by returning { abort: true, reason: string }
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onBeforeSettle(hook: BeforeSettleHook): x402ResourceServer;
    /**
     * Register a hook to execute after successful payment settlement.
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onAfterSettle(hook: AfterSettleHook): x402ResourceServer;
    /**
     * Register a hook to execute when payment settlement fails.
     * Can recover from failure by returning { recovered: true, result: SettleResponse }
     *
     * @param hook - The hook function to register
     * @returns The x402ResourceServer instance for chaining
     */
    onSettleFailure(hook: OnSettleFailureHook): x402ResourceServer;
    /**
     * Initialize by fetching supported kinds from all facilitators
     * Creates mappings for supported responses and facilitator clients
     * Earlier facilitators in the array get precedence
     */
    initialize(): Promise<void>;
    /**
     * Get supported kind for a specific version, network, and scheme
     *
     * @param x402Version - The x402 version
     * @param network - The network identifier
     * @param scheme - The payment scheme
     * @returns The supported kind or undefined if not found
     */
    getSupportedKind(x402Version: number, network: Network, scheme: string): SupportedKind | undefined;
    /**
     * Get facilitator extensions for a specific version, network, and scheme
     *
     * @param x402Version - The x402 version
     * @param network - The network identifier
     * @param scheme - The payment scheme
     * @returns The facilitator extensions or empty array if not found
     */
    getFacilitatorExtensions(x402Version: number, network: Network, scheme: string): string[];
    /**
     * Build payment requirements for a protected resource
     *
     * @param resourceConfig - Configuration for the protected resource
     * @returns Array of payment requirements
     */
    buildPaymentRequirements(resourceConfig: ResourceConfig): Promise<PaymentRequirements[]>;
    /**
     * Build payment requirements from multiple payment options
     * This method handles resolving dynamic payTo/price functions and builds requirements for each option
     *
     * @param paymentOptions - Array of payment options to convert
     * @param context - HTTP request context for resolving dynamic functions
     * @returns Array of payment requirements (one per option)
     */
    buildPaymentRequirementsFromOptions<TContext = unknown>(paymentOptions: Array<{
        scheme: string;
        payTo: string | ((context: TContext) => string | Promise<string>);
        price: Price | ((context: TContext) => Price | Promise<Price>);
        network: Network;
        maxTimeoutSeconds?: number;
    }>, context: TContext): Promise<PaymentRequirements[]>;
    /**
     * Create a payment required response
     *
     * @param requirements - Payment requirements
     * @param resourceInfo - Resource information
     * @param error - Error message
     * @param extensions - Optional declared extensions (for per-key enrichment)
     * @returns Payment required response object
     */
    createPaymentRequiredResponse(requirements: PaymentRequirements[], resourceInfo: ResourceInfo$1, error?: string, extensions?: Record<string, unknown>): Promise<PaymentRequired>;
    /**
     * Verify a payment against requirements
     *
     * @param paymentPayload - The payment payload to verify
     * @param requirements - The payment requirements
     * @returns Verification response
     */
    verifyPayment(paymentPayload: PaymentPayload, requirements: PaymentRequirements): Promise<VerifyResponse>;
    /**
     * Settle a verified payment
     *
     * @param paymentPayload - The payment payload to settle
     * @param requirements - The payment requirements
     * @param declaredExtensions - Optional declared extensions (for per-key enrichment)
     * @returns Settlement response
     */
    settlePayment(paymentPayload: PaymentPayload, requirements: PaymentRequirements, declaredExtensions?: Record<string, unknown>): Promise<SettleResponse>;
    /**
     * Find matching payment requirements for a payment
     *
     * @param availableRequirements - Array of available payment requirements
     * @param paymentPayload - The payment payload
     * @returns Matching payment requirements or undefined
     */
    findMatchingRequirements(availableRequirements: PaymentRequirements[], paymentPayload: PaymentPayload): PaymentRequirements | undefined;
    /**
     * Process a payment request
     *
     * @param paymentPayload - Optional payment payload if provided
     * @param resourceConfig - Configuration for the protected resource
     * @param resourceInfo - Information about the resource being accessed
     * @param extensions - Optional extensions to include in the response
     * @returns Processing result
     */
    processPaymentRequest(paymentPayload: PaymentPayload | null, resourceConfig: ResourceConfig, resourceInfo: ResourceInfo$1, extensions?: Record<string, unknown>): Promise<{
        success: boolean;
        requiresPayment?: PaymentRequired;
        verificationResult?: VerifyResponse;
        settlementResult?: SettleResponse;
        error?: string;
    }>;
    /**
     * Get facilitator client for a specific version, network, and scheme
     *
     * @param x402Version - The x402 version
     * @param network - The network identifier
     * @param scheme - The payment scheme
     * @returns The facilitator client or undefined if not found
     */
    private getFacilitatorClient;
}

interface ResourceServerExtension {
    key: string;
    /**
     * Enrich extension declaration with extension-specific data.
     *
     * @param declaration - Extension declaration from route config
     * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)
     * @returns Enriched extension declaration
     */
    enrichDeclaration?: (declaration: unknown, transportContext: unknown) => unknown;
    /**
     * Called when generating a 402 PaymentRequired response.
     * Return extension data to add to extensions[key], or undefined to skip.
     *
     * @param declaration - Extension declaration from route config
     * @param context - PaymentRequired context containing response and requirements
     * @returns Extension data to add to response.extensions[key]
     */
    enrichPaymentRequiredResponse?: (declaration: unknown, context: PaymentRequiredContext) => Promise<unknown>;
    /**
     * Called after successful payment settlement.
     * Return extension data to add to response.extensions[key], or undefined to skip.
     *
     * @param declaration - Extension declaration from route config
     * @param context - Settlement result context containing payment payload, requirements, and result
     * @returns Extension data to add to response.extensions[key]
     */
    enrichSettlementResponse?: (declaration: unknown, context: SettleResultContext) => Promise<unknown>;
}

type Network = `${string}:${string}`;
type Money = string | number;
type AssetAmount = {
    asset: string;
    amount: string;
    extra?: Record<string, unknown>;
};
type Price = Money | AssetAmount;

interface ResourceInfo {
    url: string;
    description: string;
    mimeType: string;
}
type PaymentRequirements = {
    scheme: string;
    network: Network;
    asset: string;
    amount: string;
    payTo: string;
    maxTimeoutSeconds: number;
    extra: Record<string, unknown>;
};
type PaymentRequired = {
    x402Version: number;
    error?: string;
    resource: ResourceInfo;
    accepts: PaymentRequirements[];
    extensions?: Record<string, unknown>;
};
type PaymentPayload = {
    x402Version: number;
    resource: ResourceInfo;
    accepted: PaymentRequirements;
    payload: Record<string, unknown>;
    extensions?: Record<string, unknown>;
};

type VerifyRequest = {
    paymentPayload: PaymentPayload;
    paymentRequirements: PaymentRequirements;
};
type VerifyResponse = {
    isValid: boolean;
    invalidReason?: string;
    invalidMessage?: string;
    payer?: string;
    extensions?: Record<string, unknown>;
};
type SettleRequest = {
    paymentPayload: PaymentPayload;
    paymentRequirements: PaymentRequirements;
};
type SettleResponse = {
    success: boolean;
    errorReason?: string;
    errorMessage?: string;
    payer?: string;
    transaction: string;
    network: Network;
    extensions?: Record<string, unknown>;
};
type SupportedKind = {
    x402Version: number;
    scheme: string;
    network: Network;
    extra?: Record<string, unknown>;
};
type SupportedResponse = {
    kinds: SupportedKind[];
    extensions: string[];
    signers: Record<string, string[]>;
};
/**
 * Error thrown when payment verification fails.
 */
declare class VerifyError extends Error {
    readonly invalidReason?: string;
    readonly invalidMessage?: string;
    readonly payer?: string;
    readonly statusCode: number;
    /**
     * Creates a VerifyError from a failed verification response.
     *
     * @param statusCode - HTTP status code from the facilitator
     * @param response - The verify response containing error details
     */
    constructor(statusCode: number, response: VerifyResponse);
}
/**
 * Error thrown when payment settlement fails.
 */
declare class SettleError extends Error {
    readonly errorReason?: string;
    readonly errorMessage?: string;
    readonly payer?: string;
    readonly transaction: string;
    readonly network: Network;
    readonly statusCode: number;
    /**
     * Creates a SettleError from a failed settlement response.
     *
     * @param statusCode - HTTP status code from the facilitator
     * @param response - The settle response containing error details
     */
    constructor(statusCode: number, response: SettleResponse);
}

/**
 * Money parser function that converts a numeric amount to an AssetAmount
 * Receives the amount as a decimal number (e.g., 1.50 for $1.50)
 * Returns null to indicate "cannot handle this amount", causing fallback to next parser
 * Always returns a Promise for consistency - use async/await
 *
 * @param amount - The decimal amount (e.g., 1.50)
 * @param network - The network identifier for context
 * @returns AssetAmount or null to try next parser
 */
type MoneyParser = (amount: number, network: Network) => Promise<AssetAmount | null>;
/**
 * Result of createPaymentPayload - the core payload fields.
 * Contains the x402 version and the scheme-specific payload data.
 */
type PaymentPayloadResult = Pick<PaymentPayload, "x402Version" | "payload">;
interface SchemeNetworkClient {
    readonly scheme: string;
    createPaymentPayload(x402Version: number, paymentRequirements: PaymentRequirements): Promise<PaymentPayloadResult>;
}
interface SchemeNetworkFacilitator {
    readonly scheme: string;
    /**
     * CAIP family pattern that this facilitator supports.
     * Used to group signers by blockchain family in the supported response.
     *
     * @example
     * // EVM facilitators
     * readonly caipFamily = "eip155:*";
     *
     * @example
     * // SVM facilitators
     * readonly caipFamily = "solana:*";
     */
    readonly caipFamily: string;
    /**
     * Get mechanism-specific extra data needed for the supported kinds endpoint.
     * This method is called when building the facilitator's supported response.
     *
     * @param network - The network identifier for context
     * @returns Extra data object or undefined if no extra data is needed
     *
     * @example
     * // EVM schemes return undefined (no extra data needed)
     * getExtra(network: Network): undefined {
     *   return undefined;
     * }
     *
     * @example
     * // SVM schemes return feePayer address
     * getExtra(network: Network): Record<string, unknown> | undefined {
     *   return { feePayer: this.signer.address };
     * }
     */
    getExtra(network: Network): Record<string, unknown> | undefined;
    /**
     * Get signer addresses used by this facilitator for a given network.
     * These are included in the supported response to help clients understand
     * which addresses might sign/pay for transactions.
     *
     * Supports multiple addresses for load balancing, key rotation, and high availability.
     *
     * @param network - The network identifier
     * @returns Array of signer addresses (wallet addresses, fee payer addresses, etc.)
     *
     * @example
     * // EVM facilitator
     * getSigners(network: string): string[] {
     *   return [...this.signer.getAddresses()];
     * }
     *
     * @example
     * // SVM facilitator
     * getSigners(network: string): string[] {
     *   return [...this.signer.getAddresses()];
     * }
     */
    getSigners(network: string): string[];
    verify(payload: PaymentPayload, requirements: PaymentRequirements): Promise<VerifyResponse>;
    settle(payload: PaymentPayload, requirements: PaymentRequirements): Promise<SettleResponse>;
}
interface SchemeNetworkServer {
    readonly scheme: string;
    /**
     * Convert a user-friendly price to the scheme's specific amount and asset format
     * Always returns a Promise for consistency
     *
     * @param price - User-friendly price (e.g., "$0.10", "0.10", { amount: "100000", asset: "USDC" })
     * @param network - The network identifier for context
     * @returns Promise that resolves to the converted amount, asset identifier, and any extra metadata
     *
     * @example
     * // For EVM networks with USDC:
     * await parsePrice("$0.10", "eip155:8453") => { amount: "100000", asset: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913" }
     *
     * // For custom schemes:
     * await parsePrice("10 points", "custom:network") => { amount: "10", asset: "points" }
     */
    parsePrice(price: Price, network: Network): Promise<AssetAmount>;
    /**
     * Build payment requirements for this scheme/network combination
     *
     * @param paymentRequirements - Base payment requirements with amount/asset already set
     * @param supportedKind - The supported kind from facilitator's /supported endpoint
     * @param supportedKind.x402Version - The x402 version
     * @param supportedKind.scheme - The payment scheme
     * @param supportedKind.network - The network identifier
     * @param supportedKind.extra - Optional extra metadata
     * @param facilitatorExtensions - Extensions supported by the facilitator
     * @returns Enhanced payment requirements ready to be sent to clients
     */
    enhancePaymentRequirements(paymentRequirements: PaymentRequirements, supportedKind: {
        x402Version: number;
        scheme: string;
        network: Network;
        extra?: Record<string, unknown>;
    }, facilitatorExtensions: string[]): Promise<PaymentRequirements>;
}

export { type AssetAmount as A, type VerifyRequest as B, type FacilitatorClient as F, HTTPFacilitatorClient as H, type Money as M, type Network as N, type PaymentPayload as P, type ResourceConfig as R, type SettleResponse as S, type VerifyResponse as V, type PaymentRequirements as a, type SchemeNetworkFacilitator as b, type PaymentRequired as c, type FacilitatorConfig as d, type SchemeNetworkClient as e, type ResourceInfo$1 as f, type SettleResultContext as g, type Price as h, type PaymentPayloadV1 as i, type PaymentRequiredV1 as j, type PaymentRequirementsV1 as k, type SettleRequestV1 as l, type SettleResponseV1 as m, type SupportedResponseV1 as n, type VerifyRequestV1 as o, type MoneyParser as p, type PaymentPayloadResult as q, type PaymentRequiredContext as r, type ResourceInfo as s, type ResourceServerExtension as t, type SchemeNetworkServer as u, SettleError as v, type SettleRequest as w, x402ResourceServer as x, type SupportedResponse as y, VerifyError as z };
