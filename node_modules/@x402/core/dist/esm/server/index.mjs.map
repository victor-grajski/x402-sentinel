{"version":3,"sources":["../../../src/server/x402ResourceServer.ts"],"sourcesContent":["import {\n  SettleError,\n  SettleResponse,\n  VerifyResponse,\n  SupportedResponse,\n  SupportedKind,\n} from \"../types/facilitator\";\nimport { PaymentPayload, PaymentRequirements, PaymentRequired } from \"../types/payments\";\nimport { SchemeNetworkServer } from \"../types/mechanisms\";\nimport { Price, Network, ResourceServerExtension, VerifyError } from \"../types\";\nimport { deepEqual, findByNetworkAndScheme } from \"../utils\";\nimport { FacilitatorClient, HTTPFacilitatorClient } from \"../http/httpFacilitatorClient\";\nimport { x402Version } from \"..\";\n\n/**\n * Configuration for a protected resource\n * Only contains payment-specific configuration, not resource metadata\n */\nexport interface ResourceConfig {\n  scheme: string;\n  payTo: string; // Payment recipient address\n  price: Price;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>; // Scheme-specific additional data\n}\n\n/**\n * Resource information for PaymentRequired response\n */\nexport interface ResourceInfo {\n  url: string;\n  description: string;\n  mimeType: string;\n}\n\n/**\n * Lifecycle Hook Context Interfaces\n */\n\nexport interface PaymentRequiredContext {\n  requirements: PaymentRequirements[];\n  resourceInfo: ResourceInfo;\n  error?: string;\n  paymentRequiredResponse: PaymentRequired;\n}\n\nexport interface VerifyContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface VerifyResultContext extends VerifyContext {\n  result: VerifyResponse;\n}\n\nexport interface VerifyFailureContext extends VerifyContext {\n  error: Error;\n}\n\nexport interface SettleContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface SettleResultContext extends SettleContext {\n  result: SettleResponse;\n}\n\nexport interface SettleFailureContext extends SettleContext {\n  error: Error;\n}\n\n/**\n * Lifecycle Hook Type Definitions\n */\n\nexport type BeforeVerifyHook = (\n  context: VerifyContext,\n) => Promise<void | { abort: true; reason: string; message?: string }>;\n\nexport type AfterVerifyHook = (context: VerifyResultContext) => Promise<void>;\n\nexport type OnVerifyFailureHook = (\n  context: VerifyFailureContext,\n) => Promise<void | { recovered: true; result: VerifyResponse }>;\n\nexport type BeforeSettleHook = (\n  context: SettleContext,\n) => Promise<void | { abort: true; reason: string; message?: string }>;\n\nexport type AfterSettleHook = (context: SettleResultContext) => Promise<void>;\n\nexport type OnSettleFailureHook = (\n  context: SettleFailureContext,\n) => Promise<void | { recovered: true; result: SettleResponse }>;\n\n/**\n * Core x402 protocol server for resource protection\n * Transport-agnostic implementation of the x402 payment protocol\n */\nexport class x402ResourceServer {\n  private facilitatorClients: FacilitatorClient[];\n  private registeredServerSchemes: Map<string, Map<string, SchemeNetworkServer>> = new Map();\n  private supportedResponsesMap: Map<number, Map<string, Map<string, SupportedResponse>>> =\n    new Map();\n  private facilitatorClientsMap: Map<number, Map<string, Map<string, FacilitatorClient>>> =\n    new Map();\n  private registeredExtensions: Map<string, ResourceServerExtension> = new Map();\n\n  private beforeVerifyHooks: BeforeVerifyHook[] = [];\n  private afterVerifyHooks: AfterVerifyHook[] = [];\n  private onVerifyFailureHooks: OnVerifyFailureHook[] = [];\n  private beforeSettleHooks: BeforeSettleHook[] = [];\n  private afterSettleHooks: AfterSettleHook[] = [];\n  private onSettleFailureHooks: OnSettleFailureHook[] = [];\n\n  /**\n   * Creates a new x402ResourceServer instance.\n   *\n   * @param facilitatorClients - Optional facilitator client(s) for payment processing\n   */\n  constructor(facilitatorClients?: FacilitatorClient | FacilitatorClient[]) {\n    // Normalize facilitator clients to array\n    if (!facilitatorClients) {\n      // No clients provided, create a default HTTP client\n      this.facilitatorClients = [new HTTPFacilitatorClient()];\n    } else if (Array.isArray(facilitatorClients)) {\n      // Array of clients provided\n      this.facilitatorClients =\n        facilitatorClients.length > 0 ? facilitatorClients : [new HTTPFacilitatorClient()];\n    } else {\n      // Single client provided\n      this.facilitatorClients = [facilitatorClients];\n    }\n  }\n\n  /**\n   * Register a scheme/network server implementation.\n   *\n   * @param network - The network identifier\n   * @param server - The scheme/network server implementation\n   * @returns The x402ResourceServer instance for chaining\n   */\n  register(network: Network, server: SchemeNetworkServer): x402ResourceServer {\n    if (!this.registeredServerSchemes.has(network)) {\n      this.registeredServerSchemes.set(network, new Map());\n    }\n\n    const serverByScheme = this.registeredServerSchemes.get(network)!;\n    if (!serverByScheme.has(server.scheme)) {\n      serverByScheme.set(server.scheme, server);\n    }\n\n    return this;\n  }\n\n  /**\n   * Check if a scheme is registered for a given network.\n   *\n   * @param network - The network identifier\n   * @param scheme - The payment scheme name\n   * @returns True if the scheme is registered for the network, false otherwise\n   */\n  hasRegisteredScheme(network: Network, scheme: string): boolean {\n    return !!findByNetworkAndScheme(this.registeredServerSchemes, scheme, network);\n  }\n\n  /**\n   * Registers a resource service extension that can enrich extension declarations.\n   *\n   * @param extension - The extension to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  registerExtension(extension: ResourceServerExtension): this {\n    this.registeredExtensions.set(extension.key, extension);\n    return this;\n  }\n\n  /**\n   * Check if an extension is registered.\n   *\n   * @param key - The extension key\n   * @returns True if the extension is registered\n   */\n  hasExtension(key: string): boolean {\n    return this.registeredExtensions.has(key);\n  }\n\n  /**\n   * Get all registered extensions.\n   *\n   * @returns Array of registered extensions\n   */\n  getExtensions(): ResourceServerExtension[] {\n    return Array.from(this.registeredExtensions.values());\n  }\n\n  /**\n   * Enriches declared extensions using registered extension hooks.\n   *\n   * @param declaredExtensions - Extensions declared on the route\n   * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)\n   * @returns Enriched extensions map\n   */\n  enrichExtensions(\n    declaredExtensions: Record<string, unknown>,\n    transportContext: unknown,\n  ): Record<string, unknown> {\n    const enriched: Record<string, unknown> = {};\n\n    for (const [key, declaration] of Object.entries(declaredExtensions)) {\n      const extension = this.registeredExtensions.get(key);\n\n      if (extension?.enrichDeclaration) {\n        enriched[key] = extension.enrichDeclaration(declaration, transportContext);\n      } else {\n        enriched[key] = declaration;\n      }\n    }\n\n    return enriched;\n  }\n\n  /**\n   * Register a hook to execute before payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeVerify(hook: BeforeVerifyHook): x402ResourceServer {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment verification.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterVerify(hook: AfterVerifyHook): x402ResourceServer {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment verification fails.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onVerifyFailure(hook: OnVerifyFailureHook): x402ResourceServer {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeSettle(hook: BeforeSettleHook): x402ResourceServer {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterSettle(hook: AfterSettleHook): x402ResourceServer {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onSettleFailure(hook: OnSettleFailureHook): x402ResourceServer {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Initialize by fetching supported kinds from all facilitators\n   * Creates mappings for supported responses and facilitator clients\n   * Earlier facilitators in the array get precedence\n   */\n  async initialize(): Promise<void> {\n    // Clear existing mappings\n    this.supportedResponsesMap.clear();\n    this.facilitatorClientsMap.clear();\n\n    // Fetch supported kinds from all facilitator clients\n    // Process in order to give precedence to earlier facilitators\n    for (const facilitatorClient of this.facilitatorClients) {\n      try {\n        const supported = await facilitatorClient.getSupported();\n\n        // Process each supported kind (now flat array with version in each element)\n        for (const kind of supported.kinds) {\n          const x402Version = kind.x402Version;\n\n          // Get or create version map for supported responses\n          if (!this.supportedResponsesMap.has(x402Version)) {\n            this.supportedResponsesMap.set(x402Version, new Map());\n          }\n          const responseVersionMap = this.supportedResponsesMap.get(x402Version)!;\n\n          // Get or create version map for facilitator clients\n          if (!this.facilitatorClientsMap.has(x402Version)) {\n            this.facilitatorClientsMap.set(x402Version, new Map());\n          }\n          const clientVersionMap = this.facilitatorClientsMap.get(x402Version)!;\n\n          // Get or create network map for responses\n          if (!responseVersionMap.has(kind.network)) {\n            responseVersionMap.set(kind.network, new Map());\n          }\n          const responseNetworkMap = responseVersionMap.get(kind.network)!;\n\n          // Get or create network map for clients\n          if (!clientVersionMap.has(kind.network)) {\n            clientVersionMap.set(kind.network, new Map());\n          }\n          const clientNetworkMap = clientVersionMap.get(kind.network)!;\n\n          // Only store if not already present (gives precedence to earlier facilitators)\n          if (!responseNetworkMap.has(kind.scheme)) {\n            responseNetworkMap.set(kind.scheme, supported);\n            clientNetworkMap.set(kind.scheme, facilitatorClient);\n          }\n        }\n      } catch (error) {\n        // Log error but continue with other facilitators\n        console.warn(`Failed to fetch supported kinds from facilitator: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Get supported kind for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The supported kind or undefined if not found\n   */\n  getSupportedKind(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): SupportedKind | undefined {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    if (!supportedResponse) return undefined;\n\n    // Find the specific kind from the response (kinds are flat array with version in each element)\n    return supportedResponse.kinds.find(\n      kind =>\n        kind.x402Version === x402Version && kind.network === network && kind.scheme === scheme,\n    );\n  }\n\n  /**\n   * Get facilitator extensions for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator extensions or empty array if not found\n   */\n  getFacilitatorExtensions(x402Version: number, network: Network, scheme: string): string[] {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return [];\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    return supportedResponse?.extensions || [];\n  }\n\n  /**\n   * Build payment requirements for a protected resource\n   *\n   * @param resourceConfig - Configuration for the protected resource\n   * @returns Array of payment requirements\n   */\n  async buildPaymentRequirements(resourceConfig: ResourceConfig): Promise<PaymentRequirements[]> {\n    const requirements: PaymentRequirements[] = [];\n\n    // Find the matching server implementation\n    const scheme = resourceConfig.scheme;\n    const SchemeNetworkServer = findByNetworkAndScheme(\n      this.registeredServerSchemes,\n      scheme,\n      resourceConfig.network,\n    );\n\n    if (!SchemeNetworkServer) {\n      // Fallback to placeholder implementation if no server registered\n      // TODO: Remove this fallback once implementations are registered\n      console.warn(\n        `No server implementation registered for scheme: ${scheme}, network: ${resourceConfig.network}`,\n      );\n      return requirements;\n    }\n\n    // Find the matching supported kind from facilitator\n    const supportedKind = this.getSupportedKind(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    if (!supportedKind) {\n      throw new Error(\n        `Facilitator does not support ${SchemeNetworkServer.scheme} on ${resourceConfig.network}. ` +\n          `Make sure to call initialize() to fetch supported kinds from facilitators.`,\n      );\n    }\n\n    // Get facilitator extensions for this combination\n    const facilitatorExtensions = this.getFacilitatorExtensions(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    // Parse the price using the scheme's price parser\n    const parsedPrice = await SchemeNetworkServer.parsePrice(\n      resourceConfig.price,\n      resourceConfig.network,\n    );\n\n    // Build base payment requirements from resource config\n    const baseRequirements: PaymentRequirements = {\n      scheme: SchemeNetworkServer.scheme,\n      network: resourceConfig.network,\n      amount: parsedPrice.amount,\n      asset: parsedPrice.asset,\n      payTo: resourceConfig.payTo,\n      maxTimeoutSeconds: resourceConfig.maxTimeoutSeconds || 300, // Default 5 minutes\n      extra: {\n        ...parsedPrice.extra,\n        ...resourceConfig.extra, // Merge user-provided extra\n      },\n    };\n\n    // Delegate to the implementation for scheme-specific enhancements\n    // Note: enhancePaymentRequirements expects x402Version in the kind, so we add it back\n    const requirement = await SchemeNetworkServer.enhancePaymentRequirements(\n      baseRequirements,\n      {\n        ...supportedKind,\n        x402Version,\n      },\n      facilitatorExtensions,\n    );\n\n    requirements.push(requirement);\n    return requirements;\n  }\n\n  /**\n   * Build payment requirements from multiple payment options\n   * This method handles resolving dynamic payTo/price functions and builds requirements for each option\n   *\n   * @param paymentOptions - Array of payment options to convert\n   * @param context - HTTP request context for resolving dynamic functions\n   * @returns Array of payment requirements (one per option)\n   */\n  async buildPaymentRequirementsFromOptions<TContext = unknown>(\n    paymentOptions: Array<{\n      scheme: string;\n      payTo: string | ((context: TContext) => string | Promise<string>);\n      price: Price | ((context: TContext) => Price | Promise<Price>);\n      network: Network;\n      maxTimeoutSeconds?: number;\n    }>,\n    context: TContext,\n  ): Promise<PaymentRequirements[]> {\n    const allRequirements: PaymentRequirements[] = [];\n\n    for (const option of paymentOptions) {\n      // Resolve dynamic payTo and price if they are functions\n      const resolvedPayTo =\n        typeof option.payTo === \"function\" ? await option.payTo(context) : option.payTo;\n      const resolvedPrice =\n        typeof option.price === \"function\" ? await option.price(context) : option.price;\n\n      const resourceConfig: ResourceConfig = {\n        scheme: option.scheme,\n        payTo: resolvedPayTo,\n        price: resolvedPrice,\n        network: option.network,\n        maxTimeoutSeconds: option.maxTimeoutSeconds,\n      };\n\n      // Use existing buildPaymentRequirements for each option\n      const requirements = await this.buildPaymentRequirements(resourceConfig);\n      allRequirements.push(...requirements);\n    }\n\n    return allRequirements;\n  }\n\n  /**\n   * Create a payment required response\n   *\n   * @param requirements - Payment requirements\n   * @param resourceInfo - Resource information\n   * @param error - Error message\n   * @param extensions - Optional declared extensions (for per-key enrichment)\n   * @returns Payment required response object\n   */\n  async createPaymentRequiredResponse(\n    requirements: PaymentRequirements[],\n    resourceInfo: ResourceInfo,\n    error?: string,\n    extensions?: Record<string, unknown>,\n  ): Promise<PaymentRequired> {\n    // V2 response with resource at top level\n    let response: PaymentRequired = {\n      x402Version: 2,\n      error,\n      resource: resourceInfo,\n      accepts: requirements as PaymentRequirements[],\n    };\n\n    // Add extensions if provided\n    if (extensions && Object.keys(extensions).length > 0) {\n      response.extensions = extensions;\n    }\n\n    // Let declared extensions add data to PaymentRequired response\n    if (extensions) {\n      for (const [key, declaration] of Object.entries(extensions)) {\n        const extension = this.registeredExtensions.get(key);\n        if (extension?.enrichPaymentRequiredResponse) {\n          try {\n            const context: PaymentRequiredContext = {\n              requirements,\n              resourceInfo,\n              error,\n              paymentRequiredResponse: response,\n            };\n            const extensionData = await extension.enrichPaymentRequiredResponse(\n              declaration,\n              context,\n            );\n            if (extensionData !== undefined) {\n              if (!response.extensions) {\n                response.extensions = {};\n              }\n              response.extensions[key] = extensionData;\n            }\n          } catch (error) {\n            console.error(\n              `Error in enrichPaymentRequiredResponse hook for extension ${key}:`,\n              error,\n            );\n          }\n        }\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Verify a payment against requirements\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Verification response\n   */\n  async verifyPayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const context: VerifyContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeVerify hooks\n    for (const hook of this.beforeVerifyHooks) {\n      try {\n        const result = await hook(context);\n        if (result && \"abort\" in result && result.abort) {\n          return {\n            isValid: false,\n            invalidReason: result.reason,\n            invalidMessage: result.message,\n          };\n        }\n      } catch (error) {\n        throw new VerifyError(400, {\n          isValid: false,\n          invalidReason: \"before_verify_hook_error\",\n          invalidMessage: error instanceof Error ? error.message : \"\",\n        });\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let verifyResult: VerifyResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            verifyResult = await client.verify(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!verifyResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        verifyResult = await facilitatorClient.verify(paymentPayload, requirements);\n      }\n\n      // Execute afterVerify hooks\n      const resultContext: VerifyResultContext = {\n        ...context,\n        result: verifyResult,\n      };\n\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n\n      return verifyResult;\n    } catch (error) {\n      const failureContext: VerifyFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onVerifyFailure hooks\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Settle a verified payment\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @param declaredExtensions - Optional declared extensions (for per-key enrichment)\n   * @returns Settlement response\n   */\n  async settlePayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n    declaredExtensions?: Record<string, unknown>,\n  ): Promise<SettleResponse> {\n    const context: SettleContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeSettle hooks\n    for (const hook of this.beforeSettleHooks) {\n      try {\n        const result = await hook(context);\n        if (result && \"abort\" in result && result.abort) {\n          throw new SettleError(400, {\n            success: false,\n            errorReason: result.reason,\n            errorMessage: result.message,\n            transaction: \"\",\n            network: requirements.network,\n          });\n        }\n      } catch (error) {\n        throw new SettleError(400, {\n          success: false,\n          errorReason: \"before_settle_hook_error\",\n          errorMessage: error instanceof Error ? error.message : \"\",\n          transaction: \"\",\n          network: requirements.network,\n        });\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let settleResult: SettleResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            settleResult = await client.settle(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!settleResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        settleResult = await facilitatorClient.settle(paymentPayload, requirements);\n      }\n\n      // Execute afterSettle hooks\n      const resultContext: SettleResultContext = {\n        ...context,\n        result: settleResult,\n      };\n\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n\n      // Let declared extensions add data to settlement response\n      if (declaredExtensions) {\n        for (const [key, declaration] of Object.entries(declaredExtensions)) {\n          const extension = this.registeredExtensions.get(key);\n          if (extension?.enrichSettlementResponse) {\n            try {\n              const extensionData = await extension.enrichSettlementResponse(\n                declaration,\n                resultContext,\n              );\n              if (extensionData !== undefined) {\n                if (!settleResult.extensions) {\n                  settleResult.extensions = {};\n                }\n                settleResult.extensions[key] = extensionData;\n              }\n            } catch (error) {\n              console.error(`Error in enrichSettlementResponse hook for extension ${key}:`, error);\n            }\n          }\n        }\n      }\n\n      return settleResult;\n    } catch (error) {\n      const failureContext: SettleFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onSettleFailure hooks\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Find matching payment requirements for a payment\n   *\n   * @param availableRequirements - Array of available payment requirements\n   * @param paymentPayload - The payment payload\n   * @returns Matching payment requirements or undefined\n   */\n  findMatchingRequirements(\n    availableRequirements: PaymentRequirements[],\n    paymentPayload: PaymentPayload,\n  ): PaymentRequirements | undefined {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        // For v2, match by accepted requirements\n        return availableRequirements.find(paymentRequirements =>\n          deepEqual(paymentRequirements, paymentPayload.accepted),\n        );\n      case 1:\n        // For v1, match by scheme and network\n        return availableRequirements.find(\n          req =>\n            req.scheme === paymentPayload.accepted.scheme &&\n            req.network === paymentPayload.accepted.network,\n        );\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Process a payment request\n   *\n   * @param paymentPayload - Optional payment payload if provided\n   * @param resourceConfig - Configuration for the protected resource\n   * @param resourceInfo - Information about the resource being accessed\n   * @param extensions - Optional extensions to include in the response\n   * @returns Processing result\n   */\n  async processPaymentRequest(\n    paymentPayload: PaymentPayload | null,\n    resourceConfig: ResourceConfig,\n    resourceInfo: ResourceInfo,\n    extensions?: Record<string, unknown>,\n  ): Promise<{\n    success: boolean;\n    requiresPayment?: PaymentRequired;\n    verificationResult?: VerifyResponse;\n    settlementResult?: SettleResponse;\n    error?: string;\n  }> {\n    const requirements = await this.buildPaymentRequirements(resourceConfig);\n\n    if (!paymentPayload) {\n      return {\n        success: false,\n        requiresPayment: await this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"Payment required\",\n          extensions,\n        ),\n      };\n    }\n\n    // Find matching requirements\n    const matchingRequirements = this.findMatchingRequirements(requirements, paymentPayload);\n    if (!matchingRequirements) {\n      return {\n        success: false,\n        requiresPayment: await this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements found\",\n          extensions,\n        ),\n      };\n    }\n\n    // Verify payment\n    const verificationResult = await this.verifyPayment(paymentPayload, matchingRequirements);\n    if (!verificationResult.isValid) {\n      return {\n        success: false,\n        error: verificationResult.invalidReason,\n        verificationResult,\n      };\n    }\n\n    // Payment verified, ready for settlement\n    return {\n      success: true,\n      verificationResult,\n    };\n  }\n\n  /**\n   * Get facilitator client for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator client or undefined if not found\n   */\n  private getFacilitatorClient(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): FacilitatorClient | undefined {\n    const versionMap = this.facilitatorClientsMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    // Use findByNetworkAndScheme for pattern matching\n    return findByNetworkAndScheme(versionMap, scheme, network);\n  }\n}\n\nexport default x402ResourceServer;\n"],"mappings":"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","names":["x402Version","error"]}