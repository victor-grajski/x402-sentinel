{"version":3,"sources":["../../../../src/exact/facilitator/eip3009.ts","../../../../src/exact/facilitator/permit2.ts","../../../../src/exact/facilitator/scheme.ts","../../../../src/exact/facilitator/register.ts"],"sourcesContent":["import {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../constants\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEIP3009Payload } from \"../../types\";\n\nexport interface EIP3009FacilitatorConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492: boolean;\n}\n\n/**\n * Verifies an EIP-3009 payment payload.\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @returns Promise resolving to verification response\n */\nexport async function verifyEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n): Promise<VerifyResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Verify scheme matches\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  // Get chain configuration\n  if (!requirements.extra?.name || !requirements.extra?.version) {\n    return {\n      isValid: false,\n      invalidReason: \"missing_eip712_domain\",\n      payer,\n    };\n  }\n\n  const { name, version } = requirements.extra;\n  const erc20Address = getAddress(requirements.asset);\n\n  // Verify network matches\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  // Build typed data for signature verification\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId: parseInt(requirements.network.split(\":\")[1]),\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: eip3009Payload.authorization.from,\n      to: eip3009Payload.authorization.to,\n      value: BigInt(eip3009Payload.authorization.value),\n      validAfter: BigInt(eip3009Payload.authorization.validAfter),\n      validBefore: BigInt(eip3009Payload.authorization.validBefore),\n      nonce: eip3009Payload.authorization.nonce,\n    },\n  };\n\n  // Verify signature\n  try {\n    const recoveredAddress = await signer.verifyTypedData({\n      address: eip3009Payload.authorization.from,\n      ...permitTypedData,\n      signature: eip3009Payload.signature!,\n    });\n\n    if (!recoveredAddress) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  } catch {\n    // Signature verification failed - could be an undeployed smart wallet\n    // Check if smart wallet is deployed\n    const signature = eip3009Payload.signature!;\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n    if (isSmartWallet) {\n      const payerAddress = eip3009Payload.authorization.from;\n      const bytecode = await signer.getCode({ address: payerAddress });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n        const erc6492Data = parseErc6492Signature(signature);\n        const hasDeploymentInfo =\n          erc6492Data.address &&\n          erc6492Data.data &&\n          !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n        if (!hasDeploymentInfo) {\n          // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n            payer: payerAddress,\n          };\n        }\n        // EIP-6492 signature with deployment info - allow through\n      } else {\n        // Wallet is deployed but signature still failed - invalid signature\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer,\n        };\n      }\n    } else {\n      // EOA signature failed\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  }\n\n  // Verify payment recipient matches\n  if (getAddress(eip3009Payload.authorization.to) !== getAddress(requirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  // Verify validBefore is in the future (with 6 second buffer for block time)\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n      payer,\n    };\n  }\n\n  // Verify validAfter is not in the future\n  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n      payer,\n    };\n  }\n\n  // Check balance\n  try {\n    const balance = (await signer.readContract({\n      address: erc20Address,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [eip3009Payload.authorization.from],\n    })) as bigint;\n\n    if (BigInt(balance) < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue with other validations\n  }\n\n  // Verify amount is sufficient\n  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n      payer,\n    };\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Settles an EIP-3009 payment by executing transferWithAuthorization.\n *\n * @param signer - The facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @param config - Facilitator configuration\n * @returns Promise resolving to settlement response\n */\nexport async function settleEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n  config: EIP3009FacilitatorConfig,\n): Promise<SettleResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Re-verify before settling\n  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  try {\n    // Parse ERC-6492 signature if applicable\n    const parseResult = parseErc6492Signature(eip3009Payload.signature!);\n    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n    // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n    if (\n      config.deployERC4337WithEIP6492 &&\n      factoryAddress &&\n      factoryCalldata &&\n      !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n    ) {\n      // Check if smart wallet is already deployed\n      const bytecode = await signer.getCode({ address: payer });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet not deployed - attempt deployment\n        const deployTx = await signer.sendTransaction({\n          to: factoryAddress as Hex,\n          data: factoryCalldata as Hex,\n        });\n\n        // Wait for deployment transaction\n        await signer.waitForTransactionReceipt({ hash: deployTx });\n      }\n    }\n\n    // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isECDSA = signatureLength === 130;\n\n    let tx: Hex;\n    if (isECDSA) {\n      // For EOA wallets, parse signature into v, r, s and use that overload\n      const parsedSig = parseSignature(signature);\n\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          (parsedSig.v as number | undefined) || parsedSig.yParity,\n          parsedSig.r,\n          parsedSig.s,\n        ],\n      });\n    } else {\n      // For smart wallets, use the bytes signature overload\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          signature,\n        ],\n      });\n    }\n\n    // Wait for transaction confirmation\n    const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n    if (receipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"invalid_transaction_state\",\n        transaction: tx,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    return {\n      success: true,\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  } catch {\n    return {\n      success: false,\n      errorReason: \"transaction_failed\",\n      transaction: \"\",\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { getAddress } from \"viem\";\nimport {\n  eip3009ABI,\n  PERMIT2_ADDRESS,\n  permit2WitnessTypes,\n  x402ExactPermit2ProxyABI,\n  x402ExactPermit2ProxyAddress,\n} from \"../../constants\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactPermit2Payload } from \"../../types\";\n\n// ERC20 allowance ABI for checking Permit2 approval\nconst erc20AllowanceABI = [\n  {\n    type: \"function\",\n    name: \"allowance\",\n    inputs: [\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n    ],\n    outputs: [{ type: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\n/**\n * Verifies a Permit2 payment payload.\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @returns Promise resolving to verification response\n */\nexport async function verifyPermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n): Promise<VerifyResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  // Verify scheme matches\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  // Verify network matches\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  const chainId = parseInt(requirements.network.split(\":\")[1]);\n  const tokenAddress = getAddress(requirements.asset);\n\n  // Verify spender is the x402ExactPermit2Proxy\n  if (\n    getAddress(permit2Payload.permit2Authorization.spender) !==\n    getAddress(x402ExactPermit2ProxyAddress)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_spender\",\n      payer,\n    };\n  }\n\n  // Verify witness.to matches payTo\n  if (\n    getAddress(permit2Payload.permit2Authorization.witness.to) !== getAddress(requirements.payTo)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  // Verify deadline not expired (with 6 second buffer for block time)\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_deadline_expired\",\n      payer,\n    };\n  }\n\n  // Verify validAfter is not in the future\n  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_not_yet_valid\",\n      payer,\n    };\n  }\n\n  // Verify amount is sufficient\n  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_insufficient_amount\",\n      payer,\n    };\n  }\n\n  // Verify token matches\n  if (getAddress(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_token_mismatch\",\n      payer,\n    };\n  }\n\n  // Build typed data for Permit2 signature verification\n  const permit2TypedData = {\n    types: permit2WitnessTypes,\n    primaryType: \"PermitWitnessTransferFrom\" as const,\n    domain: {\n      name: \"Permit2\",\n      chainId,\n      verifyingContract: PERMIT2_ADDRESS,\n    },\n    message: {\n      permitted: {\n        token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n      },\n      spender: getAddress(permit2Payload.permit2Authorization.spender),\n      nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n      deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n      witness: {\n        to: getAddress(permit2Payload.permit2Authorization.witness.to),\n        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        extra: permit2Payload.permit2Authorization.witness.extra,\n      },\n    },\n  };\n\n  // Verify signature\n  try {\n    const isValid = await signer.verifyTypedData({\n      address: payer,\n      ...permit2TypedData,\n      signature: permit2Payload.signature,\n    });\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_permit2_signature\",\n        payer,\n      };\n    }\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_signature\",\n      payer,\n    };\n  }\n\n  // Check Permit2 allowance\n  try {\n    const allowance = (await signer.readContract({\n      address: tokenAddress,\n      abi: erc20AllowanceABI,\n      functionName: \"allowance\",\n      args: [payer, PERMIT2_ADDRESS],\n    })) as bigint;\n\n    if (allowance < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"permit2_allowance_required\",\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check allowance, continue - settlement will fail if insufficient\n  }\n\n  // Check balance\n  try {\n    const balance = (await signer.readContract({\n      address: tokenAddress,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [payer],\n    })) as bigint;\n\n    if (balance < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue with other validations\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Settles a Permit2 payment by calling the x402ExactPermit2Proxy.\n *\n * @param signer - The facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @returns Promise resolving to settlement response\n */\nexport async function settlePermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  // Re-verify before settling\n  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  try {\n    // Call x402ExactPermit2Proxy.settle()\n    const tx = await signer.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settle\",\n      args: [\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n          extra: permit2Payload.permit2Authorization.witness.extra as `0x${string}`,\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    // Wait for transaction confirmation\n    const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n    if (receipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"invalid_transaction_state\",\n        transaction: tx,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    return {\n      success: true,\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  } catch (error) {\n    // Extract meaningful error message from the contract revert\n    let errorReason = \"transaction_failed\";\n    if (error instanceof Error) {\n      // Check for common contract revert patterns\n      const message = error.message;\n      if (message.includes(\"AmountExceedsPermitted\")) {\n        errorReason = \"permit2_amount_exceeds_permitted\";\n      } else if (message.includes(\"InvalidDestination\")) {\n        errorReason = \"permit2_invalid_destination\";\n      } else if (message.includes(\"InvalidOwner\")) {\n        errorReason = \"permit2_invalid_owner\";\n      } else if (message.includes(\"PaymentTooEarly\")) {\n        errorReason = \"permit2_payment_too_early\";\n      } else if (message.includes(\"InvalidSignature\") || message.includes(\"SignatureExpired\")) {\n        errorReason = \"permit2_invalid_signature\";\n      } else if (message.includes(\"InvalidNonce\")) {\n        errorReason = \"permit2_invalid_nonce\";\n      } else {\n        // Include error message for debugging (longer for better visibility)\n        errorReason = `transaction_failed: ${message.slice(0, 500)}`;\n      }\n    }\n    return {\n      success: false,\n      errorReason,\n      transaction: \"\",\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2, ExactEIP3009Payload, isPermit2Payload } from \"../../types\";\nimport { verifyEIP3009, settleEIP3009 } from \"./eip3009\";\nimport { verifyPermit2, settlePermit2 } from \"./permit2\";\n\nexport interface ExactEvmSchemeConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme.\n * Routes between EIP-3009 and Permit2 based on payload type.\n */\nexport class ExactEvmScheme implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeConfig>;\n\n  /**\n   * Creates a new ExactEvmFacilitator instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeConfig,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For EVM, no extra data is needed.\n   *\n   * @param _ - The network identifier (unused for EVM)\n   * @returns undefined (EVM has no extra data)\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * Returns all addresses this facilitator can use for signing/settling transactions.\n   *\n   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload.\n   * Routes to the appropriate verification logic based on payload type.\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    // Route based on payload type\n    if (isPermit2Payload(rawPayload)) {\n      return verifyPermit2(this.signer, payload, requirements, rawPayload);\n    }\n\n    // Type-narrowed to EIP-3009 payload\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);\n  }\n\n  /**\n   * Settles a payment by executing the transfer.\n   * Routes to the appropriate settlement logic based on payload type.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    // Route based on payload type\n    if (isPermit2Payload(rawPayload)) {\n      return settlePermit2(this.signer, payload, requirements, rawPayload);\n    }\n\n    // Type-narrowed to EIP-3009 payload\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);\n  }\n}\n","import { x402Facilitator } from \"@x402/core/facilitator\";\nimport { Network } from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/facilitator/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Facilitator\n */\nexport interface EvmFacilitatorConfig {\n  /**\n   * The EVM signer for facilitator operations (verify and settle)\n   */\n  signer: FacilitatorEvmSigner;\n\n  /**\n   * Networks to register (single network or array of networks)\n   * Examples: \"eip155:84532\", [\"eip155:84532\", \"eip155:1\"]\n   */\n  networks: Network | Network[];\n\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Facilitator instance.\n *\n * This function registers:\n * - V2: Specified networks with ExactEvmScheme\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param facilitator - The x402Facilitator instance to register schemes to\n * @param config - Configuration for EVM facilitator registration\n * @returns The facilitator instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/facilitator/register\";\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { createPublicClient, createWalletClient } from \"viem\";\n *\n * const facilitator = new x402Facilitator();\n *\n * // Single network\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: \"eip155:84532\"  // Base Sepolia\n * });\n *\n * // Multiple networks (will auto-derive eip155:* pattern)\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: [\"eip155:84532\", \"eip155:1\"]  // Base Sepolia and Mainnet\n * });\n * ```\n */\nexport function registerExactEvmScheme(\n  facilitator: x402Facilitator,\n  config: EvmFacilitatorConfig,\n): x402Facilitator {\n  // Register V2 scheme with specified networks\n  facilitator.register(\n    config.networks,\n    new ExactEvmScheme(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  // Register all V1 networks\n  facilitator.registerV1(\n    NETWORKS as Network[],\n    new ExactEvmSchemeV1(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  return facilitator;\n}\n"],"mappings":"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","names":["getAddress","getAddress"]}