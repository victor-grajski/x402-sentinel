import {
  isPermit2Payload
} from "../../chunk-PFULIQAE.mjs";
import {
  ExactEvmSchemeV12 as ExactEvmSchemeV1,
  NETWORKS,
  PERMIT2_ADDRESS,
  authorizationTypes,
  eip3009ABI,
  permit2WitnessTypes,
  x402ExactPermit2ProxyABI,
  x402ExactPermit2ProxyAddress
} from "../../chunk-DSSJHWGT.mjs";

// src/exact/facilitator/eip3009.ts
import { getAddress, isAddressEqual, parseErc6492Signature, parseSignature } from "viem";
async function verifyEIP3009(signer, payload, requirements, eip3009Payload) {
  const payer = eip3009Payload.authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (!requirements.extra?.name || !requirements.extra?.version) {
    return {
      isValid: false,
      invalidReason: "missing_eip712_domain",
      payer
    };
  }
  const { name, version } = requirements.extra;
  const erc20Address = getAddress(requirements.asset);
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const permitTypedData = {
    types: authorizationTypes,
    primaryType: "TransferWithAuthorization",
    domain: {
      name,
      version,
      chainId: parseInt(requirements.network.split(":")[1]),
      verifyingContract: erc20Address
    },
    message: {
      from: eip3009Payload.authorization.from,
      to: eip3009Payload.authorization.to,
      value: BigInt(eip3009Payload.authorization.value),
      validAfter: BigInt(eip3009Payload.authorization.validAfter),
      validBefore: BigInt(eip3009Payload.authorization.validBefore),
      nonce: eip3009Payload.authorization.nonce
    }
  };
  try {
    const recoveredAddress = await signer.verifyTypedData({
      address: eip3009Payload.authorization.from,
      ...permitTypedData,
      signature: eip3009Payload.signature
    });
    if (!recoveredAddress) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  } catch {
    const signature = eip3009Payload.signature;
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isSmartWallet = signatureLength > 130;
    if (isSmartWallet) {
      const payerAddress = eip3009Payload.authorization.from;
      const bytecode = await signer.getCode({ address: payerAddress });
      if (!bytecode || bytecode === "0x") {
        const erc6492Data = parseErc6492Signature(signature);
        const hasDeploymentInfo = erc6492Data.address && erc6492Data.data && !isAddressEqual(erc6492Data.address, "0x0000000000000000000000000000000000000000");
        if (!hasDeploymentInfo) {
          return {
            isValid: false,
            invalidReason: "invalid_exact_evm_payload_undeployed_smart_wallet",
            payer: payerAddress
          };
        }
      } else {
        return {
          isValid: false,
          invalidReason: "invalid_exact_evm_payload_signature",
          payer
        };
      }
    } else {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  }
  if (getAddress(eip3009Payload.authorization.to) !== getAddress(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_before",
      payer
    };
  }
  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_after",
      payer
    };
  }
  try {
    const balance = await signer.readContract({
      address: erc20Address,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [eip3009Payload.authorization.from]
    });
    if (BigInt(balance) < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_value",
      payer
    };
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function settleEIP3009(signer, payload, requirements, eip3009Payload, config) {
  const payer = eip3009Payload.authorization.from;
  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  try {
    const parseResult = parseErc6492Signature(eip3009Payload.signature);
    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;
    if (config.deployERC4337WithEIP6492 && factoryAddress && factoryCalldata && !isAddressEqual(factoryAddress, "0x0000000000000000000000000000000000000000")) {
      const bytecode = await signer.getCode({ address: payer });
      if (!bytecode || bytecode === "0x") {
        const deployTx = await signer.sendTransaction({
          to: factoryAddress,
          data: factoryCalldata
        });
        await signer.waitForTransactionReceipt({ hash: deployTx });
      }
    }
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isECDSA = signatureLength === 130;
    let tx;
    if (isECDSA) {
      const parsedSig = parseSignature(signature);
      tx = await signer.writeContract({
        address: getAddress(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          getAddress(eip3009Payload.authorization.from),
          getAddress(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          parsedSig.v || parsedSig.yParity,
          parsedSig.r,
          parsedSig.s
        ]
      });
    } else {
      tx = await signer.writeContract({
        address: getAddress(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          getAddress(eip3009Payload.authorization.from),
          getAddress(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          signature
        ]
      });
    }
    const receipt = await signer.waitForTransactionReceipt({ hash: tx });
    if (receipt.status !== "success") {
      return {
        success: false,
        errorReason: "invalid_transaction_state",
        transaction: tx,
        network: payload.accepted.network,
        payer
      };
    }
    return {
      success: true,
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  } catch {
    return {
      success: false,
      errorReason: "transaction_failed",
      transaction: "",
      network: payload.accepted.network,
      payer
    };
  }
}

// src/exact/facilitator/permit2.ts
import { getAddress as getAddress2 } from "viem";
var erc20AllowanceABI = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" }
    ],
    outputs: [{ type: "uint256" }],
    stateMutability: "view"
  }
];
async function verifyPermit2(signer, payload, requirements, permit2Payload) {
  const payer = permit2Payload.permit2Authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const chainId = parseInt(requirements.network.split(":")[1]);
  const tokenAddress = getAddress2(requirements.asset);
  if (getAddress2(permit2Payload.permit2Authorization.spender) !== getAddress2(x402ExactPermit2ProxyAddress)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_spender",
      payer
    };
  }
  if (getAddress2(permit2Payload.permit2Authorization.witness.to) !== getAddress2(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "permit2_deadline_expired",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "permit2_not_yet_valid",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "permit2_insufficient_amount",
      payer
    };
  }
  if (getAddress2(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {
    return {
      isValid: false,
      invalidReason: "permit2_token_mismatch",
      payer
    };
  }
  const permit2TypedData = {
    types: permit2WitnessTypes,
    primaryType: "PermitWitnessTransferFrom",
    domain: {
      name: "Permit2",
      chainId,
      verifyingContract: PERMIT2_ADDRESS
    },
    message: {
      permitted: {
        token: getAddress2(permit2Payload.permit2Authorization.permitted.token),
        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
      },
      spender: getAddress2(permit2Payload.permit2Authorization.spender),
      nonce: BigInt(permit2Payload.permit2Authorization.nonce),
      deadline: BigInt(permit2Payload.permit2Authorization.deadline),
      witness: {
        to: getAddress2(permit2Payload.permit2Authorization.witness.to),
        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),
        extra: permit2Payload.permit2Authorization.witness.extra
      }
    }
  };
  try {
    const isValid = await signer.verifyTypedData({
      address: payer,
      ...permit2TypedData,
      signature: permit2Payload.signature
    });
    if (!isValid) {
      return {
        isValid: false,
        invalidReason: "invalid_permit2_signature",
        payer
      };
    }
  } catch {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_signature",
      payer
    };
  }
  try {
    const allowance = await signer.readContract({
      address: tokenAddress,
      abi: erc20AllowanceABI,
      functionName: "allowance",
      args: [payer, PERMIT2_ADDRESS]
    });
    if (allowance < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "permit2_allowance_required",
        payer
      };
    }
  } catch {
  }
  try {
    const balance = await signer.readContract({
      address: tokenAddress,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [payer]
    });
    if (balance < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function settlePermit2(signer, payload, requirements, permit2Payload) {
  const payer = permit2Payload.permit2Authorization.from;
  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  try {
    const tx = await signer.writeContract({
      address: x402ExactPermit2ProxyAddress,
      abi: x402ExactPermit2ProxyABI,
      functionName: "settle",
      args: [
        {
          permitted: {
            token: getAddress2(permit2Payload.permit2Authorization.permitted.token),
            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
          },
          nonce: BigInt(permit2Payload.permit2Authorization.nonce),
          deadline: BigInt(permit2Payload.permit2Authorization.deadline)
        },
        getAddress2(payer),
        {
          to: getAddress2(permit2Payload.permit2Authorization.witness.to),
          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),
          extra: permit2Payload.permit2Authorization.witness.extra
        },
        permit2Payload.signature
      ]
    });
    const receipt = await signer.waitForTransactionReceipt({ hash: tx });
    if (receipt.status !== "success") {
      return {
        success: false,
        errorReason: "invalid_transaction_state",
        transaction: tx,
        network: payload.accepted.network,
        payer
      };
    }
    return {
      success: true,
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  } catch (error) {
    let errorReason = "transaction_failed";
    if (error instanceof Error) {
      const message = error.message;
      if (message.includes("AmountExceedsPermitted")) {
        errorReason = "permit2_amount_exceeds_permitted";
      } else if (message.includes("InvalidDestination")) {
        errorReason = "permit2_invalid_destination";
      } else if (message.includes("InvalidOwner")) {
        errorReason = "permit2_invalid_owner";
      } else if (message.includes("PaymentTooEarly")) {
        errorReason = "permit2_payment_too_early";
      } else if (message.includes("InvalidSignature") || message.includes("SignatureExpired")) {
        errorReason = "permit2_invalid_signature";
      } else if (message.includes("InvalidNonce")) {
        errorReason = "permit2_invalid_nonce";
      } else {
        errorReason = `transaction_failed: ${message.slice(0, 500)}`;
      }
    }
    return {
      success: false,
      errorReason,
      transaction: "",
      network: payload.accepted.network,
      payer
    };
  }
}

// src/exact/facilitator/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmFacilitator instance.
   *
   * @param signer - The EVM signer for facilitator operations
   * @param config - Optional configuration for the facilitator
   */
  constructor(signer, config) {
    this.signer = signer;
    this.scheme = "exact";
    this.caipFamily = "eip155:*";
    this.config = {
      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false
    };
  }
  /**
   * Get mechanism-specific extra data for the supported kinds endpoint.
   * For EVM, no extra data is needed.
   *
   * @param _ - The network identifier (unused for EVM)
   * @returns undefined (EVM has no extra data)
   */
  getExtra(_) {
    return void 0;
  }
  /**
   * Get signer addresses used by this facilitator.
   * Returns all addresses this facilitator can use for signing/settling transactions.
   *
   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)
   * @returns Array of facilitator wallet addresses
   */
  getSigners(_) {
    return [...this.signer.getAddresses()];
  }
  /**
   * Verifies a payment payload.
   * Routes to the appropriate verification logic based on payload type.
   *
   * @param payload - The payment payload to verify
   * @param requirements - The payment requirements
   * @returns Promise resolving to verification response
   */
  async verify(payload, requirements) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return verifyPermit2(this.signer, payload, requirements, rawPayload);
    }
    const eip3009Payload = rawPayload;
    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);
  }
  /**
   * Settles a payment by executing the transfer.
   * Routes to the appropriate settlement logic based on payload type.
   *
   * @param payload - The payment payload to settle
   * @param requirements - The payment requirements
   * @returns Promise resolving to settlement response
   */
  async settle(payload, requirements) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return settlePermit2(this.signer, payload, requirements, rawPayload);
    }
    const eip3009Payload = rawPayload;
    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);
  }
};

// src/exact/facilitator/register.ts
function registerExactEvmScheme(facilitator, config) {
  facilitator.register(
    config.networks,
    new ExactEvmScheme(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  facilitator.registerV1(
    NETWORKS,
    new ExactEvmSchemeV1(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  return facilitator;
}
export {
  ExactEvmScheme,
  registerExactEvmScheme
};
//# sourceMappingURL=index.mjs.map