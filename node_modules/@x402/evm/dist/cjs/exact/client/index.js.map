{"version":3,"sources":["../../../../src/exact/client/index.ts","../../../../src/exact/client/eip3009.ts","../../../../src/constants.ts","../../../../src/utils.ts","../../../../src/exact/v1/client/scheme.ts","../../../../src/exact/v1/facilitator/scheme.ts","../../../../src/v1/index.ts","../../../../src/exact/client/permit2.ts","../../../../src/exact/client/scheme.ts","../../../../src/exact/client/register.ts"],"sourcesContent":["export { ExactEvmScheme } from \"./scheme\";\nexport { registerExactEvmScheme } from \"./register\";\nexport type { EvmClientConfig } from \"./register\";\nexport {\n  createPermit2ApprovalTx,\n  getPermit2AllowanceReadParams,\n  erc20AllowanceAbi,\n  type Permit2AllowanceParams,\n} from \"./permit2\";\n","import { PaymentRequirements, PaymentPayloadResult } from \"@x402/core/types\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEIP3009Payload } from \"../../types\";\nimport { createNonce } from \"../../utils\";\n\n/**\n * Creates an EIP-3009 (transferWithAuthorization) payload.\n *\n * @param signer - The EVM signer for client operations\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - The payment requirements\n * @returns Promise resolving to a payment payload result\n */\nexport async function createEIP3009Payload(\n  signer: ClientEvmSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayloadResult> {\n  const nonce = createNonce();\n  const now = Math.floor(Date.now() / 1000);\n\n  const authorization: ExactEIP3009Payload[\"authorization\"] = {\n    from: signer.address,\n    to: getAddress(paymentRequirements.payTo),\n    value: paymentRequirements.amount,\n    validAfter: (now - 600).toString(),\n    validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),\n    nonce,\n  };\n\n  const signature = await signEIP3009Authorization(signer, authorization, paymentRequirements);\n\n  const payload: ExactEIP3009Payload = {\n    authorization,\n    signature,\n  };\n\n  return {\n    x402Version,\n    payload,\n  };\n}\n\n/**\n * Sign the EIP-3009 authorization using EIP-712.\n *\n * @param signer - The EVM signer\n * @param authorization - The authorization to sign\n * @param requirements - The payment requirements\n * @returns Promise resolving to the signature\n */\nasync function signEIP3009Authorization(\n  signer: ClientEvmSigner,\n  authorization: ExactEIP3009Payload[\"authorization\"],\n  requirements: PaymentRequirements,\n): Promise<`0x${string}`> {\n  const chainId = parseInt(requirements.network.split(\":\")[1]);\n\n  if (!requirements.extra?.name || !requirements.extra?.version) {\n    throw new Error(\n      `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n    );\n  }\n\n  const { name, version } = requirements.extra;\n\n  const domain = {\n    name,\n    version,\n    chainId,\n    verifyingContract: getAddress(requirements.asset),\n  };\n\n  const message = {\n    from: getAddress(authorization.from),\n    to: getAddress(authorization.to),\n    value: BigInt(authorization.value),\n    validAfter: BigInt(authorization.validAfter),\n    validBefore: BigInt(authorization.validBefore),\n    nonce: authorization.nonce,\n  };\n\n  return await signer.signTypedData({\n    domain,\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\",\n    message,\n  });\n}\n","// EIP-3009 TransferWithAuthorization types for EIP-712 signing\nexport const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n} as const;\n\n/**\n * Permit2 EIP-712 types for signing PermitWitnessTransferFrom.\n * Must match the exact format expected by the Permit2 contract.\n * Note: Types must be in ALPHABETICAL order after the primary type (TokenPermissions < Witness).\n */\nexport const permit2WitnessTypes = {\n  PermitWitnessTransferFrom: [\n    { name: \"permitted\", type: \"TokenPermissions\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"deadline\", type: \"uint256\" },\n    { name: \"witness\", type: \"Witness\" },\n  ],\n  TokenPermissions: [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint256\" },\n  ],\n  Witness: [\n    { name: \"to\", type: \"address\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"extra\", type: \"bytes\" },\n  ],\n} as const;\n\n// EIP3009 ABI for transferWithAuthorization function\nexport const eip3009ABI = [\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"v\", type: \"uint8\" },\n      { name: \"r\", type: \"bytes32\" },\n      { name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\n/**\n * Canonical Permit2 contract address.\n * Same address on all EVM chains via CREATE2 deployment.\n *\n * @see https://github.com/Uniswap/permit2\n */\nexport const PERMIT2_ADDRESS = \"0x000000000022D473030F116dDEE9F6B43aC78BA3\" as const;\n\n/**\n * x402ExactPermit2Proxy contract address.\n * Vanity address: 0x4020...0001 for easy recognition.\n * This address is deterministic based on:\n * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)\n * - Vanity-mined salt for prefix 0x4020 and suffix 0001\n * - Contract bytecode + constructor args (PERMIT2_ADDRESS)\n */\nexport const x402ExactPermit2ProxyAddress = \"0x4020615294c913F045dc10f0a5cdEbd86c280001\" as const;\n\n/**\n * x402UptoPermit2Proxy contract address.\n * Vanity address: 0x4020...0002 for easy recognition.\n * This address is deterministic based on:\n * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)\n * - Vanity-mined salt for prefix 0x4020 and suffix 0002\n * - Contract bytecode + constructor args (PERMIT2_ADDRESS)\n */\nexport const x402UptoPermit2ProxyAddress = \"0x4020633461b2895a48930Ff97eE8fCdE8E520002\" as const;\n\n/**\n * x402UptoPermit2Proxy ABI - settle function for upto payment scheme (variable amounts).\n */\nexport const x402UptoPermit2ProxyABI = [\n  {\n    type: \"function\",\n    name: \"PERMIT2\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"address\", internalType: \"contract ISignatureTransfer\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPEHASH\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"bytes32\", internalType: \"bytes32\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPE_STRING\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"string\", internalType: \"string\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"initialize\",\n    inputs: [{ name: \"_permit2\", type: \"address\", internalType: \"address\" }],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settle\",\n    inputs: [\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.Witness\",\n        components: [\n          { name: \"to\", type: \"address\", internalType: \"address\" },\n          { name: \"validAfter\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"extra\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settleWithPermit\",\n    inputs: [\n      {\n        name: \"permit2612\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.EIP2612Permit\",\n        components: [\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"r\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"s\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"v\", type: \"uint8\", internalType: \"uint8\" },\n        ],\n      },\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.Witness\",\n        components: [\n          { name: \"to\", type: \"address\", internalType: \"address\" },\n          { name: \"validAfter\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"extra\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  { type: \"event\", name: \"Settled\", inputs: [], anonymous: false },\n  { type: \"event\", name: \"SettledWithPermit\", inputs: [], anonymous: false },\n  { type: \"error\", name: \"AlreadyInitialized\", inputs: [] },\n  { type: \"error\", name: \"AmountExceedsPermitted\", inputs: [] },\n  { type: \"error\", name: \"InvalidDestination\", inputs: [] },\n  { type: \"error\", name: \"InvalidOwner\", inputs: [] },\n  { type: \"error\", name: \"InvalidPermit2Address\", inputs: [] },\n  { type: \"error\", name: \"PaymentTooEarly\", inputs: [] },\n  { type: \"error\", name: \"ReentrancyGuardReentrantCall\", inputs: [] },\n] as const;\n\n/**\n * x402ExactPermit2Proxy ABI - settle function for exact payment scheme.\n */\nexport const x402ExactPermit2ProxyABI = [\n  {\n    type: \"function\",\n    name: \"PERMIT2\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"address\", internalType: \"contract ISignatureTransfer\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPEHASH\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"bytes32\", internalType: \"bytes32\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPE_STRING\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"string\", internalType: \"string\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"initialize\",\n    inputs: [{ name: \"_permit2\", type: \"address\", internalType: \"address\" }],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settle\",\n    inputs: [\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.Witness\",\n        components: [\n          { name: \"to\", type: \"address\", internalType: \"address\" },\n          { name: \"validAfter\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"extra\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settleWithPermit\",\n    inputs: [\n      {\n        name: \"permit2612\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.EIP2612Permit\",\n        components: [\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"r\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"s\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"v\", type: \"uint8\", internalType: \"uint8\" },\n        ],\n      },\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402BasePermit2Proxy.Witness\",\n        components: [\n          { name: \"to\", type: \"address\", internalType: \"address\" },\n          { name: \"validAfter\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"extra\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  { type: \"event\", name: \"Settled\", inputs: [], anonymous: false },\n  { type: \"event\", name: \"SettledWithPermit\", inputs: [], anonymous: false },\n  { type: \"error\", name: \"AlreadyInitialized\", inputs: [] },\n  { type: \"error\", name: \"InvalidDestination\", inputs: [] },\n  { type: \"error\", name: \"InvalidOwner\", inputs: [] },\n  { type: \"error\", name: \"InvalidPermit2Address\", inputs: [] },\n  { type: \"error\", name: \"PaymentTooEarly\", inputs: [] },\n  { type: \"error\", name: \"ReentrancyGuardReentrantCall\", inputs: [] },\n] as const;\n","import { toHex } from \"viem\";\nimport { EVM_NETWORK_CHAIN_ID_MAP, EvmNetworkV1 } from \"./v1\";\n\n/**\n * Extract chain ID from network string (e.g., \"base-sepolia\" -> 84532)\n * Used by v1 implementations\n *\n * @param network - The network identifier\n * @returns The numeric chain ID\n * @throws Error if the network is not supported\n */\nexport function getEvmChainId(network: EvmNetworkV1): number {\n  const chainId = EVM_NETWORK_CHAIN_ID_MAP[network];\n  if (!chainId) {\n    throw new Error(`Unsupported network: ${network}`);\n  }\n  return chainId;\n}\n\n/**\n * Get the crypto object from the global scope.\n *\n * @returns The crypto object\n * @throws Error if crypto API is not available\n */\nfunction getCrypto(): Crypto {\n  const cryptoObj = globalThis.crypto as Crypto | undefined;\n  if (!cryptoObj) {\n    throw new Error(\"Crypto API not available\");\n  }\n  return cryptoObj;\n}\n\n/**\n * Create a random 32-byte nonce for EIP-3009 authorization.\n *\n * @returns A hex-encoded 32-byte nonce\n */\nexport function createNonce(): `0x${string}` {\n  return toHex(getCrypto().getRandomValues(new Uint8Array(32)));\n}\n\n/**\n * Creates a random 256-bit nonce for Permit2.\n * Permit2 uses uint256 nonces (not bytes32 like EIP-3009).\n *\n * @returns A string representation of the random nonce\n */\nexport function createPermit2Nonce(): string {\n  const randomBytes = getCrypto().getRandomValues(new Uint8Array(32));\n  return BigInt(toHex(randomBytes)).toString();\n}\n","import {\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../../constants\";\nimport { ClientEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { createNonce, getEvmChainId } from \"../../../utils\";\nimport { EvmNetworkV1 } from \"../../../v1\";\n\n/**\n * EVM client implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClientV1 instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme (V1).\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<\n    Pick<PaymentPayload, \"x402Version\" | \"payload\"> & { scheme: string; network: Network }\n  > {\n    const selectedV1 = paymentRequirements as unknown as PaymentRequirementsV1;\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV1[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(selectedV1.payTo),\n      value: selectedV1.maxAmountRequired,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + selectedV1.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, selectedV1);\n\n    const payload: ExactEvmPayloadV1 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      scheme: selectedV1.scheme,\n      network: selectedV1.network,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV1[\"authorization\"],\n    requirements: PaymentRequirementsV1,\n  ): Promise<`0x${string}`> {\n    const chainId = getEvmChainId(requirements.network as EvmNetworkV1);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","import {\n  PaymentPayload,\n  PaymentPayloadV1,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../../constants\";\nimport { FacilitatorEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { getEvmChainId } from \"../../../utils\";\nimport { EvmNetworkV1 } from \"../../../v1\";\n\nexport interface ExactEvmSchemeV1Config {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeV1Config>;\n\n  /**\n   * Creates a new ExactEvmFacilitatorV1 instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeV1Config,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For EVM, no extra data is needed.\n   *\n   * @param _ - The network identifier (unused for EVM)\n   * @returns undefined (EVM has no extra data)\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * Returns all addresses this facilitator can use for signing/settling transactions.\n   *\n   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload (V1).\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const requirementsV1 = requirements as unknown as PaymentRequirementsV1;\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Verify scheme matches\n    if (payloadV1.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Get chain configuration\n    let chainId: number;\n    try {\n      chainId = getEvmChainId(payloadV1.network as EvmNetworkV1);\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: `invalid_network`,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      return {\n        isValid: false,\n        invalidReason: \"missing_eip712_domain\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    const { name, version } = requirements.extra;\n    const erc20Address = getAddress(requirements.asset);\n\n    // Verify network matches\n    if (payloadV1.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Build typed data for signature verification\n    const permitTypedData = {\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\" as const,\n      domain: {\n        name,\n        version,\n        chainId,\n        verifyingContract: erc20Address,\n      },\n      message: {\n        from: exactEvmPayload.authorization.from,\n        to: exactEvmPayload.authorization.to,\n        value: BigInt(exactEvmPayload.authorization.value),\n        validAfter: BigInt(exactEvmPayload.authorization.validAfter),\n        validBefore: BigInt(exactEvmPayload.authorization.validBefore),\n        nonce: exactEvmPayload.authorization.nonce,\n      },\n    };\n\n    // Verify signature\n    try {\n      const recoveredAddress = await this.signer.verifyTypedData({\n        address: exactEvmPayload.authorization.from,\n        ...permitTypedData,\n        signature: exactEvmPayload.signature!,\n      });\n\n      if (!recoveredAddress) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // Signature verification failed - could be an undeployed smart wallet\n      // Check if smart wallet is deployed\n      const signature = exactEvmPayload.signature!;\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n      if (isSmartWallet) {\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n          // EIP-6492 signatures contain factory address and calldata needed for deployment.\n          // Non-EIP-6492 undeployed wallets cannot succeed (no way to deploy them).\n          const erc6492Data = parseErc6492Signature(signature);\n          const hasDeploymentInfo =\n            erc6492Data.address &&\n            erc6492Data.data &&\n            !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n          if (!hasDeploymentInfo) {\n            // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n            // since EIP-3009 requires on-chain EIP-1271 validation\n            return {\n              isValid: false,\n              invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n              payer: payerAddress,\n            };\n          }\n          // EIP-6492 signature with deployment info - allow through\n          // Facilitators with sponsored deployment support can handle this in settle()\n        } else {\n          // Wallet is deployed but signature still failed - invalid signature\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_signature\",\n            payer: exactEvmPayload.authorization.from,\n          };\n        }\n      } else {\n        // EOA signature failed\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    }\n\n    // Verify payment recipient matches\n    if (getAddress(exactEvmPayload.authorization.to) !== getAddress(requirements.payTo)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validBefore is in the future (with 6 second buffer for block time)\n    const now = Math.floor(Date.now() / 1000);\n    if (BigInt(exactEvmPayload.authorization.validBefore) < BigInt(now + 6)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validAfter is not in the future\n    if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(now)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Check balance\n    try {\n      const balance = (await this.signer.readContract({\n        address: erc20Address,\n        abi: eip3009ABI,\n        functionName: \"balanceOf\",\n        args: [exactEvmPayload.authorization.from],\n      })) as bigint;\n\n      if (BigInt(balance) < BigInt(requirementsV1.maxAmountRequired)) {\n        return {\n          isValid: false,\n          invalidReason: \"insufficient_funds\",\n          invalidMessage: `Insufficient funds to complete the payment. Required: ${requirementsV1.maxAmountRequired} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // If we can't check balance, continue with other validations\n    }\n\n    // Verify amount is sufficient\n    if (BigInt(exactEvmPayload.authorization.value) < BigInt(requirementsV1.maxAmountRequired)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  /**\n   * Settles a payment by executing the transfer (V1).\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Re-verify before settling\n    const valid = await this.verify(payload, requirements);\n    if (!valid.isValid) {\n      return {\n        success: false,\n        network: payloadV1.network,\n        transaction: \"\",\n        errorReason: valid.invalidReason ?? \"invalid_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    try {\n      // Parse ERC-6492 signature if applicable\n      const parseResult = parseErc6492Signature(exactEvmPayload.signature!);\n      const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n      // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n      if (\n        this.config.deployERC4337WithEIP6492 &&\n        factoryAddress &&\n        factoryCalldata &&\n        !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n      ) {\n        // Check if smart wallet is already deployed\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet not deployed - attempt deployment\n          try {\n            console.log(`Deploying ERC-4337 smart wallet for ${payerAddress} via EIP-6492`);\n\n            // Send the factory calldata directly as a transaction\n            // The factoryCalldata already contains the complete encoded function call\n            const deployTx = await this.signer.sendTransaction({\n              to: factoryAddress as Hex,\n              data: factoryCalldata as Hex,\n            });\n\n            // Wait for deployment transaction\n            await this.signer.waitForTransactionReceipt({ hash: deployTx });\n            console.log(`Successfully deployed smart wallet for ${payerAddress}`);\n          } catch (deployError) {\n            console.error(\"Smart wallet deployment failed:\", deployError);\n            // Deployment failed - cannot proceed\n            throw deployError;\n          }\n        } else {\n          console.log(`Smart wallet for ${payerAddress} already deployed, skipping deployment`);\n        }\n      }\n\n      // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n      // ECDSA signatures are exactly 65 bytes (130 hex chars without 0x)\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isECDSA = signatureLength === 130;\n\n      let tx: Hex;\n      if (isECDSA) {\n        // For EOA wallets, parse signature into v, r, s and use that overload\n        const parsedSig = parseSignature(signature);\n\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            (parsedSig.v as number | undefined) || parsedSig.yParity,\n            parsedSig.r,\n            parsedSig.s,\n          ],\n        });\n      } else {\n        // For smart wallets, use the bytes signature overload\n        // The signature contains WebAuthn/P256 or other ERC-1271 compatible signature data\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            signature,\n          ],\n        });\n      }\n\n      // Wait for transaction confirmation\n      const receipt = await this.signer.waitForTransactionReceipt({ hash: tx });\n\n      if (receipt.status !== \"success\") {\n        return {\n          success: false,\n          errorReason: \"invalid_transaction_state\",\n          transaction: tx,\n          network: payloadV1.network,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n\n      return {\n        success: true,\n        transaction: tx,\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    } catch (error) {\n      console.error(\"Failed to settle transaction:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_failed\",\n        transaction: \"\",\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n  }\n}\n","export { ExactEvmSchemeV1 } from \"../exact/v1\";\n\nexport const EVM_NETWORK_CHAIN_ID_MAP = {\n  ethereum: 1,\n  sepolia: 11155111,\n  abstract: 2741,\n  \"abstract-testnet\": 11124,\n  \"base-sepolia\": 84532,\n  base: 8453,\n  \"avalanche-fuji\": 43113,\n  avalanche: 43114,\n  iotex: 4689,\n  sei: 1329,\n  \"sei-testnet\": 1328,\n  polygon: 137,\n  \"polygon-amoy\": 80002,\n  peaq: 3338,\n  story: 1514,\n  educhain: 41923,\n  \"skale-base-sepolia\": 324705682,\n} as const;\n\nexport type EvmNetworkV1 = keyof typeof EVM_NETWORK_CHAIN_ID_MAP;\n\nexport const NETWORKS: string[] = Object.keys(EVM_NETWORK_CHAIN_ID_MAP);\n","import { PaymentRequirements, PaymentPayloadResult } from \"@x402/core/types\";\nimport { encodeFunctionData, getAddress } from \"viem\";\nimport {\n  permit2WitnessTypes,\n  PERMIT2_ADDRESS,\n  x402ExactPermit2ProxyAddress,\n} from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactPermit2Payload } from \"../../types\";\nimport { createPermit2Nonce } from \"../../utils\";\n\n/** Maximum uint256 value for unlimited approval. */\nconst MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n/**\n * Creates a Permit2 payload using the x402Permit2Proxy witness pattern.\n * The spender is set to x402Permit2Proxy, which enforces that funds\n * can only be sent to the witness.to address.\n *\n * @param signer - The EVM signer for client operations\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - The payment requirements\n * @returns Promise resolving to a payment payload result\n */\nexport async function createPermit2Payload(\n  signer: ClientEvmSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayloadResult> {\n  const now = Math.floor(Date.now() / 1000);\n  const nonce = createPermit2Nonce();\n\n  // Lower time bound - allow some clock skew\n  const validAfter = (now - 600).toString();\n  // Upper time bound is enforced by Permit2's deadline field\n  const deadline = (now + paymentRequirements.maxTimeoutSeconds).toString();\n\n  const permit2Authorization: ExactPermit2Payload[\"permit2Authorization\"] = {\n    from: signer.address,\n    permitted: {\n      token: getAddress(paymentRequirements.asset),\n      amount: paymentRequirements.amount,\n    },\n    spender: x402ExactPermit2ProxyAddress,\n    nonce,\n    deadline,\n    witness: {\n      to: getAddress(paymentRequirements.payTo),\n      validAfter,\n      extra: \"0x\",\n    },\n  };\n\n  const signature = await signPermit2Authorization(\n    signer,\n    permit2Authorization,\n    paymentRequirements,\n  );\n\n  const payload: ExactPermit2Payload = {\n    signature,\n    permit2Authorization,\n  };\n\n  return {\n    x402Version,\n    payload,\n  };\n}\n\n/**\n * Sign the Permit2 authorization using EIP-712 with witness data.\n * The signature authorizes the x402Permit2Proxy to transfer tokens on behalf of the signer.\n *\n * @param signer - The EVM signer\n * @param permit2Authorization - The Permit2 authorization parameters\n * @param requirements - The payment requirements\n * @returns Promise resolving to the signature\n */\nasync function signPermit2Authorization(\n  signer: ClientEvmSigner,\n  permit2Authorization: ExactPermit2Payload[\"permit2Authorization\"],\n  requirements: PaymentRequirements,\n): Promise<`0x${string}`> {\n  const chainId = parseInt(requirements.network.split(\":\")[1]);\n\n  const domain = {\n    name: \"Permit2\",\n    chainId,\n    verifyingContract: PERMIT2_ADDRESS,\n  };\n\n  const message = {\n    permitted: {\n      token: getAddress(permit2Authorization.permitted.token),\n      amount: BigInt(permit2Authorization.permitted.amount),\n    },\n    spender: getAddress(permit2Authorization.spender),\n    nonce: BigInt(permit2Authorization.nonce),\n    deadline: BigInt(permit2Authorization.deadline),\n    witness: {\n      to: getAddress(permit2Authorization.witness.to),\n      validAfter: BigInt(permit2Authorization.witness.validAfter),\n      extra: permit2Authorization.witness.extra,\n    },\n  };\n\n  return await signer.signTypedData({\n    domain,\n    types: permit2WitnessTypes,\n    primaryType: \"PermitWitnessTransferFrom\",\n    message,\n  });\n}\n\n/**\n * ERC20 approve ABI for encoding approval transactions.\n */\nconst erc20ApproveAbi = [\n  {\n    type: \"function\",\n    name: \"approve\",\n    inputs: [\n      { name: \"spender\", type: \"address\" },\n      { name: \"amount\", type: \"uint256\" },\n    ],\n    outputs: [{ type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n  },\n] as const;\n\n/**\n * ERC20 allowance ABI for checking approval status.\n */\nexport const erc20AllowanceAbi = [\n  {\n    type: \"function\",\n    name: \"allowance\",\n    inputs: [\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n    ],\n    outputs: [{ type: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\n/**\n * Creates transaction data to approve Permit2 to spend tokens.\n * The user sends this transaction (paying gas) before using Permit2 flow.\n *\n * @param tokenAddress - The ERC20 token contract address\n * @returns Transaction data to send for approval\n *\n * @example\n * ```typescript\n * const tx = createPermit2ApprovalTx(\"0x...\");\n * await walletClient.sendTransaction({\n *   to: tx.to,\n *   data: tx.data,\n * });\n * ```\n */\nexport function createPermit2ApprovalTx(tokenAddress: `0x${string}`): {\n  to: `0x${string}`;\n  data: `0x${string}`;\n} {\n  const data = encodeFunctionData({\n    abi: erc20ApproveAbi,\n    functionName: \"approve\",\n    args: [PERMIT2_ADDRESS, MAX_UINT256],\n  });\n\n  return {\n    to: getAddress(tokenAddress),\n    data,\n  };\n}\n\n/**\n * Parameters for checking Permit2 allowance.\n * Application provides these to check if approval is needed.\n */\nexport interface Permit2AllowanceParams {\n  tokenAddress: `0x${string}`;\n  ownerAddress: `0x${string}`;\n}\n\n/**\n * Returns contract read parameters for checking Permit2 allowance.\n * Use with a public client to check if the user has approved Permit2.\n *\n * @param params - The allowance check parameters\n * @returns Contract read parameters for checking allowance\n *\n * @example\n * ```typescript\n * const readParams = getPermit2AllowanceReadParams({\n *   tokenAddress: \"0x...\",\n *   ownerAddress: \"0x...\",\n * });\n *\n * const allowance = await publicClient.readContract(readParams);\n * const needsApproval = allowance < requiredAmount;\n * ```\n */\nexport function getPermit2AllowanceReadParams(params: Permit2AllowanceParams): {\n  address: `0x${string}`;\n  abi: typeof erc20AllowanceAbi;\n  functionName: \"allowance\";\n  args: [`0x${string}`, `0x${string}`];\n} {\n  return {\n    address: getAddress(params.tokenAddress),\n    abi: erc20AllowanceAbi,\n    functionName: \"allowance\",\n    args: [getAddress(params.ownerAddress), PERMIT2_ADDRESS],\n  };\n}\n","import { PaymentRequirements, SchemeNetworkClient, PaymentPayloadResult } from \"@x402/core/types\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { AssetTransferMethod } from \"../../types\";\nimport { createEIP3009Payload } from \"./eip3009\";\nimport { createPermit2Payload } from \"./permit2\";\n\n/**\n * EVM client implementation for the Exact payment scheme.\n * Supports both EIP-3009 (transferWithAuthorization) and Permit2 flows.\n *\n * Routes to the appropriate authorization method based on\n * `requirements.extra.assetTransferMethod`. Defaults to EIP-3009\n * for backward compatibility with older facilitators.\n */\nexport class ExactEvmScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClient instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme.\n   * Routes to EIP-3009 or Permit2 based on requirements.extra.assetTransferMethod.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload result\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<PaymentPayloadResult> {\n    const assetTransferMethod =\n      (paymentRequirements.extra?.assetTransferMethod as AssetTransferMethod) ?? \"eip3009\";\n\n    if (assetTransferMethod === \"permit2\") {\n      return createPermit2Payload(this.signer, x402Version, paymentRequirements);\n    }\n\n    return createEIP3009Payload(this.signer, x402Version, paymentRequirements);\n  }\n}\n","import { x402Client, SelectPaymentRequirements, PaymentPolicy } from \"@x402/core/client\";\nimport { Network } from \"@x402/core/types\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/client/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Client\n */\nexport interface EvmClientConfig {\n  /**\n   * The EVM signer to use for creating payment payloads\n   */\n  signer: ClientEvmSigner;\n\n  /**\n   * Optional payment requirements selector function\n   * If not provided, uses the default selector (first available option)\n   */\n  paymentRequirementsSelector?: SelectPaymentRequirements;\n\n  /**\n   * Optional policies to apply to the client\n   */\n  policies?: PaymentPolicy[];\n\n  /**\n   * Optional specific networks to register\n   * If not provided, registers wildcard support (eip155:*)\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Client instance.\n *\n * This function registers:\n * - V2: eip155:* wildcard scheme with ExactEvmScheme (or specific networks if provided)\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param client - The x402Client instance to register schemes to\n * @param config - Configuration for EVM client registration\n * @returns The client instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/client/register\";\n * import { x402Client } from \"@x402/core/client\";\n * import { privateKeyToAccount } from \"viem/accounts\";\n *\n * const account = privateKeyToAccount(\"0x...\");\n * const client = new x402Client();\n * registerExactEvmScheme(client, { signer: account });\n * ```\n */\nexport function registerExactEvmScheme(client: x402Client, config: EvmClientConfig): x402Client {\n  // Register V2 scheme\n  if (config.networks && config.networks.length > 0) {\n    // Register specific networks\n    config.networks.forEach(network => {\n      client.register(network, new ExactEvmScheme(config.signer));\n    });\n  } else {\n    // Register wildcard for all EVM chains\n    client.register(\"eip155:*\", new ExactEvmScheme(config.signer));\n  }\n\n  // Register all V1 networks\n  NETWORKS.forEach(network => {\n    client.registerV1(network as Network, new ExactEvmSchemeV1(config.signer));\n  });\n\n  // Apply policies if provided\n  if (config.policies) {\n    config.policies.forEach(policy => {\n      client.registerPolicy(policy);\n    });\n  }\n\n  return client;\n}\n"],"mappings":"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","names":["import_viem","import_viem","import_viem","import_viem"]}