"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/exact/facilitator/index.ts
var facilitator_exports = {};
__export(facilitator_exports, {
  ExactEvmScheme: () => ExactEvmScheme,
  registerExactEvmScheme: () => registerExactEvmScheme
});
module.exports = __toCommonJS(facilitator_exports);

// src/types.ts
function isPermit2Payload(payload) {
  return "permit2Authorization" in payload;
}

// src/exact/facilitator/eip3009.ts
var import_viem = require("viem");

// src/constants.ts
var authorizationTypes = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};
var permit2WitnessTypes = {
  PermitWitnessTransferFrom: [
    { name: "permitted", type: "TokenPermissions" },
    { name: "spender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "witness", type: "Witness" }
  ],
  TokenPermissions: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  Witness: [
    { name: "to", type: "address" },
    { name: "validAfter", type: "uint256" },
    { name: "extra", type: "bytes" }
  ]
};
var eip3009ABI = [
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" },
      { name: "v", type: "uint8" },
      { name: "r", type: "bytes32" },
      { name: "s", type: "bytes32" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" },
      { name: "signature", type: "bytes" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];
var PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
var x402ExactPermit2ProxyAddress = "0x4020615294c913F045dc10f0a5cdEbd86c280001";
var x402ExactPermit2ProxyABI = [
  {
    type: "function",
    name: "PERMIT2",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "contract ISignatureTransfer" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "WITNESS_TYPEHASH",
    inputs: [],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "WITNESS_TYPE_STRING",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [{ name: "_permit2", type: "address", internalType: "address" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "settle",
    inputs: [
      {
        name: "permit",
        type: "tuple",
        internalType: "struct ISignatureTransfer.PermitTransferFrom",
        components: [
          {
            name: "permitted",
            type: "tuple",
            internalType: "struct ISignatureTransfer.TokenPermissions",
            components: [
              { name: "token", type: "address", internalType: "address" },
              { name: "amount", type: "uint256", internalType: "uint256" }
            ]
          },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" }
        ]
      },
      { name: "owner", type: "address", internalType: "address" },
      {
        name: "witness",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.Witness",
        components: [
          { name: "to", type: "address", internalType: "address" },
          { name: "validAfter", type: "uint256", internalType: "uint256" },
          { name: "extra", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "settleWithPermit",
    inputs: [
      {
        name: "permit2612",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.EIP2612Permit",
        components: [
          { name: "value", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" },
          { name: "r", type: "bytes32", internalType: "bytes32" },
          { name: "s", type: "bytes32", internalType: "bytes32" },
          { name: "v", type: "uint8", internalType: "uint8" }
        ]
      },
      {
        name: "permit",
        type: "tuple",
        internalType: "struct ISignatureTransfer.PermitTransferFrom",
        components: [
          {
            name: "permitted",
            type: "tuple",
            internalType: "struct ISignatureTransfer.TokenPermissions",
            components: [
              { name: "token", type: "address", internalType: "address" },
              { name: "amount", type: "uint256", internalType: "uint256" }
            ]
          },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" }
        ]
      },
      { name: "owner", type: "address", internalType: "address" },
      {
        name: "witness",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.Witness",
        components: [
          { name: "to", type: "address", internalType: "address" },
          { name: "validAfter", type: "uint256", internalType: "uint256" },
          { name: "extra", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  { type: "event", name: "Settled", inputs: [], anonymous: false },
  { type: "event", name: "SettledWithPermit", inputs: [], anonymous: false },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidDestination", inputs: [] },
  { type: "error", name: "InvalidOwner", inputs: [] },
  { type: "error", name: "InvalidPermit2Address", inputs: [] },
  { type: "error", name: "PaymentTooEarly", inputs: [] },
  { type: "error", name: "ReentrancyGuardReentrantCall", inputs: [] }
];

// src/exact/facilitator/eip3009.ts
async function verifyEIP3009(signer, payload, requirements, eip3009Payload) {
  const payer = eip3009Payload.authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (!requirements.extra?.name || !requirements.extra?.version) {
    return {
      isValid: false,
      invalidReason: "missing_eip712_domain",
      payer
    };
  }
  const { name, version } = requirements.extra;
  const erc20Address = (0, import_viem.getAddress)(requirements.asset);
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const permitTypedData = {
    types: authorizationTypes,
    primaryType: "TransferWithAuthorization",
    domain: {
      name,
      version,
      chainId: parseInt(requirements.network.split(":")[1]),
      verifyingContract: erc20Address
    },
    message: {
      from: eip3009Payload.authorization.from,
      to: eip3009Payload.authorization.to,
      value: BigInt(eip3009Payload.authorization.value),
      validAfter: BigInt(eip3009Payload.authorization.validAfter),
      validBefore: BigInt(eip3009Payload.authorization.validBefore),
      nonce: eip3009Payload.authorization.nonce
    }
  };
  try {
    const recoveredAddress = await signer.verifyTypedData({
      address: eip3009Payload.authorization.from,
      ...permitTypedData,
      signature: eip3009Payload.signature
    });
    if (!recoveredAddress) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  } catch {
    const signature = eip3009Payload.signature;
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isSmartWallet = signatureLength > 130;
    if (isSmartWallet) {
      const payerAddress = eip3009Payload.authorization.from;
      const bytecode = await signer.getCode({ address: payerAddress });
      if (!bytecode || bytecode === "0x") {
        const erc6492Data = (0, import_viem.parseErc6492Signature)(signature);
        const hasDeploymentInfo = erc6492Data.address && erc6492Data.data && !(0, import_viem.isAddressEqual)(erc6492Data.address, "0x0000000000000000000000000000000000000000");
        if (!hasDeploymentInfo) {
          return {
            isValid: false,
            invalidReason: "invalid_exact_evm_payload_undeployed_smart_wallet",
            payer: payerAddress
          };
        }
      } else {
        return {
          isValid: false,
          invalidReason: "invalid_exact_evm_payload_signature",
          payer
        };
      }
    } else {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  }
  if ((0, import_viem.getAddress)(eip3009Payload.authorization.to) !== (0, import_viem.getAddress)(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_before",
      payer
    };
  }
  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_after",
      payer
    };
  }
  try {
    const balance = await signer.readContract({
      address: erc20Address,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [eip3009Payload.authorization.from]
    });
    if (BigInt(balance) < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_value",
      payer
    };
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function settleEIP3009(signer, payload, requirements, eip3009Payload, config) {
  const payer = eip3009Payload.authorization.from;
  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  try {
    const parseResult = (0, import_viem.parseErc6492Signature)(eip3009Payload.signature);
    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;
    if (config.deployERC4337WithEIP6492 && factoryAddress && factoryCalldata && !(0, import_viem.isAddressEqual)(factoryAddress, "0x0000000000000000000000000000000000000000")) {
      const bytecode = await signer.getCode({ address: payer });
      if (!bytecode || bytecode === "0x") {
        const deployTx = await signer.sendTransaction({
          to: factoryAddress,
          data: factoryCalldata
        });
        await signer.waitForTransactionReceipt({ hash: deployTx });
      }
    }
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isECDSA = signatureLength === 130;
    let tx;
    if (isECDSA) {
      const parsedSig = (0, import_viem.parseSignature)(signature);
      tx = await signer.writeContract({
        address: (0, import_viem.getAddress)(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          (0, import_viem.getAddress)(eip3009Payload.authorization.from),
          (0, import_viem.getAddress)(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          parsedSig.v || parsedSig.yParity,
          parsedSig.r,
          parsedSig.s
        ]
      });
    } else {
      tx = await signer.writeContract({
        address: (0, import_viem.getAddress)(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          (0, import_viem.getAddress)(eip3009Payload.authorization.from),
          (0, import_viem.getAddress)(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          signature
        ]
      });
    }
    const receipt = await signer.waitForTransactionReceipt({ hash: tx });
    if (receipt.status !== "success") {
      return {
        success: false,
        errorReason: "invalid_transaction_state",
        transaction: tx,
        network: payload.accepted.network,
        payer
      };
    }
    return {
      success: true,
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  } catch {
    return {
      success: false,
      errorReason: "transaction_failed",
      transaction: "",
      network: payload.accepted.network,
      payer
    };
  }
}

// src/exact/facilitator/permit2.ts
var import_viem2 = require("viem");
var erc20AllowanceABI = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" }
    ],
    outputs: [{ type: "uint256" }],
    stateMutability: "view"
  }
];
async function verifyPermit2(signer, payload, requirements, permit2Payload) {
  const payer = permit2Payload.permit2Authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const chainId = parseInt(requirements.network.split(":")[1]);
  const tokenAddress = (0, import_viem2.getAddress)(requirements.asset);
  if ((0, import_viem2.getAddress)(permit2Payload.permit2Authorization.spender) !== (0, import_viem2.getAddress)(x402ExactPermit2ProxyAddress)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_spender",
      payer
    };
  }
  if ((0, import_viem2.getAddress)(permit2Payload.permit2Authorization.witness.to) !== (0, import_viem2.getAddress)(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "permit2_deadline_expired",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "permit2_not_yet_valid",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "permit2_insufficient_amount",
      payer
    };
  }
  if ((0, import_viem2.getAddress)(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {
    return {
      isValid: false,
      invalidReason: "permit2_token_mismatch",
      payer
    };
  }
  const permit2TypedData = {
    types: permit2WitnessTypes,
    primaryType: "PermitWitnessTransferFrom",
    domain: {
      name: "Permit2",
      chainId,
      verifyingContract: PERMIT2_ADDRESS
    },
    message: {
      permitted: {
        token: (0, import_viem2.getAddress)(permit2Payload.permit2Authorization.permitted.token),
        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
      },
      spender: (0, import_viem2.getAddress)(permit2Payload.permit2Authorization.spender),
      nonce: BigInt(permit2Payload.permit2Authorization.nonce),
      deadline: BigInt(permit2Payload.permit2Authorization.deadline),
      witness: {
        to: (0, import_viem2.getAddress)(permit2Payload.permit2Authorization.witness.to),
        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),
        extra: permit2Payload.permit2Authorization.witness.extra
      }
    }
  };
  try {
    const isValid = await signer.verifyTypedData({
      address: payer,
      ...permit2TypedData,
      signature: permit2Payload.signature
    });
    if (!isValid) {
      return {
        isValid: false,
        invalidReason: "invalid_permit2_signature",
        payer
      };
    }
  } catch {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_signature",
      payer
    };
  }
  try {
    const allowance = await signer.readContract({
      address: tokenAddress,
      abi: erc20AllowanceABI,
      functionName: "allowance",
      args: [payer, PERMIT2_ADDRESS]
    });
    if (allowance < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "permit2_allowance_required",
        payer
      };
    }
  } catch {
  }
  try {
    const balance = await signer.readContract({
      address: tokenAddress,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [payer]
    });
    if (balance < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function settlePermit2(signer, payload, requirements, permit2Payload) {
  const payer = permit2Payload.permit2Authorization.from;
  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  try {
    const tx = await signer.writeContract({
      address: x402ExactPermit2ProxyAddress,
      abi: x402ExactPermit2ProxyABI,
      functionName: "settle",
      args: [
        {
          permitted: {
            token: (0, import_viem2.getAddress)(permit2Payload.permit2Authorization.permitted.token),
            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
          },
          nonce: BigInt(permit2Payload.permit2Authorization.nonce),
          deadline: BigInt(permit2Payload.permit2Authorization.deadline)
        },
        (0, import_viem2.getAddress)(payer),
        {
          to: (0, import_viem2.getAddress)(permit2Payload.permit2Authorization.witness.to),
          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),
          extra: permit2Payload.permit2Authorization.witness.extra
        },
        permit2Payload.signature
      ]
    });
    const receipt = await signer.waitForTransactionReceipt({ hash: tx });
    if (receipt.status !== "success") {
      return {
        success: false,
        errorReason: "invalid_transaction_state",
        transaction: tx,
        network: payload.accepted.network,
        payer
      };
    }
    return {
      success: true,
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  } catch (error) {
    let errorReason = "transaction_failed";
    if (error instanceof Error) {
      const message = error.message;
      if (message.includes("AmountExceedsPermitted")) {
        errorReason = "permit2_amount_exceeds_permitted";
      } else if (message.includes("InvalidDestination")) {
        errorReason = "permit2_invalid_destination";
      } else if (message.includes("InvalidOwner")) {
        errorReason = "permit2_invalid_owner";
      } else if (message.includes("PaymentTooEarly")) {
        errorReason = "permit2_payment_too_early";
      } else if (message.includes("InvalidSignature") || message.includes("SignatureExpired")) {
        errorReason = "permit2_invalid_signature";
      } else if (message.includes("InvalidNonce")) {
        errorReason = "permit2_invalid_nonce";
      } else {
        errorReason = `transaction_failed: ${message.slice(0, 500)}`;
      }
    }
    return {
      success: false,
      errorReason,
      transaction: "",
      network: payload.accepted.network,
      payer
    };
  }
}

// src/exact/facilitator/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmFacilitator instance.
   *
   * @param signer - The EVM signer for facilitator operations
   * @param config - Optional configuration for the facilitator
   */
  constructor(signer, config) {
    this.signer = signer;
    this.scheme = "exact";
    this.caipFamily = "eip155:*";
    this.config = {
      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false
    };
  }
  /**
   * Get mechanism-specific extra data for the supported kinds endpoint.
   * For EVM, no extra data is needed.
   *
   * @param _ - The network identifier (unused for EVM)
   * @returns undefined (EVM has no extra data)
   */
  getExtra(_) {
    return void 0;
  }
  /**
   * Get signer addresses used by this facilitator.
   * Returns all addresses this facilitator can use for signing/settling transactions.
   *
   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)
   * @returns Array of facilitator wallet addresses
   */
  getSigners(_) {
    return [...this.signer.getAddresses()];
  }
  /**
   * Verifies a payment payload.
   * Routes to the appropriate verification logic based on payload type.
   *
   * @param payload - The payment payload to verify
   * @param requirements - The payment requirements
   * @returns Promise resolving to verification response
   */
  async verify(payload, requirements) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return verifyPermit2(this.signer, payload, requirements, rawPayload);
    }
    const eip3009Payload = rawPayload;
    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);
  }
  /**
   * Settles a payment by executing the transfer.
   * Routes to the appropriate settlement logic based on payload type.
   *
   * @param payload - The payment payload to settle
   * @param requirements - The payment requirements
   * @returns Promise resolving to settlement response
   */
  async settle(payload, requirements) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return settlePermit2(this.signer, payload, requirements, rawPayload);
    }
    const eip3009Payload = rawPayload;
    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);
  }
};

// src/exact/v1/facilitator/scheme.ts
var import_viem5 = require("viem");

// src/utils.ts
var import_viem4 = require("viem");

// src/exact/v1/client/scheme.ts
var import_viem3 = require("viem");

// src/v1/index.ts
var EVM_NETWORK_CHAIN_ID_MAP = {
  ethereum: 1,
  sepolia: 11155111,
  abstract: 2741,
  "abstract-testnet": 11124,
  "base-sepolia": 84532,
  base: 8453,
  "avalanche-fuji": 43113,
  avalanche: 43114,
  iotex: 4689,
  sei: 1329,
  "sei-testnet": 1328,
  polygon: 137,
  "polygon-amoy": 80002,
  peaq: 3338,
  story: 1514,
  educhain: 41923,
  "skale-base-sepolia": 324705682
};
var NETWORKS = Object.keys(EVM_NETWORK_CHAIN_ID_MAP);

// src/utils.ts
function getEvmChainId(network) {
  const chainId = EVM_NETWORK_CHAIN_ID_MAP[network];
  if (!chainId) {
    throw new Error(`Unsupported network: ${network}`);
  }
  return chainId;
}

// src/exact/v1/facilitator/scheme.ts
var ExactEvmSchemeV12 = class {
  /**
   * Creates a new ExactEvmFacilitatorV1 instance.
   *
   * @param signer - The EVM signer for facilitator operations
   * @param config - Optional configuration for the facilitator
   */
  constructor(signer, config) {
    this.signer = signer;
    this.scheme = "exact";
    this.caipFamily = "eip155:*";
    this.config = {
      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false
    };
  }
  /**
   * Get mechanism-specific extra data for the supported kinds endpoint.
   * For EVM, no extra data is needed.
   *
   * @param _ - The network identifier (unused for EVM)
   * @returns undefined (EVM has no extra data)
   */
  getExtra(_) {
    return void 0;
  }
  /**
   * Get signer addresses used by this facilitator.
   * Returns all addresses this facilitator can use for signing/settling transactions.
   *
   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)
   * @returns Array of facilitator wallet addresses
   */
  getSigners(_) {
    return [...this.signer.getAddresses()];
  }
  /**
   * Verifies a payment payload (V1).
   *
   * @param payload - The payment payload to verify
   * @param requirements - The payment requirements
   * @returns Promise resolving to verification response
   */
  async verify(payload, requirements) {
    const requirementsV1 = requirements;
    const payloadV1 = payload;
    const exactEvmPayload = payload.payload;
    if (payloadV1.scheme !== "exact" || requirements.scheme !== "exact") {
      return {
        isValid: false,
        invalidReason: "unsupported_scheme",
        payer: exactEvmPayload.authorization.from
      };
    }
    let chainId;
    try {
      chainId = getEvmChainId(payloadV1.network);
    } catch {
      return {
        isValid: false,
        invalidReason: `invalid_network`,
        payer: exactEvmPayload.authorization.from
      };
    }
    if (!requirements.extra?.name || !requirements.extra?.version) {
      return {
        isValid: false,
        invalidReason: "missing_eip712_domain",
        payer: exactEvmPayload.authorization.from
      };
    }
    const { name, version } = requirements.extra;
    const erc20Address = (0, import_viem5.getAddress)(requirements.asset);
    if (payloadV1.network !== requirements.network) {
      return {
        isValid: false,
        invalidReason: "network_mismatch",
        payer: exactEvmPayload.authorization.from
      };
    }
    const permitTypedData = {
      types: authorizationTypes,
      primaryType: "TransferWithAuthorization",
      domain: {
        name,
        version,
        chainId,
        verifyingContract: erc20Address
      },
      message: {
        from: exactEvmPayload.authorization.from,
        to: exactEvmPayload.authorization.to,
        value: BigInt(exactEvmPayload.authorization.value),
        validAfter: BigInt(exactEvmPayload.authorization.validAfter),
        validBefore: BigInt(exactEvmPayload.authorization.validBefore),
        nonce: exactEvmPayload.authorization.nonce
      }
    };
    try {
      const recoveredAddress = await this.signer.verifyTypedData({
        address: exactEvmPayload.authorization.from,
        ...permitTypedData,
        signature: exactEvmPayload.signature
      });
      if (!recoveredAddress) {
        return {
          isValid: false,
          invalidReason: "invalid_exact_evm_payload_signature",
          payer: exactEvmPayload.authorization.from
        };
      }
    } catch {
      const signature = exactEvmPayload.signature;
      const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
      const isSmartWallet = signatureLength > 130;
      if (isSmartWallet) {
        const payerAddress = exactEvmPayload.authorization.from;
        const bytecode = await this.signer.getCode({ address: payerAddress });
        if (!bytecode || bytecode === "0x") {
          const erc6492Data = (0, import_viem5.parseErc6492Signature)(signature);
          const hasDeploymentInfo = erc6492Data.address && erc6492Data.data && !(0, import_viem5.isAddressEqual)(erc6492Data.address, "0x0000000000000000000000000000000000000000");
          if (!hasDeploymentInfo) {
            return {
              isValid: false,
              invalidReason: "invalid_exact_evm_payload_undeployed_smart_wallet",
              payer: payerAddress
            };
          }
        } else {
          return {
            isValid: false,
            invalidReason: "invalid_exact_evm_payload_signature",
            payer: exactEvmPayload.authorization.from
          };
        }
      } else {
        return {
          isValid: false,
          invalidReason: "invalid_exact_evm_payload_signature",
          payer: exactEvmPayload.authorization.from
        };
      }
    }
    if ((0, import_viem5.getAddress)(exactEvmPayload.authorization.to) !== (0, import_viem5.getAddress)(requirements.payTo)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_recipient_mismatch",
        payer: exactEvmPayload.authorization.from
      };
    }
    const now = Math.floor(Date.now() / 1e3);
    if (BigInt(exactEvmPayload.authorization.validBefore) < BigInt(now + 6)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_authorization_valid_before",
        payer: exactEvmPayload.authorization.from
      };
    }
    if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(now)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_authorization_valid_after",
        payer: exactEvmPayload.authorization.from
      };
    }
    try {
      const balance = await this.signer.readContract({
        address: erc20Address,
        abi: eip3009ABI,
        functionName: "balanceOf",
        args: [exactEvmPayload.authorization.from]
      });
      if (BigInt(balance) < BigInt(requirementsV1.maxAmountRequired)) {
        return {
          isValid: false,
          invalidReason: "insufficient_funds",
          invalidMessage: `Insufficient funds to complete the payment. Required: ${requirementsV1.maxAmountRequired} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
          payer: exactEvmPayload.authorization.from
        };
      }
    } catch {
    }
    if (BigInt(exactEvmPayload.authorization.value) < BigInt(requirementsV1.maxAmountRequired)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_authorization_value",
        payer: exactEvmPayload.authorization.from
      };
    }
    return {
      isValid: true,
      invalidReason: void 0,
      payer: exactEvmPayload.authorization.from
    };
  }
  /**
   * Settles a payment by executing the transfer (V1).
   *
   * @param payload - The payment payload to settle
   * @param requirements - The payment requirements
   * @returns Promise resolving to settlement response
   */
  async settle(payload, requirements) {
    const payloadV1 = payload;
    const exactEvmPayload = payload.payload;
    const valid = await this.verify(payload, requirements);
    if (!valid.isValid) {
      return {
        success: false,
        network: payloadV1.network,
        transaction: "",
        errorReason: valid.invalidReason ?? "invalid_scheme",
        payer: exactEvmPayload.authorization.from
      };
    }
    try {
      const parseResult = (0, import_viem5.parseErc6492Signature)(exactEvmPayload.signature);
      const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;
      if (this.config.deployERC4337WithEIP6492 && factoryAddress && factoryCalldata && !(0, import_viem5.isAddressEqual)(factoryAddress, "0x0000000000000000000000000000000000000000")) {
        const payerAddress = exactEvmPayload.authorization.from;
        const bytecode = await this.signer.getCode({ address: payerAddress });
        if (!bytecode || bytecode === "0x") {
          try {
            console.log(`Deploying ERC-4337 smart wallet for ${payerAddress} via EIP-6492`);
            const deployTx = await this.signer.sendTransaction({
              to: factoryAddress,
              data: factoryCalldata
            });
            await this.signer.waitForTransactionReceipt({ hash: deployTx });
            console.log(`Successfully deployed smart wallet for ${payerAddress}`);
          } catch (deployError) {
            console.error("Smart wallet deployment failed:", deployError);
            throw deployError;
          }
        } else {
          console.log(`Smart wallet for ${payerAddress} already deployed, skipping deployment`);
        }
      }
      const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
      const isECDSA = signatureLength === 130;
      let tx;
      if (isECDSA) {
        const parsedSig = (0, import_viem5.parseSignature)(signature);
        tx = await this.signer.writeContract({
          address: (0, import_viem5.getAddress)(requirements.asset),
          abi: eip3009ABI,
          functionName: "transferWithAuthorization",
          args: [
            (0, import_viem5.getAddress)(exactEvmPayload.authorization.from),
            (0, import_viem5.getAddress)(exactEvmPayload.authorization.to),
            BigInt(exactEvmPayload.authorization.value),
            BigInt(exactEvmPayload.authorization.validAfter),
            BigInt(exactEvmPayload.authorization.validBefore),
            exactEvmPayload.authorization.nonce,
            parsedSig.v || parsedSig.yParity,
            parsedSig.r,
            parsedSig.s
          ]
        });
      } else {
        tx = await this.signer.writeContract({
          address: (0, import_viem5.getAddress)(requirements.asset),
          abi: eip3009ABI,
          functionName: "transferWithAuthorization",
          args: [
            (0, import_viem5.getAddress)(exactEvmPayload.authorization.from),
            (0, import_viem5.getAddress)(exactEvmPayload.authorization.to),
            BigInt(exactEvmPayload.authorization.value),
            BigInt(exactEvmPayload.authorization.validAfter),
            BigInt(exactEvmPayload.authorization.validBefore),
            exactEvmPayload.authorization.nonce,
            signature
          ]
        });
      }
      const receipt = await this.signer.waitForTransactionReceipt({ hash: tx });
      if (receipt.status !== "success") {
        return {
          success: false,
          errorReason: "invalid_transaction_state",
          transaction: tx,
          network: payloadV1.network,
          payer: exactEvmPayload.authorization.from
        };
      }
      return {
        success: true,
        transaction: tx,
        network: payloadV1.network,
        payer: exactEvmPayload.authorization.from
      };
    } catch (error) {
      console.error("Failed to settle transaction:", error);
      return {
        success: false,
        errorReason: "transaction_failed",
        transaction: "",
        network: payloadV1.network,
        payer: exactEvmPayload.authorization.from
      };
    }
  }
};

// src/exact/facilitator/register.ts
function registerExactEvmScheme(facilitator, config) {
  facilitator.register(
    config.networks,
    new ExactEvmScheme(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  facilitator.registerV1(
    NETWORKS,
    new ExactEvmSchemeV12(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  return facilitator;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExactEvmScheme,
  registerExactEvmScheme
});
//# sourceMappingURL=index.js.map