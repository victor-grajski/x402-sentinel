"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ExactEvmScheme: () => ExactEvmScheme,
  PERMIT2_ADDRESS: () => PERMIT2_ADDRESS,
  authorizationTypes: () => authorizationTypes,
  createPermit2ApprovalTx: () => createPermit2ApprovalTx,
  eip3009ABI: () => eip3009ABI,
  erc20AllowanceAbi: () => erc20AllowanceAbi,
  getPermit2AllowanceReadParams: () => getPermit2AllowanceReadParams,
  isEIP3009Payload: () => isEIP3009Payload,
  isPermit2Payload: () => isPermit2Payload,
  permit2WitnessTypes: () => permit2WitnessTypes,
  toClientEvmSigner: () => toClientEvmSigner,
  toFacilitatorEvmSigner: () => toFacilitatorEvmSigner,
  x402ExactPermit2ProxyABI: () => x402ExactPermit2ProxyABI,
  x402ExactPermit2ProxyAddress: () => x402ExactPermit2ProxyAddress,
  x402UptoPermit2ProxyAddress: () => x402UptoPermit2ProxyAddress
});
module.exports = __toCommonJS(src_exports);

// src/exact/client/eip3009.ts
var import_viem4 = require("viem");

// src/constants.ts
var authorizationTypes = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};
var permit2WitnessTypes = {
  PermitWitnessTransferFrom: [
    { name: "permitted", type: "TokenPermissions" },
    { name: "spender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "witness", type: "Witness" }
  ],
  TokenPermissions: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  Witness: [
    { name: "to", type: "address" },
    { name: "validAfter", type: "uint256" },
    { name: "extra", type: "bytes" }
  ]
};
var eip3009ABI = [
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" },
      { name: "v", type: "uint8" },
      { name: "r", type: "bytes32" },
      { name: "s", type: "bytes32" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" },
      { name: "signature", type: "bytes" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];
var PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
var x402ExactPermit2ProxyAddress = "0x4020615294c913F045dc10f0a5cdEbd86c280001";
var x402UptoPermit2ProxyAddress = "0x4020633461b2895a48930Ff97eE8fCdE8E520002";
var x402ExactPermit2ProxyABI = [
  {
    type: "function",
    name: "PERMIT2",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "contract ISignatureTransfer" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "WITNESS_TYPEHASH",
    inputs: [],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "WITNESS_TYPE_STRING",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [{ name: "_permit2", type: "address", internalType: "address" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "settle",
    inputs: [
      {
        name: "permit",
        type: "tuple",
        internalType: "struct ISignatureTransfer.PermitTransferFrom",
        components: [
          {
            name: "permitted",
            type: "tuple",
            internalType: "struct ISignatureTransfer.TokenPermissions",
            components: [
              { name: "token", type: "address", internalType: "address" },
              { name: "amount", type: "uint256", internalType: "uint256" }
            ]
          },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" }
        ]
      },
      { name: "owner", type: "address", internalType: "address" },
      {
        name: "witness",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.Witness",
        components: [
          { name: "to", type: "address", internalType: "address" },
          { name: "validAfter", type: "uint256", internalType: "uint256" },
          { name: "extra", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "settleWithPermit",
    inputs: [
      {
        name: "permit2612",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.EIP2612Permit",
        components: [
          { name: "value", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" },
          { name: "r", type: "bytes32", internalType: "bytes32" },
          { name: "s", type: "bytes32", internalType: "bytes32" },
          { name: "v", type: "uint8", internalType: "uint8" }
        ]
      },
      {
        name: "permit",
        type: "tuple",
        internalType: "struct ISignatureTransfer.PermitTransferFrom",
        components: [
          {
            name: "permitted",
            type: "tuple",
            internalType: "struct ISignatureTransfer.TokenPermissions",
            components: [
              { name: "token", type: "address", internalType: "address" },
              { name: "amount", type: "uint256", internalType: "uint256" }
            ]
          },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "deadline", type: "uint256", internalType: "uint256" }
        ]
      },
      { name: "owner", type: "address", internalType: "address" },
      {
        name: "witness",
        type: "tuple",
        internalType: "struct x402BasePermit2Proxy.Witness",
        components: [
          { name: "to", type: "address", internalType: "address" },
          { name: "validAfter", type: "uint256", internalType: "uint256" },
          { name: "extra", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  { type: "event", name: "Settled", inputs: [], anonymous: false },
  { type: "event", name: "SettledWithPermit", inputs: [], anonymous: false },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidDestination", inputs: [] },
  { type: "error", name: "InvalidOwner", inputs: [] },
  { type: "error", name: "InvalidPermit2Address", inputs: [] },
  { type: "error", name: "PaymentTooEarly", inputs: [] },
  { type: "error", name: "ReentrancyGuardReentrantCall", inputs: [] }
];

// src/utils.ts
var import_viem3 = require("viem");

// src/exact/v1/client/scheme.ts
var import_viem = require("viem");

// src/exact/v1/facilitator/scheme.ts
var import_viem2 = require("viem");

// src/v1/index.ts
var EVM_NETWORK_CHAIN_ID_MAP = {
  ethereum: 1,
  sepolia: 11155111,
  abstract: 2741,
  "abstract-testnet": 11124,
  "base-sepolia": 84532,
  base: 8453,
  "avalanche-fuji": 43113,
  avalanche: 43114,
  iotex: 4689,
  sei: 1329,
  "sei-testnet": 1328,
  polygon: 137,
  "polygon-amoy": 80002,
  peaq: 3338,
  story: 1514,
  educhain: 41923,
  "skale-base-sepolia": 324705682
};
var NETWORKS = Object.keys(EVM_NETWORK_CHAIN_ID_MAP);

// src/utils.ts
function getCrypto() {
  const cryptoObj = globalThis.crypto;
  if (!cryptoObj) {
    throw new Error("Crypto API not available");
  }
  return cryptoObj;
}
function createNonce() {
  return (0, import_viem3.toHex)(getCrypto().getRandomValues(new Uint8Array(32)));
}
function createPermit2Nonce() {
  const randomBytes = getCrypto().getRandomValues(new Uint8Array(32));
  return BigInt((0, import_viem3.toHex)(randomBytes)).toString();
}

// src/exact/client/eip3009.ts
async function createEIP3009Payload(signer, x402Version, paymentRequirements) {
  const nonce = createNonce();
  const now = Math.floor(Date.now() / 1e3);
  const authorization = {
    from: signer.address,
    to: (0, import_viem4.getAddress)(paymentRequirements.payTo),
    value: paymentRequirements.amount,
    validAfter: (now - 600).toString(),
    validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),
    nonce
  };
  const signature = await signEIP3009Authorization(signer, authorization, paymentRequirements);
  const payload = {
    authorization,
    signature
  };
  return {
    x402Version,
    payload
  };
}
async function signEIP3009Authorization(signer, authorization, requirements) {
  const chainId = parseInt(requirements.network.split(":")[1]);
  if (!requirements.extra?.name || !requirements.extra?.version) {
    throw new Error(
      `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`
    );
  }
  const { name, version } = requirements.extra;
  const domain = {
    name,
    version,
    chainId,
    verifyingContract: (0, import_viem4.getAddress)(requirements.asset)
  };
  const message = {
    from: (0, import_viem4.getAddress)(authorization.from),
    to: (0, import_viem4.getAddress)(authorization.to),
    value: BigInt(authorization.value),
    validAfter: BigInt(authorization.validAfter),
    validBefore: BigInt(authorization.validBefore),
    nonce: authorization.nonce
  };
  return await signer.signTypedData({
    domain,
    types: authorizationTypes,
    primaryType: "TransferWithAuthorization",
    message
  });
}

// src/exact/client/permit2.ts
var import_viem5 = require("viem");
var MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
async function createPermit2Payload(signer, x402Version, paymentRequirements) {
  const now = Math.floor(Date.now() / 1e3);
  const nonce = createPermit2Nonce();
  const validAfter = (now - 600).toString();
  const deadline = (now + paymentRequirements.maxTimeoutSeconds).toString();
  const permit2Authorization = {
    from: signer.address,
    permitted: {
      token: (0, import_viem5.getAddress)(paymentRequirements.asset),
      amount: paymentRequirements.amount
    },
    spender: x402ExactPermit2ProxyAddress,
    nonce,
    deadline,
    witness: {
      to: (0, import_viem5.getAddress)(paymentRequirements.payTo),
      validAfter,
      extra: "0x"
    }
  };
  const signature = await signPermit2Authorization(
    signer,
    permit2Authorization,
    paymentRequirements
  );
  const payload = {
    signature,
    permit2Authorization
  };
  return {
    x402Version,
    payload
  };
}
async function signPermit2Authorization(signer, permit2Authorization, requirements) {
  const chainId = parseInt(requirements.network.split(":")[1]);
  const domain = {
    name: "Permit2",
    chainId,
    verifyingContract: PERMIT2_ADDRESS
  };
  const message = {
    permitted: {
      token: (0, import_viem5.getAddress)(permit2Authorization.permitted.token),
      amount: BigInt(permit2Authorization.permitted.amount)
    },
    spender: (0, import_viem5.getAddress)(permit2Authorization.spender),
    nonce: BigInt(permit2Authorization.nonce),
    deadline: BigInt(permit2Authorization.deadline),
    witness: {
      to: (0, import_viem5.getAddress)(permit2Authorization.witness.to),
      validAfter: BigInt(permit2Authorization.witness.validAfter),
      extra: permit2Authorization.witness.extra
    }
  };
  return await signer.signTypedData({
    domain,
    types: permit2WitnessTypes,
    primaryType: "PermitWitnessTransferFrom",
    message
  });
}
var erc20ApproveAbi = [
  {
    type: "function",
    name: "approve",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ type: "bool" }],
    stateMutability: "nonpayable"
  }
];
var erc20AllowanceAbi = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" }
    ],
    outputs: [{ type: "uint256" }],
    stateMutability: "view"
  }
];
function createPermit2ApprovalTx(tokenAddress) {
  const data = (0, import_viem5.encodeFunctionData)({
    abi: erc20ApproveAbi,
    functionName: "approve",
    args: [PERMIT2_ADDRESS, MAX_UINT256]
  });
  return {
    to: (0, import_viem5.getAddress)(tokenAddress),
    data
  };
}
function getPermit2AllowanceReadParams(params) {
  return {
    address: (0, import_viem5.getAddress)(params.tokenAddress),
    abi: erc20AllowanceAbi,
    functionName: "allowance",
    args: [(0, import_viem5.getAddress)(params.ownerAddress), PERMIT2_ADDRESS]
  };
}

// src/exact/client/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmClient instance.
   *
   * @param signer - The EVM signer for client operations
   */
  constructor(signer) {
    this.signer = signer;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   * Routes to EIP-3009 or Permit2 based on requirements.extra.assetTransferMethod.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload result
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const assetTransferMethod = paymentRequirements.extra?.assetTransferMethod ?? "eip3009";
    if (assetTransferMethod === "permit2") {
      return createPermit2Payload(this.signer, x402Version, paymentRequirements);
    }
    return createEIP3009Payload(this.signer, x402Version, paymentRequirements);
  }
};

// src/signer.ts
function toClientEvmSigner(signer) {
  return signer;
}
function toFacilitatorEvmSigner(client) {
  return {
    ...client,
    getAddresses: () => [client.address]
  };
}

// src/types.ts
function isPermit2Payload(payload) {
  return "permit2Authorization" in payload;
}
function isEIP3009Payload(payload) {
  return "authorization" in payload;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExactEvmScheme,
  PERMIT2_ADDRESS,
  authorizationTypes,
  createPermit2ApprovalTx,
  eip3009ABI,
  erc20AllowanceAbi,
  getPermit2AllowanceReadParams,
  isEIP3009Payload,
  isPermit2Payload,
  permit2WitnessTypes,
  toClientEvmSigner,
  toFacilitatorEvmSigner,
  x402ExactPermit2ProxyABI,
  x402ExactPermit2ProxyAddress,
  x402UptoPermit2ProxyAddress
});
//# sourceMappingURL=index.js.map