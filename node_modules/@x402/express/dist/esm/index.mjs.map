{"version":3,"sources":["../../src/index.ts","../../src/adapter.ts"],"sourcesContent":["import {\n  HTTPRequestContext,\n  PaywallConfig,\n  PaywallProvider,\n  x402HTTPResourceServer,\n  x402ResourceServer,\n  RoutesConfig,\n  FacilitatorClient,\n} from \"@x402/core/server\";\nimport { SchemeNetworkServer, Network } from \"@x402/core/types\";\nimport { NextFunction, Request, Response } from \"express\";\nimport { ExpressAdapter } from \"./adapter\";\n\n/**\n * Check if any routes in the configuration declare bazaar extensions\n *\n * @param routes - Route configuration\n * @returns True if any route has extensions.bazaar defined\n */\nfunction checkIfBazaarNeeded(routes: RoutesConfig): boolean {\n  // Handle single route config\n  if (\"accepts\" in routes) {\n    return !!(routes.extensions && \"bazaar\" in routes.extensions);\n  }\n\n  // Handle multiple routes\n  return Object.values(routes).some(routeConfig => {\n    return !!(routeConfig.extensions && \"bazaar\" in routeConfig.extensions);\n  });\n}\n\n/**\n * Configuration for registering a payment scheme with a specific network\n */\nexport interface SchemeRegistration {\n  /**\n   * The network identifier (e.g., 'eip155:84532', 'solana:mainnet')\n   */\n  network: Network;\n\n  /**\n   * The scheme server implementation for this network\n   */\n  server: SchemeNetworkServer;\n}\n\n/**\n * Express payment middleware for x402 protocol (direct HTTP server instance).\n *\n * Use this when you need to configure HTTP-level hooks.\n *\n * @param httpServer - Pre-configured x402HTTPResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Express middleware handler\n *\n * @example\n * ```typescript\n * import { paymentMiddlewareFromHTTPServer, x402ResourceServer, x402HTTPResourceServer } from \"@x402/express\";\n *\n * const resourceServer = new x402ResourceServer(facilitatorClient)\n *   .register(NETWORK, new ExactEvmScheme())\n *\n * const httpServer = new x402HTTPResourceServer(resourceServer, routes)\n *   .onProtectedRequest(requestHook);\n *\n * app.use(paymentMiddlewareFromHTTPServer(httpServer));\n * ```\n */\nexport function paymentMiddlewareFromHTTPServer(\n  httpServer: x402HTTPResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  // Register custom paywall provider if provided\n  if (paywall) {\n    httpServer.registerPaywallProvider(paywall);\n  }\n\n  // Store initialization promise (not the result)\n  // httpServer.initialize() fetches facilitator support and validates routes\n  let initPromise: Promise<void> | null = syncFacilitatorOnStart ? httpServer.initialize() : null;\n\n  // Dynamically register bazaar extension if routes declare it and not already registered\n  // Skip if pre-registered (e.g., in serverless environments where static imports are used)\n  let bazaarPromise: Promise<void> | null = null;\n  if (checkIfBazaarNeeded(httpServer.routes) && !httpServer.server.hasExtension(\"bazaar\")) {\n    bazaarPromise = import(\"@x402/extensions/bazaar\")\n      .then(({ bazaarResourceServerExtension }) => {\n        httpServer.server.registerExtension(bazaarResourceServerExtension);\n      })\n      .catch(err => {\n        console.error(\"Failed to load bazaar extension:\", err);\n      });\n  }\n\n  return async (req: Request, res: Response, next: NextFunction) => {\n    // Create adapter and context\n    const adapter = new ExpressAdapter(req);\n    const context: HTTPRequestContext = {\n      adapter,\n      path: req.path,\n      method: req.method,\n      paymentHeader: adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"x-payment\"),\n    };\n\n    // Check if route requires payment before initializing facilitator\n    if (!httpServer.requiresPayment(context)) {\n      return next();\n    }\n\n    // Only initialize when processing a protected route\n    if (initPromise) {\n      await initPromise;\n      initPromise = null; // Clear after first await\n    }\n\n    // Await bazaar extension loading if needed\n    if (bazaarPromise) {\n      await bazaarPromise;\n      bazaarPromise = null;\n    }\n\n    // Process payment requirement check\n    const result = await httpServer.processHTTPRequest(context, paywallConfig);\n\n    // Handle the different result types\n    switch (result.type) {\n      case \"no-payment-required\":\n        // No payment needed, proceed directly to the route handler\n        return next();\n\n      case \"payment-error\":\n        // Payment required but not provided or invalid\n        const { response } = result;\n        res.status(response.status);\n        Object.entries(response.headers).forEach(([key, value]) => {\n          res.setHeader(key, value);\n        });\n        if (response.isHtml) {\n          res.send(response.body);\n        } else {\n          res.json(response.body || {});\n        }\n        return;\n\n      case \"payment-verified\":\n        // Payment is valid, need to wrap response for settlement\n        const { paymentPayload, paymentRequirements, declaredExtensions } = result;\n\n        // Intercept and buffer all core methods that can commit response to client\n        const originalWriteHead = res.writeHead.bind(res);\n        const originalWrite = res.write.bind(res);\n        const originalEnd = res.end.bind(res);\n        const originalFlushHeaders = res.flushHeaders.bind(res);\n\n        type BufferedCall =\n          | [\"writeHead\", Parameters<typeof originalWriteHead>]\n          | [\"write\", Parameters<typeof originalWrite>]\n          | [\"end\", Parameters<typeof originalEnd>]\n          | [\"flushHeaders\", []];\n        let bufferedCalls: BufferedCall[] = [];\n        let settled = false;\n\n        // Create a promise that resolves when the handler finishes and calls res.end()\n        let endCalled: () => void;\n        const endPromise = new Promise<void>(resolve => {\n          endCalled = resolve;\n        });\n\n        res.writeHead = function (...args: Parameters<typeof originalWriteHead>) {\n          if (!settled) {\n            bufferedCalls.push([\"writeHead\", args]);\n            return res;\n          }\n          return originalWriteHead(...args);\n        } as typeof originalWriteHead;\n\n        res.write = function (...args: Parameters<typeof originalWrite>) {\n          if (!settled) {\n            bufferedCalls.push([\"write\", args]);\n            return true;\n          }\n          return originalWrite(...args);\n        } as typeof originalWrite;\n\n        res.end = function (...args: Parameters<typeof originalEnd>) {\n          if (!settled) {\n            bufferedCalls.push([\"end\", args]);\n            // Signal that the handler has finished\n            endCalled();\n            return res;\n          }\n          return originalEnd(...args);\n        } as typeof originalEnd;\n\n        res.flushHeaders = function () {\n          if (!settled) {\n            bufferedCalls.push([\"flushHeaders\", []]);\n            return;\n          }\n          return originalFlushHeaders();\n        };\n\n        // Proceed to the next middleware or route handler\n        next();\n\n        // Wait for the handler to actually call res.end() before checking status\n        await endPromise;\n\n        // If the response from the protected route is >= 400, do not settle payment\n        if (res.statusCode >= 400) {\n          settled = true;\n          res.writeHead = originalWriteHead;\n          res.write = originalWrite;\n          res.end = originalEnd;\n          res.flushHeaders = originalFlushHeaders;\n          // Replay all buffered calls in order\n          for (const [method, args] of bufferedCalls) {\n            if (method === \"writeHead\")\n              originalWriteHead(...(args as Parameters<typeof originalWriteHead>));\n            else if (method === \"write\")\n              originalWrite(...(args as Parameters<typeof originalWrite>));\n            else if (method === \"end\") originalEnd(...(args as Parameters<typeof originalEnd>));\n            else if (method === \"flushHeaders\") originalFlushHeaders();\n          }\n          bufferedCalls = [];\n          return;\n        }\n\n        try {\n          const settleResult = await httpServer.processSettlement(\n            paymentPayload,\n            paymentRequirements,\n            declaredExtensions,\n          );\n\n          // If settlement fails, return an error and do not send the buffered response\n          if (!settleResult.success) {\n            bufferedCalls = [];\n            res.status(402).json({\n              error: \"Settlement failed\",\n              details: settleResult.errorReason,\n            });\n            return;\n          }\n\n          // Settlement succeeded - add headers to response\n          Object.entries(settleResult.headers).forEach(([key, value]) => {\n            res.setHeader(key, value);\n          });\n        } catch (error) {\n          console.error(error);\n          // If settlement fails, don't send the buffered response\n          bufferedCalls = [];\n          res.status(402).json({\n            error: \"Settlement failed\",\n            details: error instanceof Error ? error.message : \"Unknown error\",\n          });\n          return;\n        } finally {\n          settled = true;\n          res.writeHead = originalWriteHead;\n          res.write = originalWrite;\n          res.end = originalEnd;\n          res.flushHeaders = originalFlushHeaders;\n\n          // Replay all buffered calls in order\n          for (const [method, args] of bufferedCalls) {\n            if (method === \"writeHead\")\n              originalWriteHead(...(args as Parameters<typeof originalWriteHead>));\n            else if (method === \"write\")\n              originalWrite(...(args as Parameters<typeof originalWrite>));\n            else if (method === \"end\") originalEnd(...(args as Parameters<typeof originalEnd>));\n            else if (method === \"flushHeaders\") originalFlushHeaders();\n          }\n          bufferedCalls = [];\n        }\n        return;\n    }\n  };\n}\n\n/**\n * Express payment middleware for x402 protocol (direct server instance).\n *\n * Use this when you want to pass a pre-configured x402ResourceServer instance.\n * This provides more flexibility for testing, custom configuration, and reusing\n * server instances across multiple middlewares.\n *\n * @param routes - Route configurations for protected endpoints\n * @param server - Pre-configured x402ResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Express middleware handler\n *\n * @example\n * ```typescript\n * import { paymentMiddleware } from \"@x402/express\";\n *\n * const server = new x402ResourceServer(myFacilitatorClient)\n *   .register(NETWORK, new ExactEvmScheme());\n *\n * app.use(paymentMiddleware(routes, server, paywallConfig));\n * ```\n */\nexport function paymentMiddleware(\n  routes: RoutesConfig,\n  server: x402ResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  // Create the x402 HTTP server instance with the resource server\n  const httpServer = new x402HTTPResourceServer(server, routes);\n\n  return paymentMiddlewareFromHTTPServer(\n    httpServer,\n    paywallConfig,\n    paywall,\n    syncFacilitatorOnStart,\n  );\n}\n\n/**\n * Express payment middleware for x402 protocol (configuration-based).\n *\n * Use this when you want to quickly set up middleware with simple configuration.\n * This function creates and configures the x402ResourceServer internally.\n *\n * @param routes - Route configurations for protected endpoints\n * @param facilitatorClients - Optional facilitator client(s) for payment processing\n * @param schemes - Optional array of scheme registrations for server-side payment processing\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Express middleware handler\n *\n * @example\n * ```typescript\n * import { paymentMiddlewareFromConfig } from \"@x402/express\";\n *\n * app.use(paymentMiddlewareFromConfig(\n *   routes,\n *   myFacilitatorClient,\n *   [{ network: \"eip155:8453\", server: evmSchemeServer }],\n *   paywallConfig\n * ));\n * ```\n */\nexport function paymentMiddlewareFromConfig(\n  routes: RoutesConfig,\n  facilitatorClients?: FacilitatorClient | FacilitatorClient[],\n  schemes?: SchemeRegistration[],\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  const ResourceServer = new x402ResourceServer(facilitatorClients);\n\n  if (schemes) {\n    schemes.forEach(({ network, server: schemeServer }) => {\n      ResourceServer.register(network, schemeServer);\n    });\n  }\n\n  // Use the direct paymentMiddleware with the configured server\n  // Note: paymentMiddleware handles dynamic bazaar registration\n  return paymentMiddleware(routes, ResourceServer, paywallConfig, paywall, syncFacilitatorOnStart);\n}\n\nexport { x402ResourceServer, x402HTTPResourceServer } from \"@x402/core/server\";\n\nexport type {\n  PaymentRequired,\n  PaymentRequirements,\n  PaymentPayload,\n  Network,\n  SchemeNetworkServer,\n} from \"@x402/core/types\";\n\nexport type { PaywallProvider, PaywallConfig } from \"@x402/core/server\";\n\nexport { RouteConfigurationError } from \"@x402/core/server\";\n\nexport type { RouteValidationError } from \"@x402/core/server\";\n\nexport { ExpressAdapter } from \"./adapter\";\n","import { HTTPAdapter } from \"@x402/core/server\";\nimport { Request } from \"express\";\n\n/**\n * Express adapter implementation\n */\nexport class ExpressAdapter implements HTTPAdapter {\n  /**\n   * Creates a new ExpressAdapter instance.\n   *\n   * @param req - The Express request object\n   */\n  constructor(private req: Request) {}\n\n  /**\n   * Gets a header value from the request.\n   *\n   * @param name - The header name\n   * @returns The header value or undefined\n   */\n  getHeader(name: string): string | undefined {\n    const value = this.req.header(name);\n    return Array.isArray(value) ? value[0] : value;\n  }\n\n  /**\n   * Gets the HTTP method of the request.\n   *\n   * @returns The HTTP method\n   */\n  getMethod(): string {\n    return this.req.method;\n  }\n\n  /**\n   * Gets the path of the request.\n   *\n   * @returns The request path\n   */\n  getPath(): string {\n    return this.req.path;\n  }\n\n  /**\n   * Gets the full URL of the request.\n   *\n   * @returns The full request URL\n   */\n  getUrl(): string {\n    return `${this.req.protocol}://${this.req.headers.host}${this.req.originalUrl}`;\n  }\n\n  /**\n   * Gets the Accept header from the request.\n   *\n   * @returns The Accept header value or empty string\n   */\n  getAcceptHeader(): string {\n    return this.req.header(\"Accept\") || \"\";\n  }\n\n  /**\n   * Gets the User-Agent header from the request.\n   *\n   * @returns The User-Agent header value or empty string\n   */\n  getUserAgent(): string {\n    return this.req.header(\"User-Agent\") || \"\";\n  }\n\n  /**\n   * Gets all query parameters from the request URL.\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams(): Record<string, string | string[]> {\n    return this.req.query as Record<string, string | string[]>;\n  }\n\n  /**\n   * Gets a specific query parameter by name.\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam(name: string): string | string[] | undefined {\n    const value = this.req.query[name];\n    return value as string | string[] | undefined;\n  }\n\n  /**\n   * Gets the parsed request body.\n   * Requires express.json() or express.urlencoded() middleware.\n   *\n   * @returns The parsed request body\n   */\n  getBody(): unknown {\n    return this.req.body;\n  }\n}\n"],"mappings":"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","names":["x402ResourceServer","x402HTTPResourceServer"]}