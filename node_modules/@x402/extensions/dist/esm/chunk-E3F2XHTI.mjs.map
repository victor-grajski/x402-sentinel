{"version":3,"sources":["../../src/sign-in-with-x/types.ts","../../src/sign-in-with-x/solana.ts","../../src/sign-in-with-x/schema.ts","../../src/sign-in-with-x/declare.ts","../../src/sign-in-with-x/server.ts","../../src/sign-in-with-x/parse.ts","../../src/sign-in-with-x/validate.ts","../../src/sign-in-with-x/evm.ts","../../src/sign-in-with-x/verify.ts","../../src/sign-in-with-x/message.ts","../../src/sign-in-with-x/sign.ts","../../src/sign-in-with-x/client.ts","../../src/sign-in-with-x/encode.ts","../../src/sign-in-with-x/fetch.ts","../../src/sign-in-with-x/storage.ts","../../src/sign-in-with-x/hooks.ts"],"sourcesContent":["/**\n * Type definitions for the Sign-In-With-X (SIWX) extension\n *\n * Implements CAIP-122 standard for chain-agnostic wallet-based identity assertions.\n * Per x402 v2 spec: typescript/site/CHANGELOG-v2.md lines 237-341\n */\n\nimport { z } from \"zod\";\n\n/**\n * Extension identifier constant\n */\nexport const SIGN_IN_WITH_X = \"sign-in-with-x\";\n\n/**\n * Supported signature schemes per CHANGELOG-v2.md line 271.\n *\n * NOTE: This is primarily informational. Actual signature verification\n * is determined by the chainId prefix, not this field:\n * - `eip155:*` chains use EVM verification (handles eip191, eip712, eip1271, eip6492 automatically)\n * - `solana:*` chains use Ed25519 verification (siws)\n *\n * The signatureScheme field serves as a hint for clients to select\n * the appropriate signing UX.\n */\nexport type SignatureScheme =\n  | \"eip191\" // personal_sign (default for EVM EOAs)\n  | \"eip1271\" // smart contract wallet verification\n  | \"eip6492\" // counterfactual smart wallet verification\n  | \"siws\"; // Sign-In-With-Solana\n\n/** Signature algorithm type per CAIP-122 */\nexport type SignatureType = \"eip191\" | \"ed25519\";\n\n/**\n * Supported chain configuration in supportedChains array.\n * Specifies which chains the server accepts for authentication.\n */\nexport interface SupportedChain {\n  /** CAIP-2 chain identifier (e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\") */\n  chainId: string;\n  /** Signature algorithm type per CAIP-122 */\n  type: SignatureType;\n  /** Optional signature scheme hint (informational) */\n  signatureScheme?: SignatureScheme;\n}\n\n/**\n * Server-declared extension info included in PaymentRequired.extensions.\n * Contains message metadata shared across all supported chains.\n * Per CHANGELOG-v2.md lines 263-272\n */\nexport interface SIWxExtensionInfo {\n  /** Server's domain */\n  domain: string;\n  /** Full resource URI */\n  uri: string;\n  /** Human-readable purpose for signing */\n  statement?: string;\n  /** CAIP-122 version, always \"1\" */\n  version: string;\n  /** Cryptographic nonce (SDK auto-generates) */\n  nonce: string;\n  /** ISO 8601 timestamp (SDK auto-generates) */\n  issuedAt: string;\n  /** Optional expiry (default: +5 min) */\n  expirationTime?: string;\n  /** Optional validity start */\n  notBefore?: string;\n  /** Optional correlation ID */\n  requestId?: string;\n  /** Associated resources */\n  resources?: string[];\n}\n\n/**\n * JSON Schema for SIWX extension validation\n * Per CHANGELOG-v2.md lines 276-292\n */\nexport interface SIWxExtensionSchema {\n  $schema: string;\n  type: \"object\";\n  properties: {\n    domain: { type: \"string\" };\n    address: { type: \"string\" };\n    statement?: { type: \"string\" };\n    uri: { type: \"string\"; format: \"uri\" };\n    version: { type: \"string\" };\n    chainId: { type: \"string\" };\n    type: { type: \"string\" };\n    nonce: { type: \"string\" };\n    issuedAt: { type: \"string\"; format: \"date-time\" };\n    expirationTime?: { type: \"string\"; format: \"date-time\" };\n    notBefore?: { type: \"string\"; format: \"date-time\" };\n    requestId?: { type: \"string\" };\n    resources?: { type: \"array\"; items: { type: \"string\"; format: \"uri\" } };\n    signature: { type: \"string\" };\n  };\n  required: string[];\n}\n\n/**\n * Complete SIWX extension structure (info + supportedChains + schema).\n * Follows standard x402 v2 extension pattern with multi-chain support.\n */\nexport interface SIWxExtension {\n  info: SIWxExtensionInfo;\n  supportedChains: SupportedChain[];\n  schema: SIWxExtensionSchema;\n}\n\n/**\n * Zod schema for SIWX payload validation\n * Client proof payload sent in SIGN-IN-WITH-X header\n * Per CHANGELOG-v2.md lines 301-315\n */\nexport const SIWxPayloadSchema = z.object({\n  domain: z.string(),\n  address: z.string(),\n  statement: z.string().optional(),\n  uri: z.string(),\n  version: z.string(),\n  chainId: z.string(),\n  type: z.enum([\"eip191\", \"ed25519\"]),\n  nonce: z.string(),\n  issuedAt: z.string(),\n  expirationTime: z.string().optional(),\n  notBefore: z.string().optional(),\n  requestId: z.string().optional(),\n  resources: z.array(z.string()).optional(),\n  signatureScheme: z.enum([\"eip191\", \"eip1271\", \"eip6492\", \"siws\"]).optional(),\n  signature: z.string(),\n});\n\n/**\n * Client proof payload type (inferred from zod schema)\n */\nexport type SIWxPayload = z.infer<typeof SIWxPayloadSchema>;\n\n/**\n * Options for declaring SIWX extension on server.\n *\n * Most fields are optional and derived automatically from request context:\n * - `domain`: Parsed from resourceUri or request URL\n * - `resourceUri`: From request URL\n * - `network`: From payment requirements (accepts[].network)\n *\n * Explicit values override automatic derivation.\n */\nexport interface DeclareSIWxOptions {\n  /** Server's domain. If omitted, derived from resourceUri or request URL. */\n  domain?: string;\n  /** Full resource URI. If omitted, derived from request URL. */\n  resourceUri?: string;\n  /** Human-readable purpose */\n  statement?: string;\n  /** CAIP-122 version (default: \"1\") */\n  version?: string;\n  /**\n   * Network(s) to support. If omitted, derived from payment requirements.\n   * - Single chain: \"eip155:8453\" or \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"\n   * - Multi-chain: [\"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"]\n   */\n  network?: string | string[];\n  /**\n   * Optional expiration duration in seconds.\n   * - Number (e.g., 300): Signature expires after this many seconds\n   * - undefined: Infinite expiration (no expirationTime field in wire format)\n   */\n  expirationSeconds?: number;\n}\n\n/**\n * Validation result from validateSIWxMessage\n */\nexport interface SIWxValidationResult {\n  valid: boolean;\n  error?: string;\n}\n\n/**\n * Options for message validation\n */\nexport interface SIWxValidationOptions {\n  /** Maximum age for issuedAt in milliseconds (default: 5 minutes) */\n  maxAge?: number;\n  /** Custom nonce validation function */\n  checkNonce?: (nonce: string) => boolean | Promise<boolean>;\n}\n\n/**\n * Result from signature verification\n */\nexport interface SIWxVerifyResult {\n  valid: boolean;\n  /** Recovered/verified address (checksummed) */\n  address?: string;\n  error?: string;\n}\n\n/**\n * EVM message verifier function type.\n * Compatible with viem's publicClient.verifyMessage().\n *\n * When provided to verifySIWxSignature, enables:\n * - EIP-1271 (deployed smart contract wallets)\n * - EIP-6492 (counterfactual/pre-deploy smart wallets)\n *\n * Without a verifier, only EOA signatures (EIP-191) can be verified.\n *\n * @example\n * ```typescript\n * import { createPublicClient, http } from 'viem';\n * import { base } from 'viem/chains';\n *\n * const publicClient = createPublicClient({ chain: base, transport: http() });\n * // publicClient.verifyMessage satisfies EVMMessageVerifier\n * ```\n */\nexport type EVMMessageVerifier = (args: {\n  address: `0x${string}`;\n  message: string;\n  signature: `0x${string}`;\n}) => Promise<boolean>;\n\n/**\n * Options for SIWX signature verification\n */\nexport interface SIWxVerifyOptions {\n  /**\n   * EVM message verifier for smart wallet support.\n   *\n   * Pass `publicClient.verifyMessage` from viem to enable verification of:\n   * - Smart contract wallets (EIP-1271)\n   * - Counterfactual/undeployed smart wallets (EIP-6492)\n   *\n   * If not provided, only EOA signatures are verified using standalone\n   * ECDSA recovery (no RPC calls required).\n   */\n  evmVerifier?: EVMMessageVerifier;\n}\n","/**\n * Solana Sign-In-With-X (SIWS) support\n *\n * Implements CAIP-122 compliant message format and Ed25519 signature verification\n * for Solana wallets.\n */\n\nimport { base58 } from \"@scure/base\";\nimport nacl from \"tweetnacl\";\nimport type { CompleteSIWxInfo } from \"./client\";\n\n/**\n * Common Solana network CAIP-2 identifiers.\n * Uses genesis hash as the chain reference per CAIP-30.\n */\nexport const SOLANA_MAINNET = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\nexport const SOLANA_DEVNET = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\nexport const SOLANA_TESTNET = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n\n/**\n * Extract chain reference from CAIP-2 Solana chainId.\n *\n * @param chainId - CAIP-2 format chain ID (e.g., \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\")\n * @returns Chain reference (genesis hash)\n *\n * @example\n * ```typescript\n * extractSolanaChainReference(\"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\") // \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"\n * ```\n */\nexport function extractSolanaChainReference(chainId: string): string {\n  const [, reference] = chainId.split(\":\");\n  return reference;\n}\n\n/**\n * Format SIWS message following CAIP-122 ABNF specification.\n *\n * The message format is identical to SIWE (EIP-4361) but uses \"Solana account\"\n * instead of \"Ethereum account\" in the header line.\n *\n * @param info - Server-provided extension info\n * @param address - Client's Solana wallet address (Base58 encoded public key)\n * @returns Message string ready for signing\n *\n * @example\n * ```typescript\n * const message = formatSIWSMessage(serverInfo, \"BSmWDgE9ex6dZYbiTsJGcwMEgFp8q4aWh92hdErQPeVW\");\n * // Returns:\n * // \"api.example.com wants you to sign in with your Solana account:\n * // BSmWDgE9ex6dZYbiTsJGcwMEgFp8q4aWh92hdErQPeVW\n * //\n * // Sign in to access your content\n * //\n * // URI: https://api.example.com/data\n * // Version: 1\n * // Chain ID: mainnet\n * // Nonce: abc123\n * // Issued At: 2024-01-01T00:00:00.000Z\"\n * ```\n */\nexport function formatSIWSMessage(info: CompleteSIWxInfo, address: string): string {\n  const lines: string[] = [\n    `${info.domain} wants you to sign in with your Solana account:`,\n    address,\n    \"\",\n  ];\n\n  // Statement (optional, with blank line after)\n  if (info.statement) {\n    lines.push(info.statement, \"\");\n  }\n\n  // Required fields\n  lines.push(\n    `URI: ${info.uri}`,\n    `Version: ${info.version}`,\n    `Chain ID: ${extractSolanaChainReference(info.chainId)}`,\n    `Nonce: ${info.nonce}`,\n    `Issued At: ${info.issuedAt}`,\n  );\n\n  // Optional fields\n  if (info.expirationTime) {\n    lines.push(`Expiration Time: ${info.expirationTime}`);\n  }\n  if (info.notBefore) {\n    lines.push(`Not Before: ${info.notBefore}`);\n  }\n  if (info.requestId) {\n    lines.push(`Request ID: ${info.requestId}`);\n  }\n\n  // Resources (optional)\n  if (info.resources && info.resources.length > 0) {\n    lines.push(\"Resources:\");\n    for (const resource of info.resources) {\n      lines.push(`- ${resource}`);\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Verify Ed25519 signature for SIWS.\n *\n * @param message - The SIWS message that was signed\n * @param signature - Ed25519 signature bytes\n * @param publicKey - Solana public key bytes (32 bytes)\n * @returns true if signature is valid\n *\n * @example\n * ```typescript\n * const messageBytes = new TextEncoder().encode(message);\n * const valid = verifySolanaSignature(message, signatureBytes, publicKeyBytes);\n * ```\n */\nexport function verifySolanaSignature(\n  message: string,\n  signature: Uint8Array,\n  publicKey: Uint8Array,\n): boolean {\n  const messageBytes = new TextEncoder().encode(message);\n  return nacl.sign.detached.verify(messageBytes, signature, publicKey);\n}\n\n/**\n * Decode Base58 string to bytes.\n *\n * Solana uses Base58 encoding (Bitcoin alphabet) for addresses and signatures.\n *\n * @param encoded - Base58 encoded string\n * @returns Decoded bytes\n * @throws Error if string contains invalid Base58 characters\n *\n * @example\n * ```typescript\n * const publicKeyBytes = decodeBase58(\"BSmWDgE9ex6dZYbiTsJGcwMEgFp8q4aWh92hdErQPeVW\");\n * // Returns Uint8Array of 32 bytes\n * ```\n */\nexport function decodeBase58(encoded: string): Uint8Array {\n  return base58.decode(encoded);\n}\n\n/**\n * Encode bytes to Base58 string.\n *\n * @param bytes - Bytes to encode\n * @returns Base58 encoded string\n */\nexport function encodeBase58(bytes: Uint8Array): string {\n  return base58.encode(bytes);\n}\n","/**\n * JSON Schema builder for SIWX extension\n *\n * Per CHANGELOG-v2.md lines 276-292\n */\n\nimport type { SIWxExtensionSchema } from \"./types\";\n\n/**\n * Build JSON Schema for SIWX extension validation.\n * This schema validates the client proof payload structure.\n *\n * @returns JSON Schema for validating SIWX client payloads\n */\nexport function buildSIWxSchema(): SIWxExtensionSchema {\n  return {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\",\n    type: \"object\",\n    properties: {\n      domain: { type: \"string\" },\n      address: { type: \"string\" },\n      statement: { type: \"string\" },\n      uri: { type: \"string\", format: \"uri\" },\n      version: { type: \"string\" },\n      chainId: { type: \"string\" },\n      type: { type: \"string\" },\n      nonce: { type: \"string\" },\n      issuedAt: { type: \"string\", format: \"date-time\" },\n      expirationTime: { type: \"string\", format: \"date-time\" },\n      notBefore: { type: \"string\", format: \"date-time\" },\n      requestId: { type: \"string\" },\n      resources: { type: \"array\", items: { type: \"string\", format: \"uri\" } },\n      signature: { type: \"string\" },\n    },\n    required: [\n      \"domain\",\n      \"address\",\n      \"uri\",\n      \"version\",\n      \"chainId\",\n      \"type\",\n      \"nonce\",\n      \"issuedAt\",\n      \"signature\",\n    ],\n  };\n}\n","/**\n * Server-side declaration helper for SIWX extension\n *\n * Helps servers declare SIWX authentication requirements in PaymentRequired responses.\n */\n\nimport type {\n  SIWxExtension,\n  SIWxExtensionInfo,\n  DeclareSIWxOptions,\n  SignatureType,\n  SupportedChain,\n} from \"./types\";\nimport { SIGN_IN_WITH_X } from \"./types\";\nimport { buildSIWxSchema } from \"./schema\";\n\n/**\n * Derive signature type from network.\n *\n * @param network - CAIP-2 network identifier\n * @returns Signature algorithm type\n */\nexport function getSignatureType(network: string): SignatureType {\n  return network.startsWith(\"solana:\") ? \"ed25519\" : \"eip191\";\n}\n\n/**\n * Internal type for SIWX declaration with stored options.\n * The _options field is used by enrichPaymentRequiredResponse to derive\n * values from request context.\n */\nexport interface SIWxDeclaration extends SIWxExtension {\n  _options: DeclareSIWxOptions;\n}\n\n/**\n * Create SIWX extension declaration for PaymentRequired.extensions\n *\n * Most fields are derived automatically from request context when using\n * siwxResourceServerExtension:\n * - `network`: From payment requirements (accepts[].network)\n * - `resourceUri`: From request URL\n * - `domain`: Parsed from resourceUri\n *\n * Explicit values in options override automatic derivation.\n *\n * @param options - Configuration options (most are optional)\n * @returns Extension object ready for PaymentRequired.extensions\n *\n * @example\n * ```typescript\n * // Minimal - derives network, domain, resourceUri from context\n * const extensions = declareSIWxExtension({\n *   statement: 'Sign in to access your purchased content',\n * });\n *\n * // With explicit network (overrides accepts)\n * const extensions = declareSIWxExtension({\n *   network: 'eip155:8453',\n *   statement: 'Sign in to access',\n * });\n *\n * // Full explicit config (no derivation)\n * const extensions = declareSIWxExtension({\n *   domain: 'api.example.com',\n *   resourceUri: 'https://api.example.com/data',\n *   network: ['eip155:8453', 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'],\n *   statement: 'Sign in to access',\n *   expirationSeconds: 300,\n * });\n * ```\n */\nexport function declareSIWxExtension(\n  options: DeclareSIWxOptions = {},\n): Record<string, SIWxDeclaration> {\n  // Build partial info with static fields only\n  // Time-based fields (nonce, issuedAt, expirationTime) are generated\n  // per-request by enrichPaymentRequiredResponse in siwxResourceServerExtension\n  const info: Partial<SIWxExtensionInfo> & { version: string } = {\n    version: options.version ?? \"1\",\n  };\n\n  // Add fields that are provided\n  if (options.domain) {\n    info.domain = options.domain;\n  }\n  if (options.resourceUri) {\n    info.uri = options.resourceUri;\n    info.resources = [options.resourceUri];\n  }\n  if (options.statement) {\n    info.statement = options.statement;\n  }\n  // Note: expirationSeconds is stored in _options and used by\n  // enrichPaymentRequiredResponse to calculate expirationTime per-request\n\n  // Build supportedChains if network is provided\n  let supportedChains: SupportedChain[] = [];\n  if (options.network) {\n    const networks = Array.isArray(options.network) ? options.network : [options.network];\n    supportedChains = networks.map(network => ({\n      chainId: network,\n      type: getSignatureType(network),\n    }));\n  }\n\n  const declaration: SIWxDeclaration = {\n    info: info as SIWxExtensionInfo,\n    supportedChains,\n    schema: buildSIWxSchema(),\n    _options: options,\n  };\n\n  return { [SIGN_IN_WITH_X]: declaration };\n}\n","/**\n * Server-side ResourceServerExtension for SIWX\n *\n * Provides enrichPaymentRequiredResponse hook to:\n * - Derive missing fields from request context (network, resourceUri, domain)\n * - Refresh time-based fields per request (nonce, issuedAt, expirationTime)\n */\n\nimport { randomBytes } from \"crypto\";\nimport type { ResourceServerExtension, PaymentRequiredContext } from \"@x402/core/types\";\nimport type { SIWxExtension, SIWxExtensionInfo, SupportedChain, DeclareSIWxOptions } from \"./types\";\nimport { SIGN_IN_WITH_X } from \"./types\";\nimport { getSignatureType, type SIWxDeclaration } from \"./declare\";\nimport { buildSIWxSchema } from \"./schema\";\n\n/**\n * SIWX Resource Server Extension.\n *\n * Implements enrichPaymentRequiredResponse hook to:\n * 1. Derive missing fields from context (network from requirements, URL from resourceInfo)\n * 2. Refresh time-based fields (nonce, issuedAt, expirationTime) per request\n *\n * @example\n * ```typescript\n * import { siwxResourceServerExtension } from \"@x402/extensions/sign-in-with-x\";\n *\n * const resourceServer = new x402ResourceServer(facilitator)\n *   .registerExtension(siwxResourceServerExtension)\n *   .onAfterSettle(createSIWxSettleHook({ storage }));\n * ```\n */\nexport const siwxResourceServerExtension: ResourceServerExtension = {\n  key: SIGN_IN_WITH_X,\n\n  enrichPaymentRequiredResponse: async (\n    declaration: unknown,\n    context: PaymentRequiredContext,\n  ): Promise<SIWxExtension> => {\n    const decl = declaration as SIWxDeclaration;\n    const opts: DeclareSIWxOptions = decl._options ?? {};\n\n    // Derive resourceUri from context if not provided\n    const resourceUri = opts.resourceUri ?? context.resourceInfo.url;\n\n    // Derive domain from resourceUri\n    let domain = opts.domain;\n    if (!domain && resourceUri) {\n      try {\n        domain = new URL(resourceUri).hostname;\n      } catch {\n        // If URL parsing fails, leave domain undefined (will cause validation error)\n      }\n    }\n\n    // Derive networks from payment requirements if not provided\n    let networks: string[];\n    if (opts.network) {\n      networks = Array.isArray(opts.network) ? opts.network : [opts.network];\n    } else {\n      // Get unique networks from payment requirements\n      networks = [...new Set(context.requirements.map(r => r.network))];\n    }\n\n    // Generate fresh time-based fields\n    const nonce = randomBytes(16).toString(\"hex\");\n    const issuedAt = new Date().toISOString();\n\n    // Calculate expirationTime based on configured duration\n    const expirationSeconds = opts.expirationSeconds;\n    const expirationTime =\n      expirationSeconds !== undefined\n        ? new Date(Date.now() + expirationSeconds * 1000).toISOString()\n        : undefined;\n\n    // Build complete info\n    const info: SIWxExtensionInfo = {\n      domain: domain ?? \"\",\n      uri: resourceUri,\n      version: opts.version ?? \"1\",\n      nonce,\n      issuedAt,\n      resources: [resourceUri],\n    };\n\n    if (expirationTime) {\n      info.expirationTime = expirationTime;\n    }\n    if (opts.statement) {\n      info.statement = opts.statement;\n    }\n\n    // Build supportedChains from networks\n    const supportedChains: SupportedChain[] = networks.map(network => ({\n      chainId: network,\n      type: getSignatureType(network),\n    }));\n\n    return {\n      info,\n      supportedChains,\n      schema: buildSIWxSchema(),\n    };\n  },\n};\n","/**\n * Header parsing for SIWX extension\n *\n * Parses the SIGN-IN-WITH-X header from client requests.\n * Requires base64-encoded JSON per x402 v2 spec.\n */\n\nimport { Base64EncodedRegex, safeBase64Decode } from \"@x402/core/utils\";\nimport { SIWxPayloadSchema, type SIWxPayload } from \"./types\";\n\n/**\n * Parse SIGN-IN-WITH-X header into structured payload.\n *\n * Expects base64-encoded JSON per x402 v2 spec (CHANGELOG-v2.md line 335).\n *\n * @param header - The SIGN-IN-WITH-X header value (base64-encoded JSON)\n * @returns Parsed SIWX payload\n * @throws Error if header is invalid or missing required fields\n *\n * @example\n * ```typescript\n * const header = request.headers.get('SIGN-IN-WITH-X');\n * if (header) {\n *   const payload = parseSIWxHeader(header);\n *   // payload.address, payload.signature, etc.\n * }\n * ```\n */\nexport function parseSIWxHeader(header: string): SIWxPayload {\n  if (!Base64EncodedRegex.test(header)) {\n    throw new Error(\"Invalid SIWX header: not valid base64\");\n  }\n\n  const jsonStr = safeBase64Decode(header);\n\n  let rawPayload: unknown;\n  try {\n    rawPayload = JSON.parse(jsonStr);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new Error(\"Invalid SIWX header: not valid JSON\");\n    }\n    throw error;\n  }\n\n  const parsed = SIWxPayloadSchema.safeParse(rawPayload);\n\n  if (!parsed.success) {\n    const issues = parsed.error.issues.map(i => `${i.path.join(\".\")}: ${i.message}`).join(\", \");\n    throw new Error(`Invalid SIWX header: ${issues}`);\n  }\n\n  return parsed.data;\n}\n","/**\n * Message validation for SIWX extension\n *\n * Validates SIWX payload fields before cryptographic verification.\n * Per CHANGELOG-v2.md validation rules (lines 318-329).\n */\n\nimport type { SIWxPayload, SIWxValidationResult, SIWxValidationOptions } from \"./types\";\n\n/** Default maximum age for issuedAt: 5 minutes per spec */\nconst DEFAULT_MAX_AGE_MS = 5 * 60 * 1000;\n\n/**\n * Validate SIWX message fields.\n *\n * Performs validation per spec (CHANGELOG-v2.md lines 318-329):\n * - Domain binding: domain MUST match server's domain\n * - URI validation: uri must refer to base url of resource\n * - Temporal validation:\n *   - issuedAt MUST be recent (< 5 minutes by default)\n *   - expirationTime MUST be in the future\n *   - notBefore (if present) MUST be in the past\n * - Nonce: MUST be unique (via optional checkNonce callback)\n *\n * @param message - The SIWX payload to validate\n * @param expectedResourceUri - Expected resource URI (for domain/URI matching)\n * @param options - Validation options\n * @returns Validation result\n *\n * @example\n * ```typescript\n * const payload = parseSIWxHeader(header);\n * const result = await validateSIWxMessage(\n *   payload,\n *   'https://api.example.com/data',\n *   { checkNonce: (n) => !usedNonces.has(n) }\n * );\n *\n * if (!result.valid) {\n *   return { error: result.error };\n * }\n * ```\n */\nexport async function validateSIWxMessage(\n  message: SIWxPayload,\n  expectedResourceUri: string,\n  options: SIWxValidationOptions = {},\n): Promise<SIWxValidationResult> {\n  const expectedUrl = new URL(expectedResourceUri);\n  const maxAge = options.maxAge ?? DEFAULT_MAX_AGE_MS;\n\n  // 1. Domain binding (spec: \"domain field MUST match server's domain\")\n  // Use hostname (without port) per EIP-4361 convention\n  if (message.domain !== expectedUrl.hostname) {\n    return {\n      valid: false,\n      error: `Domain mismatch: expected \"${expectedUrl.hostname}\", got \"${message.domain}\"`,\n    };\n  }\n\n  // 2. URI validation (spec: \"uri and resources must refer to base url of resource\")\n  // Allow the message URI to be the origin or the full resource URL\n  if (!message.uri.startsWith(expectedUrl.origin)) {\n    return {\n      valid: false,\n      error: `URI mismatch: expected origin \"${expectedUrl.origin}\", got \"${message.uri}\"`,\n    };\n  }\n\n  // 3. issuedAt validation (spec: \"MUST be recent, recommended < 5 minutes\")\n  const issuedAt = new Date(message.issuedAt);\n  if (isNaN(issuedAt.getTime())) {\n    return {\n      valid: false,\n      error: \"Invalid issuedAt timestamp\",\n    };\n  }\n\n  const age = Date.now() - issuedAt.getTime();\n  if (age > maxAge) {\n    return {\n      valid: false,\n      error: `Message too old: ${Math.round(age / 1000)}s exceeds ${maxAge / 1000}s limit`,\n    };\n  }\n  if (age < 0) {\n    return {\n      valid: false,\n      error: \"issuedAt is in the future\",\n    };\n  }\n\n  // 4. expirationTime validation (spec: \"MUST be in the future\")\n  if (message.expirationTime) {\n    const expiration = new Date(message.expirationTime);\n    if (isNaN(expiration.getTime())) {\n      return {\n        valid: false,\n        error: \"Invalid expirationTime timestamp\",\n      };\n    }\n    if (expiration < new Date()) {\n      return {\n        valid: false,\n        error: \"Message expired\",\n      };\n    }\n  }\n\n  // 5. notBefore validation (spec: \"if present, MUST be in the past\")\n  if (message.notBefore) {\n    const notBefore = new Date(message.notBefore);\n    if (isNaN(notBefore.getTime())) {\n      return {\n        valid: false,\n        error: \"Invalid notBefore timestamp\",\n      };\n    }\n    if (new Date() < notBefore) {\n      return {\n        valid: false,\n        error: \"Message not yet valid (notBefore is in the future)\",\n      };\n    }\n  }\n\n  // 6. Nonce validation (spec: \"MUST be unique per session to prevent replay attacks\")\n  if (options.checkNonce) {\n    const nonceValid = await options.checkNonce(message.nonce);\n    if (!nonceValid) {\n      return {\n        valid: false,\n        error: \"Nonce validation failed (possible replay attack)\",\n      };\n    }\n  }\n\n  return { valid: true };\n}\n","/**\n * EVM Sign-In-With-Ethereum (SIWE) support\n *\n * Implements EIP-4361 compliant message format and signature verification\n * for EVM chains (Ethereum, Base, Polygon, etc.)\n */\n\nimport { verifyMessage } from \"viem\";\nimport { SiweMessage } from \"siwe\";\nimport type { EVMMessageVerifier } from \"./types\";\nimport type { CompleteSIWxInfo } from \"./client\";\n\n/**\n * Extract numeric chain ID from CAIP-2 EVM chainId.\n *\n * @param chainId - CAIP-2 format chain ID (e.g., \"eip155:8453\")\n * @returns Numeric chain ID (e.g., 8453)\n * @throws Error if chainId format is invalid\n *\n * @example\n * ```typescript\n * extractEVMChainId(\"eip155:1\")    // 1 (Ethereum mainnet)\n * extractEVMChainId(\"eip155:8453\") // 8453 (Base)\n * extractEVMChainId(\"eip155:137\")  // 137 (Polygon)\n * ```\n */\nexport function extractEVMChainId(chainId: string): number {\n  const match = /^eip155:(\\d+)$/.exec(chainId);\n  if (!match) {\n    throw new Error(`Invalid EVM chainId format: ${chainId}. Expected eip155:<number>`);\n  }\n  return parseInt(match[1], 10);\n}\n\n/**\n * Format SIWE message following EIP-4361 specification.\n *\n * Uses the siwe library to ensure message format matches verification.\n *\n * @param info - Server-provided extension info\n * @param address - Client's EVM wallet address (0x-prefixed)\n * @returns Message string ready for signing\n *\n * @example\n * ```typescript\n * const message = formatSIWEMessage(serverInfo, \"0x1234...abcd\");\n * // Returns EIP-4361 formatted message:\n * // \"api.example.com wants you to sign in with your Ethereum account:\n * // 0x1234...abcd\n * //\n * // Sign in to access your content\n * //\n * // URI: https://api.example.com/data\n * // Version: 1\n * // Chain ID: 8453\n * // Nonce: abc123\n * // Issued At: 2024-01-01T00:00:00.000Z\"\n * ```\n */\nexport function formatSIWEMessage(info: CompleteSIWxInfo, address: string): string {\n  const numericChainId = extractEVMChainId(info.chainId);\n\n  const siweMessage = new SiweMessage({\n    domain: info.domain,\n    address,\n    statement: info.statement,\n    uri: info.uri,\n    version: info.version,\n    chainId: numericChainId,\n    nonce: info.nonce,\n    issuedAt: info.issuedAt,\n    expirationTime: info.expirationTime,\n    notBefore: info.notBefore,\n    requestId: info.requestId,\n    resources: info.resources,\n  });\n\n  return siweMessage.prepareMessage();\n}\n\n/**\n * Verify EVM signature.\n *\n * Supports:\n * - EOA signatures (standard ECDSA via EIP-191) - always available\n * - EIP-1271 (deployed smart contract wallets) - requires verifier\n * - EIP-6492 (counterfactual/pre-deploy smart wallets) - requires verifier\n *\n * @param message - The SIWE message that was signed\n * @param address - The claimed signer address\n * @param signature - The signature to verify\n * @param verifier - Optional message verifier for smart wallet support.\n *                   Pass publicClient.verifyMessage for EIP-1271/EIP-6492 support.\n *                   Without this, only EOA signatures are verified.\n * @returns true if signature is valid\n *\n * @example\n * ```typescript\n * // EOA-only verification (default, no RPC required)\n * const valid = await verifyEVMSignature(message, address, signature);\n *\n * // Smart wallet verification with viem PublicClient\n * import { createPublicClient, http } from 'viem';\n * import { base } from 'viem/chains';\n *\n * const publicClient = createPublicClient({ chain: base, transport: http() });\n * const valid = await verifyEVMSignature(\n *   message,\n *   address,\n *   signature,\n *   publicClient.verifyMessage\n * );\n * ```\n */\nexport async function verifyEVMSignature(\n  message: string,\n  address: string,\n  signature: string,\n  verifier?: EVMMessageVerifier,\n): Promise<boolean> {\n  const args = {\n    address: address as `0x${string}`,\n    message,\n    signature: signature as `0x${string}`,\n  };\n\n  if (verifier) {\n    // Use provided verifier (supports EIP-1271/EIP-6492 via RPC)\n    return verifier(args);\n  }\n\n  // Fallback to standalone verifyMessage (EOA only, no RPC)\n  return verifyMessage(args);\n}\n","/**\n * Signature verification for SIWX extension\n *\n * Routes to chain-specific verification based on chainId namespace:\n * - EVM (eip155:*): EOA by default, smart wallet (EIP-1271/EIP-6492) with verifier\n * - Solana (solana:*): Ed25519 signature verification via tweetnacl\n */\n\nimport { formatSIWEMessage, verifyEVMSignature } from \"./evm\";\nimport { formatSIWSMessage, verifySolanaSignature, decodeBase58 } from \"./solana\";\nimport type { SIWxPayload, SIWxVerifyResult, SIWxVerifyOptions, EVMMessageVerifier } from \"./types\";\n\n/**\n * Verify SIWX signature cryptographically.\n *\n * Routes to the appropriate chain-specific verification based on the\n * chainId namespace prefix:\n * - `eip155:*` → EVM verification (EOA by default, smart wallet with verifier)\n * - `solana:*` → Ed25519 signature verification\n *\n * @param payload - The SIWX payload containing signature\n * @param options - Optional verification options\n * @returns Verification result with recovered address if valid\n *\n * @example\n * ```typescript\n * // EOA-only verification (default)\n * const result = await verifySIWxSignature(payload);\n *\n * // Smart wallet verification\n * import { createPublicClient, http } from 'viem';\n * import { base } from 'viem/chains';\n *\n * const publicClient = createPublicClient({ chain: base, transport: http() });\n * const result = await verifySIWxSignature(payload, {\n *   evmVerifier: publicClient.verifyMessage,\n * });\n *\n * if (result.valid) {\n *   console.log('Verified wallet:', result.address);\n * } else {\n *   console.error('Verification failed:', result.error);\n * }\n * ```\n */\nexport async function verifySIWxSignature(\n  payload: SIWxPayload,\n  options?: SIWxVerifyOptions,\n): Promise<SIWxVerifyResult> {\n  try {\n    // Route by chain namespace\n    if (payload.chainId.startsWith(\"eip155:\")) {\n      return verifyEVMPayload(payload, options?.evmVerifier);\n    }\n\n    if (payload.chainId.startsWith(\"solana:\")) {\n      return verifySolanaPayload(payload);\n    }\n\n    return {\n      valid: false,\n      error: `Unsupported chain namespace: ${payload.chainId}. Supported: eip155:* (EVM), solana:* (Solana)`,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : \"Verification failed\",\n    };\n  }\n}\n\n/**\n * Verify EVM signature with optional smart wallet support.\n *\n * @param payload - The SIWX payload containing signature and message data\n * @param verifier - Optional message verifier for EIP-1271/EIP-6492 support\n * @returns Verification result with recovered address if valid\n */\nasync function verifyEVMPayload(\n  payload: SIWxPayload,\n  verifier?: EVMMessageVerifier,\n): Promise<SIWxVerifyResult> {\n  // Reconstruct SIWE message for verification\n  const message = formatSIWEMessage(\n    {\n      domain: payload.domain,\n      uri: payload.uri,\n      statement: payload.statement,\n      version: payload.version,\n      chainId: payload.chainId,\n      type: payload.type,\n      nonce: payload.nonce,\n      issuedAt: payload.issuedAt,\n      expirationTime: payload.expirationTime,\n      notBefore: payload.notBefore,\n      requestId: payload.requestId,\n      resources: payload.resources,\n    },\n    payload.address,\n  );\n\n  try {\n    const valid = await verifyEVMSignature(message, payload.address, payload.signature, verifier);\n\n    if (!valid) {\n      return {\n        valid: false,\n        error: \"Signature verification failed\",\n      };\n    }\n\n    return {\n      valid: true,\n      address: payload.address,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : \"Signature verification failed\",\n    };\n  }\n}\n\n/**\n * Verify Solana Ed25519 signature.\n *\n * Reconstructs the SIWS message and verifies using tweetnacl.\n *\n * @param payload - The SIWX payload containing signature and message data\n * @returns Verification result with recovered address if valid\n */\nfunction verifySolanaPayload(payload: SIWxPayload): SIWxVerifyResult {\n  // Reconstruct SIWS message\n  const message = formatSIWSMessage(\n    {\n      domain: payload.domain,\n      uri: payload.uri,\n      statement: payload.statement,\n      version: payload.version,\n      chainId: payload.chainId,\n      type: payload.type,\n      nonce: payload.nonce,\n      issuedAt: payload.issuedAt,\n      expirationTime: payload.expirationTime,\n      notBefore: payload.notBefore,\n      requestId: payload.requestId,\n      resources: payload.resources,\n    },\n    payload.address,\n  );\n\n  // Decode Base58 signature and public key\n  let signature: Uint8Array;\n  let publicKey: Uint8Array;\n\n  try {\n    signature = decodeBase58(payload.signature);\n    publicKey = decodeBase58(payload.address);\n  } catch (error) {\n    return {\n      valid: false,\n      error: `Invalid Base58 encoding: ${error instanceof Error ? error.message : \"decode failed\"}`,\n    };\n  }\n\n  // Validate signature length (Ed25519 signatures are 64 bytes)\n  if (signature.length !== 64) {\n    return {\n      valid: false,\n      error: `Invalid signature length: expected 64 bytes, got ${signature.length}`,\n    };\n  }\n\n  // Validate public key length (Ed25519 public keys are 32 bytes)\n  if (publicKey.length !== 32) {\n    return {\n      valid: false,\n      error: `Invalid public key length: expected 32 bytes, got ${publicKey.length}`,\n    };\n  }\n\n  // Verify Ed25519 signature\n  const valid = verifySolanaSignature(message, signature, publicKey);\n\n  if (!valid) {\n    return {\n      valid: false,\n      error: \"Solana signature verification failed\",\n    };\n  }\n\n  return {\n    valid: true,\n    address: payload.address,\n  };\n}\n","/**\n * CAIP-122 message construction for SIWX extension\n *\n * Constructs the canonical message string for signing.\n * Routes to chain-specific formatters based on chainId namespace.\n */\n\nimport { formatSIWEMessage } from \"./evm\";\nimport { formatSIWSMessage } from \"./solana\";\nimport type { CompleteSIWxInfo } from \"./client\";\n\n/**\n * Construct CAIP-122 compliant message string for signing.\n *\n * Routes to the appropriate chain-specific message formatter based on the\n * chainId namespace prefix:\n * - `eip155:*` → SIWE (EIP-4361) format via siwe library\n * - `solana:*` → SIWS format\n *\n * @param serverInfo - Server extension info with chain selected (includes chainId)\n * @param address - Client wallet address\n * @returns Message string ready for signing\n * @throws Error if chainId namespace is not supported\n *\n * @example\n * ```typescript\n * // EVM (Ethereum, Base, etc.)\n * const completeInfo = { ...extension.info, chainId: \"eip155:8453\", type: \"eip191\" };\n * const evmMessage = createSIWxMessage(completeInfo, \"0x1234...\");\n * ```\n */\nexport function createSIWxMessage(serverInfo: CompleteSIWxInfo, address: string): string {\n  // Route by chain namespace\n  if (serverInfo.chainId.startsWith(\"eip155:\")) {\n    return formatSIWEMessage(serverInfo, address);\n  }\n\n  if (serverInfo.chainId.startsWith(\"solana:\")) {\n    return formatSIWSMessage(serverInfo, address);\n  }\n\n  throw new Error(\n    `Unsupported chain namespace: ${serverInfo.chainId}. ` +\n      `Supported: eip155:* (EVM), solana:* (Solana)`,\n  );\n}\n","/**\n * Message signing for SIWX extension\n *\n * Client-side helpers for signing SIWX messages.\n * Supports both EVM (viem) and Solana wallet adapters.\n */\n\nimport { encodeBase58 } from \"./solana\";\n\n/**\n * Signer interface for EVM SIWX message signing.\n * Compatible with viem WalletClient and PrivateKeyAccount.\n */\nexport interface EVMSigner {\n  /** Sign a message and return hex-encoded signature */\n  signMessage: (args: { message: string; account?: unknown }) => Promise<string>;\n  /** Account object (for WalletClient) */\n  account?: { address: string };\n  /** Direct address (for PrivateKeyAccount) */\n  address?: string;\n}\n\n/**\n * Signer interface for Solana SIWX message signing.\n * Compatible with @solana/wallet-adapter and Phantom/Solflare wallet APIs.\n */\nexport interface SolanaSigner {\n  /** Sign a message and return raw signature bytes */\n  signMessage: (message: Uint8Array) => Promise<Uint8Array>;\n  /** Solana public key (Base58 encoded string or PublicKey-like object) */\n  publicKey: string | { toBase58: () => string };\n}\n\n/**\n * Union type for SIWX signers - supports both EVM and Solana wallets.\n */\nexport type SIWxSigner = EVMSigner | SolanaSigner;\n\n/**\n * Get address from an EVM signer.\n *\n * @param signer - EVM wallet signer instance\n * @returns The wallet address as a hex string\n */\nexport function getEVMAddress(signer: EVMSigner): string {\n  if (signer.account?.address) {\n    return signer.account.address;\n  }\n  if (signer.address) {\n    return signer.address;\n  }\n  throw new Error(\"EVM signer missing address\");\n}\n\n/**\n * Get address from a Solana signer.\n *\n * @param signer - Solana wallet signer instance\n * @returns The wallet address as a Base58 string\n */\nexport function getSolanaAddress(signer: SolanaSigner): string {\n  const pk = signer.publicKey;\n  return typeof pk === \"string\" ? pk : pk.toBase58();\n}\n\n/**\n * Sign a message with an EVM wallet.\n * Returns hex-encoded signature.\n *\n * @param message - The message to sign\n * @param signer - EVM wallet signer instance\n * @returns Hex-encoded signature\n */\nexport async function signEVMMessage(message: string, signer: EVMSigner): Promise<string> {\n  if (signer.account) {\n    return signer.signMessage({ message, account: signer.account });\n  }\n  return signer.signMessage({ message });\n}\n\n/**\n * Sign a message with a Solana wallet.\n * Returns Base58-encoded signature.\n *\n * @param message - The message to sign\n * @param signer - Solana wallet signer instance\n * @returns Base58-encoded signature\n */\nexport async function signSolanaMessage(message: string, signer: SolanaSigner): Promise<string> {\n  const messageBytes = new TextEncoder().encode(message);\n  const signatureBytes = await signer.signMessage(messageBytes);\n  return encodeBase58(signatureBytes);\n}\n","/**\n * Complete client flow for SIWX extension\n *\n * Combines message construction, signing, and payload creation.\n * Supports both EVM and Solana wallets.\n */\n\nimport type { SIWxExtensionInfo, SIWxPayload, SignatureType, SignatureScheme } from \"./types\";\nimport type { SIWxSigner, EVMSigner, SolanaSigner } from \"./sign\";\nimport { getEVMAddress, getSolanaAddress, signEVMMessage, signSolanaMessage } from \"./sign\";\nimport { createSIWxMessage } from \"./message\";\n\n/**\n * Complete SIWX info with chain-specific fields.\n * Used by utility functions that need the selected chain information.\n */\nexport type CompleteSIWxInfo = SIWxExtensionInfo & {\n  chainId: string;\n  type: SignatureType;\n  signatureScheme?: SignatureScheme;\n};\n\n/**\n * Create a complete SIWX payload from server extension info with selected chain.\n *\n * Routes to EVM or Solana signing based on the chainId prefix:\n * - `eip155:*` → EVM signing\n * - `solana:*` → Solana signing\n *\n * @param serverExtension - Server extension info with chain selected (includes chainId, type)\n * @param signer - Wallet that can sign messages (EVMSigner or SolanaSigner)\n * @returns Complete SIWX payload with signature\n *\n * @example\n * ```typescript\n * // EVM wallet\n * const completeInfo = { ...extension.info, chainId: \"eip155:8453\", type: \"eip191\" };\n * const payload = await createSIWxPayload(completeInfo, evmWallet);\n * ```\n */\nexport async function createSIWxPayload(\n  serverExtension: CompleteSIWxInfo,\n  signer: SIWxSigner,\n): Promise<SIWxPayload> {\n  const isSolana = serverExtension.chainId.startsWith(\"solana:\");\n\n  // Get address and sign based on chain type\n  const address = isSolana\n    ? getSolanaAddress(signer as SolanaSigner)\n    : getEVMAddress(signer as EVMSigner);\n\n  const message = createSIWxMessage(serverExtension, address);\n\n  const signature = isSolana\n    ? await signSolanaMessage(message, signer as SolanaSigner)\n    : await signEVMMessage(message, signer as EVMSigner);\n\n  return {\n    domain: serverExtension.domain,\n    address,\n    statement: serverExtension.statement,\n    uri: serverExtension.uri,\n    version: serverExtension.version,\n    chainId: serverExtension.chainId,\n    type: serverExtension.type,\n    nonce: serverExtension.nonce,\n    issuedAt: serverExtension.issuedAt,\n    expirationTime: serverExtension.expirationTime,\n    notBefore: serverExtension.notBefore,\n    requestId: serverExtension.requestId,\n    resources: serverExtension.resources,\n    signatureScheme: serverExtension.signatureScheme,\n    signature,\n  };\n}\n","/**\n * Header encoding for SIWX extension\n *\n * Encodes SIWX payload for the SIGN-IN-WITH-X HTTP header.\n * Per CHANGELOG-v2.md line 335: header should be base64-encoded.\n */\n\nimport { safeBase64Encode } from \"@x402/core/utils\";\nimport type { SIWxPayload } from \"./types\";\n\n/**\n * Encode SIWX payload for SIGN-IN-WITH-X header.\n *\n * Uses base64 encoding per x402 v2 spec (CHANGELOG-v2.md line 335).\n *\n * @param payload - Complete SIWX payload with signature\n * @returns Base64-encoded JSON string\n *\n * @example\n * ```typescript\n * const payload = await createSIWxPayload(serverInfo, signer);\n * const header = encodeSIWxHeader(payload);\n *\n * fetch(url, {\n *   headers: { 'SIGN-IN-WITH-X': header }\n * });\n * ```\n */\nexport function encodeSIWxHeader(payload: SIWxPayload): string {\n  return safeBase64Encode(JSON.stringify(payload));\n}\n","/**\n * Fetch wrapper for SIWX authentication.\n *\n * Provides a convenient wrapper around fetch that automatically handles\n * SIWX authentication when a 402 response includes SIWX extension info.\n */\n\nimport { decodePaymentRequiredHeader } from \"@x402/core/http\";\nimport type { SIWxSigner } from \"./sign\";\nimport type { SIWxExtension } from \"./types\";\nimport { SIGN_IN_WITH_X } from \"./types\";\nimport { createSIWxPayload } from \"./client\";\nimport { encodeSIWxHeader } from \"./encode\";\n\n/**\n * Wraps fetch to automatically handle SIWX authentication.\n *\n * When a 402 response is received with a SIWX extension:\n * 1. Extracts SIWX info from PAYMENT-REQUIRED header\n * 2. Creates signed SIWX proof using the provided signer\n * 3. Retries the request with the SIWX header\n *\n * If the 402 response doesn't include SIWX extension info, the original\n * response is returned unchanged (allowing payment handling to proceed).\n *\n * @param fetch - The fetch function to wrap (typically globalThis.fetch)\n * @param signer - Wallet signer (EVMSigner or SolanaSigner)\n * @returns A wrapped fetch function that handles SIWX authentication\n *\n * @example\n * ```typescript\n * import { wrapFetchWithSIWx } from '@x402/extensions/sign-in-with-x';\n * import { privateKeyToAccount } from 'viem/accounts';\n *\n * const signer = privateKeyToAccount(privateKey);\n * const fetchWithSIWx = wrapFetchWithSIWx(fetch, signer);\n *\n * // Request that may require SIWX auth (for returning paid users)\n * const response = await fetchWithSIWx('https://api.example.com/data');\n * ```\n */\nexport function wrapFetchWithSIWx(fetch: typeof globalThis.fetch, signer: SIWxSigner) {\n  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const request = new Request(input, init);\n    const clonedRequest = request.clone();\n\n    const response = await fetch(request);\n\n    if (response.status !== 402) {\n      return response;\n    }\n\n    // Extract SIWX info from 402 response\n    const paymentRequiredHeader = response.headers.get(\"PAYMENT-REQUIRED\");\n    if (!paymentRequiredHeader) {\n      return response; // No PAYMENT-REQUIRED header, return original response\n    }\n\n    const paymentRequired = decodePaymentRequiredHeader(paymentRequiredHeader);\n    const siwxExtension = paymentRequired.extensions?.[SIGN_IN_WITH_X] as SIWxExtension | undefined;\n\n    if (!siwxExtension?.supportedChains) {\n      return response; // Server doesn't support SIWX, return original 402\n    }\n\n    // Prevent infinite loops\n    if (clonedRequest.headers.has(SIGN_IN_WITH_X)) {\n      throw new Error(\"SIWX authentication already attempted\");\n    }\n\n    // Get network from payment requirements\n    const paymentNetwork = paymentRequired.accepts?.[0]?.network;\n    if (!paymentNetwork) {\n      return response; // No network in payment requirements\n    }\n\n    // Find matching chain in supportedChains\n    const matchingChain = siwxExtension.supportedChains.find(\n      chain => chain.chainId === paymentNetwork,\n    );\n\n    if (!matchingChain) {\n      return response; // Payment network not in SIWX supportedChains\n    }\n\n    // Build complete info with selected chain\n    const completeInfo = {\n      ...siwxExtension.info,\n      chainId: matchingChain.chainId,\n      type: matchingChain.type,\n    };\n\n    // Create and send SIWX proof\n    const payload = await createSIWxPayload(completeInfo, signer);\n    const siwxHeader = encodeSIWxHeader(payload);\n\n    clonedRequest.headers.set(SIGN_IN_WITH_X, siwxHeader);\n\n    return fetch(clonedRequest);\n  };\n}\n","/**\n * Storage interface for SIWX payment tracking.\n *\n * Implementations track which addresses have paid for which resources,\n * enabling SIWX authentication to grant access without re-payment.\n *\n * Optionally supports nonce tracking to prevent signature replay attacks.\n */\nexport interface SIWxStorage {\n  /**\n   * Check if an address has paid for a resource.\n   *\n   * @param resource - The resource path (e.g., \"/weather\")\n   * @param address - The wallet address to check\n   * @returns True if the address has paid for the resource\n   */\n  hasPaid(resource: string, address: string): boolean | Promise<boolean>;\n\n  /**\n   * Record that an address has paid for a resource.\n   *\n   * @param resource - The resource path\n   * @param address - The wallet address that paid\n   */\n  recordPayment(resource: string, address: string): void | Promise<void>;\n\n  /**\n   * Check if a nonce has already been used (optional).\n   *\n   * Implementing this method prevents signature replay attacks where\n   * an intercepted SIWX header could be reused by an attacker.\n   *\n   * @param nonce - The nonce from the SIWX payload\n   * @returns True if the nonce has been used\n   */\n  hasUsedNonce?(nonce: string): boolean | Promise<boolean>;\n\n  /**\n   * Record that a nonce has been used (optional).\n   *\n   * Called after successfully granting access via SIWX.\n   * Implementations should consider adding expiration to avoid unbounded growth.\n   *\n   * @param nonce - The nonce to record as used\n   */\n  recordNonce?(nonce: string): void | Promise<void>;\n}\n\n/**\n * In-memory implementation of SIWxStorage.\n *\n * Suitable for development and single-instance deployments.\n * For production multi-instance deployments, use a persistent storage implementation.\n */\nexport class InMemorySIWxStorage implements SIWxStorage {\n  private paidAddresses = new Map<string, Set<string>>();\n\n  /**\n   * Check if an address has paid for a resource.\n   *\n   * @param resource - The resource path\n   * @param address - The wallet address to check\n   * @returns True if the address has paid\n   */\n  hasPaid(resource: string, address: string): boolean {\n    return this.paidAddresses.get(resource)?.has(address.toLowerCase()) ?? false;\n  }\n\n  /**\n   * Record that an address has paid for a resource.\n   *\n   * @param resource - The resource path\n   * @param address - The wallet address that paid\n   */\n  recordPayment(resource: string, address: string): void {\n    if (!this.paidAddresses.has(resource)) {\n      this.paidAddresses.set(resource, new Set());\n    }\n    this.paidAddresses.get(resource)!.add(address.toLowerCase());\n  }\n}\n","/**\n * SIWX Lifecycle Hooks\n *\n * Pre-built hooks for integrating SIWX authentication with x402 servers and clients.\n */\n\nimport type { SIWxStorage } from \"./storage\";\nimport type { SIWxExtension, SIWxVerifyOptions } from \"./types\";\nimport type { SIWxSigner } from \"./sign\";\nimport { SIGN_IN_WITH_X } from \"./types\";\nimport { parseSIWxHeader } from \"./parse\";\nimport { validateSIWxMessage } from \"./validate\";\nimport { verifySIWxSignature } from \"./verify\";\nimport { createSIWxPayload } from \"./client\";\nimport { encodeSIWxHeader } from \"./encode\";\n\n/**\n * Options for creating server-side SIWX hooks.\n */\nexport interface CreateSIWxHookOptions {\n  /** Storage for tracking paid addresses */\n  storage: SIWxStorage;\n  /** Options for signature verification (e.g., EVM smart wallet support) */\n  verifyOptions?: SIWxVerifyOptions;\n  /** Optional callback for logging/debugging */\n  onEvent?: (event: SIWxHookEvent) => void;\n}\n\n/**\n * Events emitted by SIWX hooks for logging/debugging.\n */\nexport type SIWxHookEvent =\n  | { type: \"payment_recorded\"; resource: string; address: string }\n  | { type: \"access_granted\"; resource: string; address: string }\n  | { type: \"validation_failed\"; resource: string; error?: string }\n  | { type: \"nonce_reused\"; resource: string; nonce: string }\n  | { type: \"siwx_header_sent\"; resource: string };\n\n/**\n * Creates an onAfterSettle hook that records payments for SIWX.\n *\n * @param options - Hook configuration\n * @returns Hook function for x402ResourceServer.onAfterSettle()\n *\n * @example\n * ```typescript\n * const storage = new InMemorySIWxStorage();\n * const resourceServer = new x402ResourceServer(facilitator)\n *   .onAfterSettle(createSIWxSettleHook({ storage }));\n * ```\n */\nexport function createSIWxSettleHook(options: CreateSIWxHookOptions) {\n  const { storage, onEvent } = options;\n\n  return async (ctx: {\n    paymentPayload: { payload: unknown; resource: { url: string } };\n    result: { success: boolean; payer?: string };\n  }): Promise<void> => {\n    // Only record payment if settlement succeeded\n    if (!ctx.result.success) return;\n\n    // Get payer from facilitator's settle result (works for all payment schemes)\n    const address = ctx.result.payer;\n    if (!address) return;\n\n    const resource = new URL(ctx.paymentPayload.resource.url).pathname;\n    await storage.recordPayment(resource, address);\n    onEvent?.({ type: \"payment_recorded\", resource, address });\n  };\n}\n\n/**\n * Creates an onProtectedRequest hook that validates SIWX auth before payment.\n *\n * @param options - Hook configuration\n * @returns Hook function for x402HTTPResourceServer.onProtectedRequest()\n *\n * @example\n * ```typescript\n * const storage = new InMemorySIWxStorage();\n * const httpServer = new x402HTTPResourceServer(resourceServer, routes)\n *   .onProtectedRequest(createSIWxRequestHook({ storage }));\n * ```\n */\nexport function createSIWxRequestHook(options: CreateSIWxHookOptions) {\n  const { storage, verifyOptions, onEvent } = options;\n\n  // Validate nonce tracking is fully implemented or not at all\n  const hasUsedNonce = typeof storage.hasUsedNonce === \"function\";\n  const hasRecordNonce = typeof storage.recordNonce === \"function\";\n  if (hasUsedNonce !== hasRecordNonce) {\n    throw new Error(\n      \"SIWxStorage nonce tracking requires both hasUsedNonce and recordNonce to be implemented\",\n    );\n  }\n\n  return async (context: {\n    adapter: { getHeader(name: string): string | undefined; getUrl(): string };\n    path: string;\n  }): Promise<void | { grantAccess: true }> => {\n    // Try both cases for header (HTTP headers are case-insensitive)\n    const header =\n      context.adapter.getHeader(SIGN_IN_WITH_X) ||\n      context.adapter.getHeader(SIGN_IN_WITH_X.toLowerCase());\n    if (!header) return;\n\n    try {\n      const payload = parseSIWxHeader(header);\n      const resourceUri = context.adapter.getUrl();\n\n      const validation = await validateSIWxMessage(payload, resourceUri);\n      if (!validation.valid) {\n        onEvent?.({ type: \"validation_failed\", resource: context.path, error: validation.error });\n        return;\n      }\n\n      const verification = await verifySIWxSignature(payload, verifyOptions);\n      if (!verification.valid || !verification.address) {\n        onEvent?.({ type: \"validation_failed\", resource: context.path, error: verification.error });\n        return;\n      }\n\n      // Check if nonce was already used (prevents signature replay attacks)\n      if (storage.hasUsedNonce) {\n        const nonceUsed = await storage.hasUsedNonce(payload.nonce);\n        if (nonceUsed) {\n          onEvent?.({ type: \"nonce_reused\", resource: context.path, nonce: payload.nonce });\n          return;\n        }\n      }\n\n      const hasPaid = await storage.hasPaid(context.path, verification.address);\n      if (hasPaid) {\n        // Record nonce as used before granting access\n        if (storage.recordNonce) {\n          await storage.recordNonce(payload.nonce);\n        }\n\n        onEvent?.({\n          type: \"access_granted\",\n          resource: context.path,\n          address: verification.address,\n        });\n        return { grantAccess: true };\n      }\n    } catch (err) {\n      onEvent?.({\n        type: \"validation_failed\",\n        resource: context.path,\n        error: err instanceof Error ? err.message : \"Unknown error\",\n      });\n    }\n  };\n}\n\n/**\n * Creates an onPaymentRequired hook for client-side SIWX authentication.\n *\n * Uses the network from payment requirements to select the appropriate chain\n * from the server's supportedChains.\n *\n * @param signer - Wallet signer for creating SIWX proofs\n * @returns Hook function for x402HTTPClient.onPaymentRequired()\n *\n * @example\n * ```typescript\n * const httpClient = new x402HTTPClient(client)\n *   .onPaymentRequired(createSIWxClientHook(signer));\n * ```\n */\nexport function createSIWxClientHook(signer: SIWxSigner) {\n  return async (context: {\n    paymentRequired: { accepts?: Array<{ network: string }>; extensions?: Record<string, unknown> };\n  }): Promise<{ headers: Record<string, string> } | void> => {\n    const extensions = context.paymentRequired.extensions ?? {};\n    const siwxExtension = extensions[SIGN_IN_WITH_X] as SIWxExtension | undefined;\n\n    if (!siwxExtension?.supportedChains) return;\n\n    try {\n      // Get network from payment requirements\n      const paymentNetwork = context.paymentRequired.accepts?.[0]?.network;\n      if (!paymentNetwork) return;\n\n      // Find matching chain in supportedChains\n      const matchingChain = siwxExtension.supportedChains.find(\n        chain => chain.chainId === paymentNetwork,\n      );\n\n      if (!matchingChain) {\n        // Payment network not in SIWX supportedChains\n        return;\n      }\n\n      // Build complete info with selected chain\n      const completeInfo = {\n        ...siwxExtension.info,\n        chainId: matchingChain.chainId,\n        type: matchingChain.type,\n      };\n\n      const payload = await createSIWxPayload(completeInfo, signer);\n      const header = encodeSIWxHeader(payload);\n      return { headers: { [SIGN_IN_WITH_X]: header } };\n    } catch {\n      // Failed to create SIWX payload, continue to payment\n    }\n  };\n}\n"],"mappings":"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","names":[]}